<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Arcanum: The Grand Ritual</title>
    <style>
        /* --- Ê†∏ÂøÉÊ†∑Âºè (Core Styles) --- */
        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            font-family: 'Cinzel', serif; user-select: none; 
            -webkit-tap-highlight-color: transparent; 
        }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Noto+Serif+SC:wght@400;700&display=swap');

        /* --- ÂàùÂßãÁïåÈù¢ (Start Screen) --- */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 100;
            background: radial-gradient(circle at center, rgba(0,0,0,0.6) 0%, #000000 95%);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 1.5s ease; color: #d4af37;
        }

        .title-group { text-align: center; margin-bottom: 40px; animation: floatTitle 6s ease-in-out infinite; padding: 0 20px; }
        h1 { 
            font-size: 48px; margin: 0; letter-spacing: 12px; font-weight: 800;
            background: linear-gradient(135deg, #fff 0%, #d4af37 50%, #996515 100%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 20px rgba(212, 175, 55, 0.4));
        }
        h2 { 
            font-size: 12px; letter-spacing: 4px; color: #888; margin-top: 15px; 
            text-transform: uppercase; border-top: 1px solid rgba(212,175,55,0.3); padding-top: 15px; display: inline-block; 
        }
        @media (max-width: 768px) { h1 { font-size: 36px; letter-spacing: 6px; } }
        @keyframes floatTitle { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }

        /* ÈÄâÈ°πÊåâÈíÆ */
        .options-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 50px; text-align: center; }
        .option-group { display: flex; flex-direction: column; gap: 15px; align-items: center; }
        @media (max-width: 480px) { .options-grid { display: flex; flex-direction: column; gap: 20px; } }

        .choice-btn {
            background: rgba(255, 255, 255, 0.05); border: 1px solid #444; color: #888;
            padding: 12px 0; width: 160px; font-size: 12px; cursor: pointer;
            border-radius: 50px; transition: 0.3s; backdrop-filter: blur(4px); font-family: inherit;
        }
        .choice-btn.active { border-color: #d4af37; color: #fff; background: rgba(212, 175, 55, 0.15); box-shadow: 0 0 20px rgba(212, 175, 55, 0.15); }

        #enter-btn {
            background: transparent; color: #d4af37; border: 1px solid #d4af37;
            padding: 15px 80px; font-size: 16px; letter-spacing: 6px; cursor: pointer;
            font-weight: 700; border-radius: 50px; transition: 0.3s; font-family: 'Cinzel', serif;
        }
        #enter-btn:hover { background: #d4af37; color: #000; box-shadow: 0 0 40px rgba(212, 175, 55, 0.5); }

        /* --- Ê∏∏ÊàèÂÜÖ UI --- */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 20; pointer-events: none; opacity: 0; transition: opacity 1.5s; }
        
        #history-container {
            position: absolute; top: 20px; right: 20px;
            display: flex; gap: 10px; pointer-events: auto; z-index: 30;
        }
        .history-slot {
            width: 45px; height: 75px; background: #fff; border: 1px solid #d4af37; border-radius: 6px; overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.8); animation: slotEnter 0.6s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        .history-slot img { width: 100%; height: 100%; object-fit: cover; }
        .is-reversed img { transform: rotate(180deg); }
        @keyframes slotEnter { from { opacity:0; transform: translateY(-20px); } to { opacity:1; transform: translateY(0); } }

        #hud-center {
            position: absolute; bottom: 8%; width: 100%; text-align: center; color: #d4af37; 
            transition: opacity 0.5s; text-shadow: 0 2px 10px black;
        }
        #status-text { font-size: 12px; letter-spacing: 3px; font-weight: bold; text-transform: uppercase; }
        #gesture-icon { font-size: 32px; display: block; margin-bottom: 10px; opacity: 0.9; }

        /* ÁªìÊûúÂ±ïÁ§∫ */
        #final-text-container {
            position: absolute; top: 68%; width: 100%;
            display: flex; justify-content: center; gap: 20px;
            opacity: 0; transition: opacity 2s; pointer-events: none;
        }
        .final-card-label {
            width: 200px; text-align: center; display: flex; flex-direction: column; align-items: center;
            animation: textFloat 3s ease-in-out infinite alternate;
        }
        @media (max-width: 768px) {
            #final-text-container { top: 62%; gap: 5px; }
            .final-card-label { width: 32vw; }
        }
        .final-name { 
            font-size: 14px; font-weight: bold; color: #d4af37; 
            margin-bottom: 6px; border-bottom: 1px solid rgba(212,175,55,0.4); padding-bottom: 4px;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100%;
        }
        .final-meaning { font-size: 10px; color: #ccc; font-style: italic; line-height: 1.4; opacity: 0.8; }
        @keyframes textFloat { from { transform: translateY(0); } to { transform: translateY(-5px); } }

        #end-ui { position: absolute; bottom: 12%; width: 100%; text-align: center; opacity: 0; pointer-events: none; transition: opacity 1.5s; z-index: 50; }
        #restart-btn {
            background: rgba(0,0,0,0.8); border: 1px solid #d4af37; color: #d4af37;
            padding: 12px 50px; font-size: 12px; letter-spacing: 3px; 
            border-radius: 50px; cursor: pointer; pointer-events: auto; transition: 0.4s;
        }
        #restart-btn:hover { background: #d4af37; color: #000; box-shadow: 0 0 20px #d4af37; }
        
        #credits { position: absolute; bottom: 15px; right: 20px; text-align: right; color: #555; font-size: 9px; font-family: sans-serif; pointer-events: none;}

        #video-feed { position: absolute; bottom: 10px; right: 10px; width: 80px; opacity: 0; transform: scaleX(-1); border: 1px solid #d4af37; pointer-events: none; transition: opacity 0.5s; }
        #loader { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); color: #d4af37; font-size: 10px; letter-spacing: 4px; z-index: 200; }
        
        .sparkle { position: absolute; background: white; border-radius: 50%; pointer-events: none; opacity: 0; box-shadow: 0 0 10px #d4af37; animation: sparkleFloat linear forwards; }
        @keyframes sparkleFloat { 0% { opacity: 0; transform: scale(0); } 50% { opacity: 1; transform: translateY(-30px) scale(1); } 100% { opacity: 0; transform: translateY(-60px) scale(0); } }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>
    <div id="loader">INITIALIZING RITUAL...</div>

    <div id="start-screen">
        <div class="title-group">
            <h1>ARCANUM</h1>
            <h2>The Virtual Ritual</h2>
        </div>
        <div class="options-grid">
            <div class="option-group">
                <button class="choice-btn active" onclick="setLang('en')" id="btn-en">English</button>
                <button class="choice-btn" onclick="setLang('zh')" id="btn-zh">‰∏≠Êñá</button>
            </div>
            <div class="option-group">
                <button class="choice-btn active" onclick="setInput('hand')" id="btn-hand">Hand Gesture ‚úã</button>
                <button class="choice-btn" onclick="setInput('mouse')" id="btn-mouse">Touch / Mouse üñ±Ô∏è</button>
            </div>
        </div>
        <button id="enter-btn" onclick="enterExperience()">ENTER</button>
    </div>

    <div id="ui-layer">
        <div id="history-container"></div>
        <div id="final-text-container"></div>
        <div id="end-ui"><button id="restart-btn" onclick="location.reload()">RESTART RITUAL</button></div>
        <div id="credits">Jerry Hu & Gemini<br>huqiuzhi10@gmail.com</div>
        <div id="hud-center">
            <div id="gesture-icon">‚úã</div>
            <div id="status-text"></div>
        </div>
    </div>

    <video id="video-feed" playsinline></video>
    <div id="canvas-container"></div>

<script>
/**
 * =========================================
 * 1. CONFIGURATION & DATA
 * =========================================
 */
const CONFIG = {
    radius: 6.5,
    mobileRadius: 5.5,
    cardW: 1.5,
    cardH: 2.58,
    maxSelection: 3,
    goldColor: 0xd4af37
};

// Global State
let state = {
    lang: 'en',
    mode: 'hand',
    started: false,
    deck: [], // 3D Objects
    selectionCount: 0,
    isRitualComplete: false,
    chosenCards: [],
    activeCard: null,
    ringRotation: 0,
    targetRotation: 0,
    isDragging: false
};

const TEXTS = {
    en: { 
        statusWave: "Wave Hand / Drag Screen", 
        statusPinch: "Pinch / Tap to Select", 
        statusFist: "Fist / Tap Again to Reveal", 
        statusReturn: "Tap Empty Space to Return",
        revealing: "OBSERVING FATE...", 
        complete: "RITUAL COMPLETE", 
        rev: "Rev", 
        restart: "RESTART RITUAL",
        btnHand: "Hand Gesture ‚úã", btnMouse: "Touch / Mouse üñ±Ô∏è" 
    },
    zh: { 
        statusWave: "Êå•Êâã / ÊªëÂä®Â±èÂπïËΩ¨Âä®", 
        statusPinch: "ÊçèÂêà / ÁÇπÂáªÁâåÈù¢ÊäìÂèñ", 
        statusFist: "Êè°Êã≥ / ÂÜçÊ¨°ÁÇπÂáªÊè≠Á§∫", 
        statusReturn: "ÁÇπÂáªÁ©∫ÁôΩÂ§ÑÊîæÂõû",
        revealing: "Ê≠£Âú®ËßÇÊµãÂëΩËøê...", 
        complete: "‰ª™ÂºèÂÆåÊàê", 
        rev: "ÈÄÜ", 
        restart: "ÈáçÊñ∞ÂºÄÂßã‰ª™Âºè",
        btnHand: "ÊâãÂäøÊéßÂà∂ ‚úã", btnMouse: "Ëß¶Êéß / Èº†Ê†á üñ±Ô∏è" 
    }
};

const RWS_DATA = [
    { id: 0, en: { name: "The Fool", meaning: "New beginnings, innocence, spontaneity" }, zh: { name: "ÊÑöËÄÖ", meaning: "Êñ∞ÁöÑÂºÄÂßãÔºåÂ§©ÁúüÔºåËá™ÂèëÊÄßÔºåÂÜíÈô©" } },
    { id: 1, en: { name: "The Magician", meaning: "Manifestation, resourcefulness, power" }, zh: { name: "È≠îÊúØÂ∏à", meaning: "ÊòæÂåñÔºåËµÑÊ∫ê‰∏∞ÂØåÔºåÂäõÈáèÔºåÂàõÈÄ†Âäõ" } },
    { id: 2, en: { name: "High Priestess", meaning: "Intuition, sacred knowledge" }, zh: { name: "Â•≥Á•≠Âè∏", meaning: "Áõ¥ËßâÔºåÁ•ûÂú£Áü•ËØÜÔºåÊΩúÊÑèËØÜÔºåÁ•ûÁßò" } },
    { id: 3, en: { name: "The Empress", meaning: "Femininity, beauty, nature" }, zh: { name: "ÁöáÂêé", meaning: "Â•≥ÊÄßÂäõÈáèÔºåÁæé‰∏ΩÔºåËá™ÁÑ∂ÔºåÂ≠ïËÇ≤" } },
    { id: 4, en: { name: "The Emperor", meaning: "Authority, establishment" }, zh: { name: "ÁöáÂ∏ù", meaning: "ÊùÉÂ®ÅÔºå‰ΩìÂà∂ÔºåÁªìÊûÑÔºåÊéßÂà∂" } },
    { id: 5, en: { name: "The Hierophant", meaning: "Spiritual wisdom, beliefs" }, zh: { name: "ÊïôÁöá", meaning: "Á≤æÁ•ûÊô∫ÊÖßÔºå‰ø°‰ª∞Ôºå‰º†ÁªüÔºåÊïôÂØº" } },
    { id: 6, en: { name: "The Lovers", meaning: "Love, harmony, choices" }, zh: { name: "ÊÅã‰∫∫", meaning: "Áà±ÔºåÂíåË∞êÔºåÂÖ≥Á≥ªÔºåÈÄâÊã©" } },
    { id: 7, en: { name: "The Chariot", meaning: "Control, willpower, success" }, zh: { name: "ÊàòËΩ¶", meaning: "ÊéßÂà∂ÔºåÊÑèÂøóÂäõÔºåÊàêÂäüÔºåË°åÂä®" } },
    { id: 8, en: { name: "Strength", meaning: "Strength, courage, persuasion" }, zh: { name: "ÂäõÈáè", meaning: "ÂäõÈáèÔºåÂãáÊ∞îÔºåËØ¥ÊúçÔºåÂΩ±ÂìçÂäõ" } },
    { id: 9, en: { name: "The Hermit", meaning: "Soul-searching, introspection" }, zh: { name: "ÈöêÂ£´", meaning: "Êé¢Á¥¢ÂÜÖÂøÉÔºåÂÜÖÁúÅÔºåÁã¨Â§ÑÔºåÊåáÂºï" } },
    { id: 10, en: { name: "Wheel of Fortune", meaning: "Good luck, karma, destiny" }, zh: { name: "ÂëΩËøê‰πãËΩÆ", meaning: "Â•ΩËøêÔºå‰∏öÂäõÔºåÁîüÂëΩÂë®ÊúüÔºåÂëΩËøê" } },
    { id: 11, en: { name: "Justice", meaning: "Justice, fairness, truth" }, zh: { name: "Ê≠£‰πâ", meaning: "Ê≠£‰πâÔºåÂÖ¨Âπ≥ÔºåÁúüÁêÜÔºåÂõ†Êûú" } },
    { id: 12, en: { name: "Hanged Man", meaning: "Pause, surrender, letting go" }, zh: { name: "ÂÄíÂêä‰∫∫", meaning: "ÊöÇÂÅúÔºåËá£ÊúçÔºåÊîæÊâãÔºåÊñ∞ËßÜËßí" } },
    { id: 13, en: { name: "Death", meaning: "Endings, change, transformation" }, zh: { name: "Ê≠ªÁ•û", meaning: "ÁªìÊùüÔºåÊîπÂèòÔºåËΩ¨ÂåñÔºåËøáÊ∏°" } },
    { id: 14, en: { name: "Temperance", meaning: "Balance, moderation, patience" }, zh: { name: "ËäÇÂà∂", meaning: "Âπ≥Ë°°ÔºåÈÄÇÂ∫¶ÔºåËÄêÂøÉÔºåÁõÆÊ†á" } },
    { id: 15, en: { name: "The Devil", meaning: "Shadow self, addiction" }, zh: { name: "ÊÅ∂È≠î", meaning: "Èò¥ÊöóÈù¢ÔºåÊâßÁùÄÔºåÊàêÁòæÔºåÊùüÁºö" } },
    { id: 16, en: { name: "The Tower", meaning: "Sudden change, upheaval" }, zh: { name: "È´òÂ°î", meaning: "Á™ÅÂèòÔºåÂâßÂèòÔºåÊ∑∑‰π±ÔºåÂêØÁ§∫" } },
    { id: 17, en: { name: "The Star", meaning: "Hope, faith, renewal" }, zh: { name: "ÊòüÊòü", meaning: "Â∏åÊúõÔºå‰ø°ÂøµÔºåÁõÆÊ†áÔºåÊñ∞Áîü" } },
    { id: 18, en: { name: "The Moon", meaning: "Illusion, fear, anxiety" }, zh: { name: "Êúà‰∫Æ", meaning: "ÂπªËßâÔºåÊÅêÊÉßÔºåÁÑ¶ËôëÔºåÊΩúÊÑèËØÜ" } },
    { id: 19, en: { name: "The Sun", meaning: "Positivity, fun, warmth" }, zh: { name: "Â§™Èò≥", meaning: "ÁßØÊûÅÔºåÂø´‰πêÔºåÊ∏©ÊöñÔºåÊàêÂäü" } },
    { id: 20, en: { name: "Judgement", meaning: "Judgement, rebirth, calling" }, zh: { name: "ÂÆ°Âà§", meaning: "ÂÆ°Âà§ÔºåÈáçÁîüÔºåÂÜÖÂøÉÂè¨Âî§ÔºåËµ¶ÂÖç" } },
    { id: 21, en: { name: "The World", meaning: "Completion, integration" }, zh: { name: "‰∏ñÁïå", meaning: "ÂÆåÊàêÔºåÊï¥ÂêàÔºåÊàêÂ∞±ÔºåÂúÜÊª°" } }
];

// UI Helpers
function createSparkles() {
    const screen = document.getElementById('start-screen');
    if(screen.style.display === 'none') return; 
    const sparkle = document.createElement('div');
    sparkle.className = 'sparkle';
    sparkle.style.left = Math.random() * 100 + '%';
    sparkle.style.top = Math.random() * 100 + '%';
    const size = Math.random() * 3 + 1; 
    sparkle.style.width = size + 'px';
    sparkle.style.height = size + 'px';
    sparkle.style.animationDuration = (Math.random() * 2 + 1) + 's'; 
    screen.appendChild(sparkle);
    setTimeout(() => { sparkle.remove(); }, 3000);
}
setInterval(createSparkles, 300);

function setLang(l) { state.lang = l; updateUI(); }
function setInput(m) { state.mode = m; updateUI(); }
function updateUI() {
    const t = TEXTS[state.lang];
    document.querySelectorAll('.choice-btn').forEach(b => b.classList.remove('active'));
    document.getElementById(`btn-${state.lang}`).classList.add('active');
    document.getElementById(`btn-${state.mode}`).classList.add('active');
    document.getElementById('btn-hand').innerText = t.btnHand;
    document.getElementById('btn-mouse').innerText = t.btnMouse;
    document.getElementById('restart-btn').innerText = t.restart;
}

function updateStatus() {
    const t = TEXTS[state.lang];
    const el = document.getElementById('status-text');
    const icon = document.getElementById('gesture-icon');
    
    if (state.isRitualComplete) {
        el.innerText = t.complete;
        icon.innerText = "‚ú®";
        return;
    }

    if (state.activeCard) {
        if (state.activeCard.userData.state === 'REVEALING') {
            el.innerText = t.revealing;
            icon.innerText = "üîÆ";
        } else {
            // Â∑≤ÈÄâ‰∏≠Áä∂ÊÄÅÔºöÊèêÁ§∫ÂèØ‰ª•Êè≠Á§∫Ôºå‰πüÂèØ‰ª•ÂèñÊ∂à
            el.innerText = t.statusFist; // "Tap Again to Reveal"
            icon.innerText = state.mode === 'hand' ? "‚úä" : "üëÜ";
        }
    } else {
        // Á©∫Èó≤Áä∂ÊÄÅ
        el.innerText = t.statusWave;
        icon.innerText = state.mode === 'hand' ? "‚úã" : "‚ÜîÔ∏è";
    }
}

function enterExperience() {
    state.started = true;
    const screen = document.getElementById('start-screen');
    screen.style.opacity = 0;
    setTimeout(() => { screen.style.display = 'none'; }, 1500);
    document.getElementById('ui-layer').style.opacity = 1;
    
    spawnDeck();
    updateStatus();
    handleResize();

    // Â∞ùËØïÂºÄÂêØÊëÑÂÉèÂ§¥ÔºåÂ§±Ë¥•ÂàôÈùôÈªò
    if (state.mode === 'hand') {
        document.getElementById('video-feed').style.opacity = 0.3;
        initCamera();
    }
}

/**
 * =========================================
 * 2. THREE.JS SCENE & OBJECTS
 * =========================================
 */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);
scene.fog = new THREE.FogExp2(0x000000, 0.012);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
camera.position.set(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
document.getElementById('canvas-container').appendChild(renderer.domElement);

// Lights
const light = new THREE.DirectionalLight(0xffeaac, 0.8);
light.position.set(0, 2, 5);
scene.add(light);
scene.add(new THREE.AmbientLight(0xffffff, 0.6));

// Texture Loader
const texLoader = new THREE.TextureLoader();
const texBack = texLoader.load('./cards/back.png'); // Á°Æ‰øù‰Ω†ÁöÑÊñá‰ª∂ÂêçÊòØ back.png
texBack.center.set(0.5, 0.5);

// Star Particles
const starGeo = new THREE.BufferGeometry();
const starPos = new Float32Array(3000 * 3);
for(let i=0; i<3000*3; i++) starPos[i] = (Math.random() - 0.5) * 80;
starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({color: 0x888888, size: 0.05}));
scene.add(stars);

// Card Geometry
const shape = new THREE.Shape();
const w=CONFIG.cardW/2, h=CONFIG.cardH/2, r=CONFIG.cardH*0.05;
shape.moveTo(-w+r, -h); shape.lineTo(w-r, -h); shape.quadraticCurveTo(w, -h, w, -h+r);
shape.lineTo(w, h-r); shape.quadraticCurveTo(w, h, w-r, h);
shape.lineTo(-w+r, h); shape.quadraticCurveTo(-w, h, -w, h-r);
shape.lineTo(-w, -h+r); shape.quadraticCurveTo(-w, -h, -w+r, -h);
const cardGeo = new THREE.ShapeGeometry(shape);

// Fix UVs
const posAttr = cardGeo.attributes.position;
const uvAttr = cardGeo.attributes.uv;
for(let i=0; i<posAttr.count; i++){
    const x = posAttr.getX(i);
    const y = posAttr.getY(i);
    uvAttr.setXY(i, (x/CONFIG.cardW)+0.5, (y/CONFIG.cardH)+0.5);
}
cardGeo.attributes.uv.needsUpdate = true;

const deckGroup = new THREE.Group();
scene.add(deckGroup);

// Spawn Cards
function spawnDeck() {
    deckGroup.clear();
    state.deck = [];
    
    // Shuffle
    let dataList = [...RWS_DATA].sort(() => Math.random() - 0.5);
    
    const matBase = { roughness: 0.6, metalness: 0.1 };

    dataList.forEach((data, index) => {
        const group = new THREE.Group();
        // Load Image based on ID: 0.png, 1.png...
        const texFront = texLoader.load(`./cards/${data.id}.png`);
        texFront.center.set(0.5, 0.5);

        const meshBack = new THREE.Mesh(cardGeo, new THREE.MeshStandardMaterial({map: texBack, ...matBase}));
        meshBack.position.z = 0.005;
        
        const meshFront = new THREE.Mesh(cardGeo, new THREE.MeshStandardMaterial({map: texFront, ...matBase}));
        meshFront.rotation.y = Math.PI;
        meshFront.position.z = -0.005;

        const edges = new THREE.LineSegments(new THREE.EdgesGeometry(cardGeo), new THREE.LineBasicMaterial({color: CONFIG.goldColor}));
        
        group.add(meshBack, meshFront, edges);
        
        // Initial Ring Layout
        const angle = (index / dataList.length) * Math.PI * 2;
        const currentRadius = (window.innerWidth < 768) ? CONFIG.mobileRadius : CONFIG.radius;
        group.position.set(Math.sin(angle)*currentRadius, 0, -Math.cos(angle)*currentRadius);
        group.lookAt(0,0,0);
        
        group.userData = { id: data.id, info: data, state: 'IDLE', angle: angle };
        deckGroup.add(group);
        state.deck.push(group);
    });
    
    document.getElementById('loader').style.display = 'none';
}

/**
 * =========================================
 * 3. INTERACTION LOGIC (Improved)
 * =========================================
 */
// Unified Raycaster
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

// Interaction Variables
let startX = 0;
let startY = 0;
let startTime = 0;
let isInteracting = false;

// 1. Pointer Down (Touch Start / Mouse Down)
function handleStart(x, y) {
    if (state.isRitualComplete) return;
    isInteracting = true;
    startX = x;
    startY = y;
    startTime = Date.now();
    state.isDragging = false;
}

// 2. Pointer Move (Touch Move / Mouse Move)
function handleMove(x, y) {
    if (!isInteracting || state.isRitualComplete) return;

    const deltaX = x - startX;
    const deltaY = y - startY;

    // Detect Dragging
    if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
        state.isDragging = true;
    }

    // Rotate Ring if dragging and no card selected
    if (state.isDragging && !state.activeCard) {
        state.targetRotation += deltaX * 0.005;
        startX = x; // Reset reference
    }
}

// 3. Pointer Up (Touch End / Mouse Up)
function handleEnd(x, y) {
    if (!isInteracting || state.isRitualComplete) return;
    isInteracting = false;

    // Calculate duration
    const duration = Date.now() - startTime;

    // If it was a short tap and NOT a drag -> Click Event
    if (duration < 300 && !state.isDragging) {
        handleTap(x, y);
    }
    
    // Reset Drag state
    state.isDragging = false;
}

// Core Logic: What happens when you tap?
function handleTap(x, y) {
    // Normalize coordinates
    mouse.x = (x / window.innerWidth) * 2 - 1;
    mouse.y = -(y / window.innerHeight) * 2 + 1;
    
    raycaster.setFromCamera(mouse, camera);

    // Scenario A: Card is already selected (Floating in front)
    if (state.activeCard) {
        // Check if we hit the active card
        const intersectsActive = raycaster.intersectObject(state.activeCard, true);
        
        if (intersectsActive.length > 0) {
            // Hit the active card -> Reveal it
            revealCard(state.activeCard);
        } else {
            // Hit empty space -> Deselect (Return to ring)
            returnCard(state.activeCard);
        }
        return;
    }

    // Scenario B: No card selected (Ring mode)
    // Check if we hit any card in the ring
    const intersectsDeck = raycaster.intersectObjects(deckGroup.children, true);
    
    if (intersectsDeck.length > 0) {
        // Find the root group of the clicked card
        let target = intersectsDeck[0].object;
        while(target.parent !== deckGroup) {
            target = target.parent;
        }
        
        if (target.userData.state === 'IDLE') {
            selectCard(target);
        }
    }
}

// Bind Events
window.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY));
window.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
window.addEventListener('mouseup', e => handleEnd(e.clientX, e.clientY));

window.addEventListener('touchstart', e => handleStart(e.touches[0].clientX, e.touches[0].clientY), {passive: false});
window.addEventListener('touchmove', e => handleMove(e.touches[0].clientX, e.touches[0].clientY), {passive: false});
window.addEventListener('touchend', e => {
    // Touch end doesn't have clientX, use last known position or simplified logic
    // Usually changedTouches contains info
    const touch = e.changedTouches[0];
    handleEnd(touch.clientX, touch.clientY);
});


/**
 * =========================================
 * 4. CARD ACTIONS
 * =========================================
 */
function selectCard(card) {
    if (state.selectionCount >= CONFIG.maxSelection) return;
    
    state.activeCard = card;
    card.userData.state = 'SELECTED';
    scene.attach(card); // Move to scene root for easier control
    updateStatus();
}

function returnCard(card) {
    deckGroup.attach(card); // Put back in group
    card.userData.state = 'RETURNING';
    state.activeCard = null;
    updateStatus();
}

function revealCard(card) {
    if (card.userData.state === 'REVEALING') return;
    card.userData.state = 'REVEALING';
    updateStatus();

    const isReversed = Math.random() < 0.5;
    card.userData.isReversed = isReversed;

    // Flip Animation
    const targetZ = isReversed ? Math.PI : 0;
    new TWEEN.Tween(card.rotation)
        .to({ z: targetZ, y: Math.PI }, 800)
        .easing(TWEEN.Easing.Quadratic.Out)
        .onComplete(() => {
            setTimeout(() => dissolveCard(card), 1000);
        })
        .start();
}

function dissolveCard(card) {
    spawnParticles(card.position); // Explosion effect
    state.selectionCount++;
    state.chosenCards.push(card);
    card.visible = false; 
    addHistory(card.userData);
    
    state.activeCard = null;
    
    if (state.selectionCount >= CONFIG.maxSelection) {
        finishRitual();
    } else {
        updateStatus();
    }
}

// Particle System
const particles = [];
function spawnParticles(pos) {
    const count = 300;
    const pGeo = new THREE.BufferGeometry();
    const pPos = new Float32Array(count*3);
    const pVel = new Float32Array(count*3);
    
    for(let i=0; i<count; i++) {
        pPos[i*3] = pos.x + (Math.random()-0.5);
        pPos[i*3+1] = pos.y + (Math.random()-0.5);
        pPos[i*3+2] = pos.z;
        
        pVel[i*3] = (Math.random()-0.5) * 0.05;
        pVel[i*3+1] = (Math.random()-0.5) * 0.05;
        pVel[i*3+2] = (Math.random()-0.5) * 0.05;
    }
    pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
    const pMat = new THREE.PointsMaterial({color: CONFIG.goldColor, size: 0.05, transparent: true});
    const pSys = new THREE.Points(pGeo, pMat);
    pSys.userData = { life: 1.0, velocity: pVel };
    scene.add(pSys);
    particles.push(pSys);
}

function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        const sys = particles[i];
        sys.userData.life -= 0.02;
        const pos = sys.geometry.attributes.position.array;
        const vel = sys.userData.velocity;
        
        for(let j=0; j<pos.length/3; j++) {
            pos[j*3] += vel[j*3];
            pos[j*3+1] += vel[j*3+1];
            pos[j*3+2] += vel[j*3+2];
        }
        sys.geometry.attributes.position.needsUpdate = true;
        sys.material.opacity = sys.userData.life;
        
        if (sys.userData.life <= 0) {
            scene.remove(sys);
            particles.splice(i, 1);
        }
    }
}

/**
 * =========================================
 * 5. FINAL RITUAL & UTIL
 * =========================================
 */
function addHistory(info) {
    const con = document.getElementById('history-container');
    const div = document.createElement('div');
    div.className = 'history-slot ' + (info.isReversed ? 'is-reversed' : '');
    div.innerHTML = `<img src="./cards/${info.id}.png">`;
    con.appendChild(div);
}

function finishRitual() {
    state.isRitualComplete = true;
    updateStatus();
    
    document.getElementById('hud-center').style.opacity = 0;
    setTimeout(() => {
        document.getElementById('end-ui').style.opacity = 1;
        document.getElementById('end-ui').style.pointerEvents = 'auto';
        document.getElementById('credits').style.opacity = 1;
    }, 1500);

    // Drop unused cards
    state.deck.forEach(c => {
        if (!state.chosenCards.includes(c)) {
            new TWEEN.Tween(c.position).to({y: -15}, 2000).delay(Math.random()*500).start();
        }
    });

    // Arrange chosen cards
    const isMobile = window.innerWidth < 768;
    const gap = isMobile ? 1.6 : 2.5; 
    const finalZ = isMobile ? -7 : -6;
    
    state.chosenCards.forEach((card, i) => {
        card.visible = true;
        scene.attach(card);
        card.scale.set(0.1, 0.1, 0.1); // Reset scale
        
        const tx = (i - 1) * gap;
        
        new TWEEN.Tween(card.position)
            .to({ x: tx, y: 0, z: finalZ }, 1500)
            .easing(TWEEN.Easing.Cubic.Out)
            .delay(i*300)
            .start();
            
        new TWEEN.Tween(card.scale)
            .to({ x: 0.6, y: 0.6, z: 0.6 }, 1500)
            .delay(i*300)
            .start();
            
        card.rotation.set(0, Math.PI, card.userData.isReversed ? Math.PI : 0);
        
        // Add text labels
        const textCon = document.getElementById('final-text-container');
        const div = document.createElement('div');
        div.className = 'final-card-label';
        const info = card.userData.info[state.lang];
        div.innerHTML = `
            <div class="final-name">${info.name} ${card.userData.isReversed ? '('+TEXTS[state.lang].rev+')' : ''}</div>
            <div class="final-meaning">${info.meaning}</div>
        `;
        textCon.appendChild(div);
    });
    setTimeout(() => { document.getElementById('final-text-container').style.opacity = 1; }, 2000);
}

// Camera / Resize Logic
function handleResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    // Move camera back on mobile portrait to fit ring
    if (window.innerWidth < window.innerHeight) {
        camera.position.z = 6.5; 
    } else {
        camera.position.z = 0;
    }
}
window.addEventListener('resize', handleResize);

// Hand Tracking Init (Try Catch)
function initCamera() {
    const video = document.getElementById('video-feed');
    const hands = new Hands({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
    hands.setOptions({maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5});
    hands.onResults(res => {
        if(res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
            const lm = res.multiHandLandmarks[0];
            const x = lm[8].x; 
            const y = lm[8].y;
            // Map hand to screen roughly
            // Simple gesture check: Pinch (Thumb Tip 4 close to Index Tip 8)
            const pinchDist = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
            const isFist = lm[12].y > lm[9].y; // Middle finger down
            
            // Map gestures to our unified logic
            // Move -> Scroll Ring
            if (!state.activeCard && pinchDist > 0.1) {
                state.targetRotation += (x - 0.5) * 0.05;
            }
            
            // Interaction trigger via gestures can be mapped here if needed
            // For stability, we rely mostly on touch/click, but visual feedback remains
            document.getElementById('gesture-icon').innerText = isFist ? "‚úä" : (pinchDist<0.05 ? "üëå" : "‚úã");
        }
    });
    
    const cam = new Camera(video, {
        onFrame: async () => { await hands.send({image: video}); },
        width: 320, height: 240
    });
    cam.start().catch(e => console.warn("Camera init failed, using fallback inputs.", e));
}

// Main Loop
function animate() {
    requestAnimationFrame(animate);
    TWEEN.update();
    
    // Smooth Ring Rotation
    if (!state.isRitualComplete) {
        deckGroup.rotation.y += (state.targetRotation - deckGroup.rotation.y) * 0.1;
    }
    
    // Stars
    stars.rotation.y += 0.0005;
    
    // Active Card Hover Logic
    if (state.activeCard && state.activeCard.userData.state === 'SELECTED') {
        // Smoothly interpolate to front of camera
        state.activeCard.position.lerp(new THREE.Vector3(0, 0, camera.position.z - 2.5), 0.1);
        // Reset rotations
        state.activeCard.rotation.x *= 0.9;
        state.activeCard.rotation.z *= 0.9;
        state.activeCard.lookAt(camera.position);
    }
    
    // Returning Logic
    state.deck.forEach(card => {
        if (card.userData.state === 'RETURNING') {
            const r = (window.innerWidth < 768) ? CONFIG.mobileRadius : CONFIG.radius;
            const targetPos = new THREE.Vector3(
                Math.sin(card.userData.angle) * r,
                0,
                -Math.cos(card.userData.angle) * r
            );
            card.position.lerp(targetPos, 0.1);
            
            // Reset rotation to look at center
            const dummy = new THREE.Object3D();
            dummy.position.copy(card.position);
            dummy.lookAt(0,0,0);
            card.quaternion.slerp(dummy.quaternion, 0.1);
            
            if (card.position.distanceTo(targetPos) < 0.05) {
                card.userData.state = 'IDLE';
            }
        }
    });

    updateParticles();
    renderer.render(scene, camera);
}
animate();

</script>
</body>
</html>
