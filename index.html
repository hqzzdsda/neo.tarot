<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Arcanum: Final Ritual</title>
    <style>
        /* --- å…¨å±€æ ·å¼ (Global Styles) --- */
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Times New Roman', 'Songti SC', 'SimSun', serif; 
            user-select: none; 
            -webkit-tap-highlight-color: transparent; 
        }
        #canvas-container { 
            width: 100vw; 
            height: 100vh; 
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 1; 
        }

        /* é»˜è®¤é¼ æ ‡æ˜¯æŒ‡é’ˆ */
body {
    cursor: default; 
}

/* å½“é¼ æ ‡æ‚¬åœåœ¨ä¸­è½´åŒºåŸŸæ—¶ (JSæ§åˆ¶ç±»å) */
body.can-grab {
    cursor: grab;
}
body.is-grabbing {
    cursor: grabbing;
}
        
        /* --- åˆå§‹ç•Œé¢ (Start Screen) --- */
        #start-screen {
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            z-index: 100;
            background: radial-gradient(circle at center, rgba(0,0,0,0.4) 0%, rgba(0,0,0,0.95) 90%);
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center;
            transition: opacity 1.5s cubic-bezier(0.25, 1, 0.5, 1);
            color: #d4af37;
            padding: 20px;
            box-sizing: border-box;
        }

        /* æ ‡é¢˜åŠ¨ç”»ä¸æ ·å¼ */
        .title-group { 
            text-align: center; 
            margin-bottom: 5vh; 
            position: relative;
            animation: floatTitle 6s ease-in-out infinite; 
        }
        
        h1 { 
            font-size: 72px; 
            margin: 0; 
            letter-spacing: 20px; 
            font-weight: 800;
            background: linear-gradient(135deg, #fff 0%, #d4af37 50%, #996515 100%);
            -webkit-background-clip: text; 
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 20px rgba(212, 175, 55, 0.4));
            position: relative;
        }
        
        h2 { 
            font-size: 14px; 
            font-weight: 400; 
            letter-spacing: 8px; 
            color: #a0a0a0; 
            margin-top: 15px; 
            text-transform: uppercase; 
            opacity: 0.8;
            border-top: 1px solid rgba(212, 175, 55, 0.3); 
            display: inline-block; 
            padding-top: 15px; 
            width: 120%; 
            margin-left: -10%;
        }

        @keyframes floatTitle {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        /* é€‰é¡¹æŒ‰é’®ç½‘æ ¼ */
        .options-grid { 
            display: grid; 
            grid-template-columns: 1fr 1fr; 
            gap: 60px; 
            margin-bottom: 5vh; 
            text-align: center; 
            opacity: 0; 
            animation: fadeUp 1s ease-out 0.5s forwards; 
        }
        .option-group { 
            display: flex; 
            flex-direction: column; 
            gap: 20px; 
            align-items: center; 
        }
        .option-label { 
            font-size: 11px; 
            letter-spacing: 3px; 
            color: #666; 
            text-transform: uppercase; 
            margin-bottom: 5px; 
            font-weight: 600;
        }

        /* èƒ¶å›ŠæŒ‰é’®æ ·å¼ */
        .choice-btn {
            background: rgba(255, 255, 255, 0.03); 
            border: 1px solid rgba(212, 175, 55, 0.3); 
            color: #888;
            padding: 12px 0; 
            width: 160px;
            font-family: inherit; 
            font-size: 12px; 
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
            border-radius: 50px; 
            position: relative; 
            overflow: hidden;
            backdrop-filter: blur(2px);
        }
        
        .choice-btn.active { 
            border-color: #d4af37; 
            color: #fff; 
            background: rgba(212, 175, 55, 0.15); 
            box-shadow: 0 0 25px rgba(212, 175, 55, 0.15);
        }
        
        .choice-btn:hover { 
            border-color: #fff; 
            color: #fff; 
            transform: translateY(-2px); 
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }

        /* è¿›å…¥æŒ‰é’®ç‰¹æ•ˆ */
        #enter-btn {
            background: transparent; 
            color: #d4af37; 
            border: 1px solid #d4af37;
            padding: 18px 80px; 
            font-size: 16px; 
            letter-spacing: 8px; 
            cursor: pointer;
            font-family: inherit; 
            font-weight: 600; 
            border-radius: 50px; 
            transition: all 0.5s;
            position: relative; 
            overflow: hidden;
            opacity: 0; 
            animation: fadeUp 1s ease-out 0.8s forwards;
        }
        
        #enter-btn::before {
            content: ''; 
            position: absolute; 
            top: 0; 
            left: -100%; 
            width: 100%; 
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(212, 175, 55, 0.2), transparent);
            transition: 0.5s;
        }
        #enter-btn:hover::before { left: 100%; transition: 0.7s; }
        #enter-btn:hover { 
            background: #d4af37; 
            color: #000; 
            box-shadow: 0 0 40px rgba(212, 175, 55, 0.4); 
            transform: scale(1.05); 
            letter-spacing: 10px;
        }

        @keyframes fadeUp { 
            from { opacity: 0; transform: translateY(20px); } 
            to { opacity: 1; transform: translateY(0); } 
        }

        /* ç¥ç§˜å­¦é—ªå…‰ç²’å­ */
        .sparkle {
            position: absolute; 
            background: white; 
            border-radius: 50%;
            pointer-events: none; 
            opacity: 0;
            box-shadow: 0 0 10px #d4af37, 0 0 20px #d4af37;
            animation: sparkleFloat linear forwards;
        }
        @keyframes sparkleFloat {
            0% { opacity: 0; transform: translateY(0) scale(0); }
            50% { opacity: 1; transform: translateY(-50px) scale(1); }
            100% { opacity: 0; transform: translateY(-100px) scale(0); }
        }

        /* --- æ¸¸æˆå†… UI å±‚ --- */
        #ui-layer { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: 20; 
            pointer-events: none; 
            color: #d4af37; 
            opacity: 0; 
            transition: opacity 1.5s; 
            /* --- æ–°å¢ï¼šä¸­è½´æŒ‡é’ˆ (Axis Markers) --- */
            #axis-markers {
    position: absolute;
    top: 0;
    left: 50%;
    /* å±…ä¸­è‡ªèº« */
    transform: translateX(-50%);
    
    width: 2px; /* æç»†çš„ä¸­è½´çº¿å®¹å™¨ */
    height: 100%;
    
    /* âš ï¸ æ ¸å¿ƒå±‚çº§æ§åˆ¶ï¼š
       è™½ç„¶ Z-index æ¯” Canvas é«˜ï¼Œä½†é€šè¿‡é€æ˜åº¦å’Œæ··åˆæ¨¡å¼ï¼Œ
       è®©å®ƒè¡¨ç°å¾—åƒæ˜¯åœ¨â€œèƒŒæ™¯â€é‡Œï¼Œä¸ä¼šé®æŒ¡å¡ç‰Œå†…å®¹ */
    z-index: 5; 
    pointer-events: none; /* ç»å¯¹ç©¿é€ */
    opacity: 0.4; /* ä½å¯¹æ¯”åº¦ï¼Œä¼¼æœ‰è‹¥æ—  */
}

/* ä¸ŠæŒ‡é’ˆ (Top Pointer) */
#axis-markers::before {
    content: '';
    position: absolute;
    top: 20%; /* è·ç¦»é¡¶éƒ¨çš„ä½ç½®ï¼Œé¿å¼€å¡ç‰ŒåŒºåŸŸ */
    left: 50%;
    transform: translateX(-50%);
    
    /* å½¢çŠ¶ï¼šç»†é•¿è±å½¢æˆ–é’ˆå°– */
    width: 1px;
    height: 30px; 
    background: linear-gradient(to bottom, transparent, #ccd437);
}
/* ä¸ŠæŒ‡é’ˆçš„è£…é¥°ç‚¹ (12ç‚¹é’Ÿåˆ»åº¦æ„Ÿ) */
#axis-markers::after {
    content: '';
    position: absolute;
    top: calc(20% + 35px); /* åœ¨çº¿æ¡ä¸‹æ–¹ä¸€ç‚¹ */
    left: 50%;
    transform: translateX(-50%) rotate(45deg);
    
    width: 4px;
    height: 4px;
    border: 1px solid #ccd437;
    background: transparent;
    opacity: 0.6;
}

/* ä¸‹æŒ‡é’ˆ (Bottom Pointer) */
/* ä¸ºäº†ä»£ç æ•´æ´ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ªå­å…ƒç´ æ¥åšä¸‹æŒ‡é’ˆ */
.bottom-marker {
    position: absolute;
    bottom: 12%; /* è·ç¦»åº•éƒ¨çš„ä½ç½® */
    left: 50%;
    transform: translateX(-50%);
    width: 100%;
    height: 100%;
}

.bottom-marker::before {
    content: '';
    position: absolute;
    bottom: 20%;
    left: 50%;
    transform: translateX(-50%);
    
    width: 1px;
    height: 30px; 
    background: linear-gradient(to top, transparent, #ccd437);
}

.bottom-marker::after {
    content: '';
    position: absolute;
    bottom: calc(20% + 35px); /* åœ¨çº¿æ¡ä¸Šæ–¹ä¸€ç‚¹ */
    left: 50%;
    transform: translateX(-50%) rotate(45deg);
    
    width: 4px;
    height: 4px;
    border: 1px solid #ccd437;
    background: transparent;
    opacity: 0.6;
}

        }
        
        /* å†å²è®°å½•æ  */
        #history-container {
            position: absolute; 
            top: 20px; 
            right: 20px;
            display: flex; 
            flex-direction: row; 
            gap: 15px;
            pointer-events: auto; 
            z-index: 30; 
            height: 100px; 
            align-items: flex-start;
            transition: opacity 1s ease;
        }
        .history-slot {
            width: 50px; 
            height: 85px; 
            background: #fff; 
            border: 2px solid #d4af37; 
            border-radius: 8px; 
            overflow: hidden;
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: flex-end;
            box-shadow: 0 4px 15px rgba(0,0,0,0.8); 
            flex-shrink: 0; 
            position: relative;
            animation: slotEnter 0.6s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        @keyframes slotEnter { 
            from { opacity:0; transform: translateY(-20px); } 
            to { opacity:1; transform: translateY(0); } 
        }
        .history-slot img { position: absolute; top:0; left:0; width: 100%; height: 100%; object-fit: cover; }
        .history-info { position: relative; z-index: 2; width: 100%; background: rgba(0,0,0,0.8); text-align: center; padding: 2px 0; border-top: 1px solid #d4af37; }
        .history-name { font-size: 8px; color: #d4af37; font-weight: 700; white-space: nowrap; transform: scale(0.9); }
        .history-rev { font-size: 7px; color: #ff3333; display: none; font-weight: bold; background: rgba(0,0,0,0.5); width:100%; }
        .is-reversed img { transform: rotate(180deg); }
        .is-reversed .history-rev { display: block; }

        /* åº•éƒ¨ HUD */
        #hud-center {
            position: absolute; 
            bottom: 8%; 
            left: 50%; 
            transform: translateX(-50%);
            text-align: center; 
            color: #d4af37; 
            pointer-events: none; 
            width: 100%;
            background: transparent;
            border-radius: 0;
        }

        /* æŒ‰ä¸‹æ—¶çš„åé¦ˆ */
        #hud-center:active {
        transform: none; background: transparent;
        }

        #gesture-icon { font-size: 32px; display: block; margin-bottom: 10px; opacity: 0.9; text-shadow: 0 0 15px #d4af37;}
        #status-text { font-size: 11px; letter-spacing: 4px; text-transform: uppercase; font-weight: 600; opacity: 0.8; }


        /* æœ€ç»ˆç»“æœæ–‡å­—å®¹å™¨ */
        #final-text-container {
            position: absolute; 
            top: 65%; /* ç¨å¾®ä¸Šç§»ä»¥é€‚é…å°å±å¹• */
            left: 0; 
            width: 100%;
            text-align: center; 
            opacity: 0; 
            transition: opacity 2s;
            pointer-events: none; 
            display: flex; 
            justify-content: center; 
            gap: 120px; /* æ¡Œé¢ç«¯é—´è·æ”¹å¤§ */
            flex-wrap: wrap; /* å…è®¸æ¢è¡Œ */
            padding: 0 20px;
            box-sizing: border-box;
        }
        .final-card-label {
            display: flex; 
            flex-direction: column; 
            width: 220px; 
            color: #fff; 
            text-shadow: 0 0 10px #d4af37; 
            text-align: center;
            animation: textFloat 3s ease-in-out infinite alternate;
            margin-bottom: 20px;
        }
        @keyframes textFloat { from { transform: translateY(0); } to { transform: translateY(-5px); } }
        
        .final-name { font-size: 15px; font-weight: bold; color: #d4af37; margin-bottom: 8px; border-bottom: 1px solid rgba(212, 175, 55, 0.3); padding-bottom: 5px; }
        .final-meaning { font-size: 11px; color: #ccc; font-style: italic; line-height: 1.5; opacity: 0.8; }

        /* é‡å¯æŒ‰é’®åŒºåŸŸ (åŒ…å«æŸ¥çœ‹æŒ‡å¼•) */
        #end-ui {
            position: absolute; 
            bottom: 12%; 
            left: 0; 
            width: 100%;
            display: flex; 
            flex-direction: column; /* å‚ç›´æ’åˆ— */
            align-items: center;
            justify-content: center;
            opacity: 0; 
            pointer-events: none; 
            transition: opacity 1.5s; 
            z-index: 50;
            gap: 20px;
        }
        
        #restart-btn {
            background: rgba(0,0,0,0.7); 
            border: 1px solid #d4af37; 
            color: #d4af37;
            padding: 12px 50px; 
            font-size: 13px; 
            letter-spacing: 4px; 
            border-radius: 50px; 
            cursor: pointer; 
            font-family: inherit; 
            transition: 0.4s;
            backdrop-filter: blur(5px);
        }
        #restart-btn:hover { background: #d4af37; color: #000; box-shadow: 0 0 25px rgba(212, 175, 55, 0.6); }

        /* æ–°å¢ï¼šæŸ¥çœ‹æŒ‡å¼•æŒ‰é’® */
        #view-reading-btn {
            background: #d4af37;  /* é‡‘è‰²èƒŒæ™¯ */
            color: #000;          /* é»‘è‰²æ–‡å­— */
            border: 1px solid #d4af37;
            padding: 15px 60px;
            font-size: 14px;
            letter-spacing: 4px;
            border-radius: 50px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            transition: 0.4s;
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.4);
        }
        #view-reading-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 40px rgba(212, 175, 55, 0.8);
        }

        /* æ–°å¢ï¼šè§£è¯´æ–‡å­—å…¨å±å®¹å™¨ */
        #oracle-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 700px;
            text-align: center;
            color: #fff;
            font-size: 18px;        
            line-height: 2.0;       
            font-family: 'Noto Serif SC', serif;
            text-shadow: 0 0 10px #d4af37;
            z-index: 60;
            pointer-events: none; /* å¼€å§‹æ—¶ä¸å¯ç‚¹å‡» */
            opacity: 1;
        }

        /* Loading å‘¼å¸ç¯åŠ¨ç”» */
        @keyframes pulse { 0% { opacity: 0.4; } 50% { opacity: 1; } 100% { opacity: 0.4; } }

        /* --- åˆ¶ä½œäººå‘˜ä¿¡æ¯ --- */
        #credits {
            position: absolute; 
            bottom: 20px; 
            right: 25px;
            text-align: right; 
            color: #a0a0a0; 
            font-size: 10px;
            line-height: 1.6; 
            opacity: 0; 
            transition: opacity 1.5s;
            pointer-events: none; 
            z-index: 50; 
            font-family: 'Noto Serif SC', serif;
            letter-spacing: 1px;
        }

        #video-feed { position: absolute; bottom: 10px; right: 10px; width: 100px; opacity: 0; transform: scaleX(-1); pointer-events: none; border: 1px solid #d4af37; transition: opacity 0.5s; }
        #loader { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); color: #d4af37; letter-spacing: 6px; font-size: 12px; font-weight: bold; z-index: 200; }

        /* --- ç§»åŠ¨ç«¯é€‚é… (Responsive Styles) --- */
        @media (max-width: 768px) {
            h1 { font-size: 42px; letter-spacing: 8px; }
            h2 { font-size: 10px; letter-spacing: 4px; }
            .options-grid { grid-template-columns: 1fr; gap: 30px; margin-bottom: 30px; }
            .choice-btn { padding: 10px 0; width: 200px; }
            #enter-btn { padding: 15px 60px; font-size: 14px; }
            #axis-markers::before { top: 15%; }
            #axis-markers::after { top: calc(15% + 35px); }
            .bottom-marker { bottom: 20%; }
            
            /* ç§»åŠ¨ç«¯å†å²è®°å½•ç½®é¡¶å±…ä¸­ */
            #history-container {
                top: 10px;
                right: 50%;
                transform: translateX(50%);
                height: 70px;
                gap: 10px;
            }
            .history-slot { width: 40px; height: 65px; }
            .history-name { font-size: 6px; }

            /* HUD è°ƒæ•´ */
            #hud-center { bottom: 15%; }
            #status-text { font-size: 10px; letter-spacing: 2px; }
            
            /* åˆ¶ä½œäººå‘˜ä¿¡æ¯ç¼©å° */
            #credits { text-align: center; right: 0; width: 100%; bottom: 10px; font-size: 8px; }
            
            /* æœ€ç»ˆç»“æœæ–‡å­—è°ƒæ•´ */
            #final-text-container { 
                top: 47%;           /* è°ƒæ•´å‚ç›´ä½ç½® */
                flex-direction: column; /* å¼ºåˆ¶å‚ç›´æ’åˆ—ï¼Œé˜²æ­¢æ–‡å­—æŒ¤å‹ */
                align-items: center;    /* å±…ä¸­å¯¹é½ */
                max-height: 40vh;       /* é™åˆ¶é«˜åº¦ï¼Œé˜²æ­¢é®æŒ¡åº•éƒ¨æŒ‰é’® */
                overflow-y: auto;       /* å¦‚æœæ–‡å­—å¤ªå¤šï¼Œå…è®¸æ»šåŠ¨ */
                gap: 10px; /* ç§»åŠ¨ç«¯é—´è·æ”¹å›å°å€¼ */
            }
            .final-card-label { width: 100%; max-width: 300px; }
            
            /* è§£è¯´æ–‡å­—åœ¨æ‰‹æœºä¸Šå°ä¸€ç‚¹ */
            #oracle-overlay { font-size: 14px; width: 90%; }
        }
    </style>
    
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>
    <div id="loader"></div>

    <div id="start-screen">
        <div class="title-group">
            <h1>ARCANUM</h1>
            <h2 id="subtitle">The Virtual Ritual</h2>
        </div>

        <div class="options-grid">
            <div class="option-group">
                <div class="option-label" id="lbl-language">Language / è¯­è¨€</div>
                <button class="choice-btn active" onclick="setLang('en')" id="btn-en">English</button>
                <button class="choice-btn" onclick="setLang('zh')" id="btn-zh">ä¸­æ–‡</button>
            </div>
            <div class="option-group">
                <div class="option-label" id="lbl-input">Input / æ“æ§</div>
                <button class="choice-btn active" onclick="setInput('hand')" id="btn-hand">Hand Gesture âœ‹</button>
                <button class="choice-btn" onclick="setInput('mouse')" id="btn-mouse">Mouse / Touch ğŸ–±ï¸</button>
            </div>
        </div>

        <button id="enter-btn" onclick="enterExperience()">ENTER</button>
    </div>

    <div id="ui-layer">
        <div id="axis-markers">
            <div class="bottom-marker"></div>
        </div>
        <div id="debug-axis-info" style=";
        ">
        </div>

        <div id="history-container"></div>
        <div id="final-text-container"></div>


        <div id="oracle-overlay"></div>

        <div id="end-ui">
            <button id="view-reading-btn" onclick="enterStarryVoid()">REVEAL DESTINY</button>
            <button id="restart-btn" onclick="location.reload()" style="display:none">RESTART RITUAL</button>
        </div>
        
        <div id="credits">
            By: Jerry Hu & Gemini<br>huqiuzhi10@gmail.com
        </div>

        <div id="hud-center">
            <span id="gesture-icon">âœ‹</span>
            <div id="status-text">Wave to Turn Â· Pinch to Select</div>
        </div>
    </div>

    <video id="video-feed" playsinline></video>
    <div id="canvas-container"></div>

<script>
// ================= API é…ç½®åŒºåŸŸ =================
// ğŸ”´ è¯·åœ¨è¿™é‡Œå¡«å…¥ä½ çš„ DeepSeek API Key (sk-xxxxxxxx)
const API_KEY = "sk-92c5cec08baf4941a5ab5a185cd9c22f"; 

// DeepSeek å®˜æ–¹æ¥å£åœ°å€
const API_ENDPOINT = "https://api.deepseek.com/chat/completions"; 

// DeepSeek æ¨¡å‹åç§°
const API_MODEL = "deepseek-chat"; 

// ğŸ”µ ä»£ç†å¼€å…³ï¼šåªåœ¨æœ€åè°ƒç”¨ API æ—¶ç”Ÿæ•ˆ
const USE_PROXY_FOR_API = true;

// ä»£ç†æœåŠ¡åœ°å€ (ä»…åœ¨ API è°ƒç”¨ç¬é—´ä½¿ç”¨)
const PROXY_BASE_URL = "https://corsproxy.io/?"; 

// è°ƒè¯•å¼€å…³
const DEBUG_MODE = true;
// ==============================================


// æ£€æµ‹æ˜¯å¦ç§»åŠ¨è®¾å¤‡
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

// 1. é—ªå…‰ç‰¹æ•ˆé€»è¾‘
function createSparkles() {
    const screen = document.getElementById('start-screen');
    if(screen.style.display === 'none') return; 

    const sparkle = document.createElement('div');
    sparkle.className = 'sparkle';
    
    // éšæœºä½ç½®
    const x = Math.random() * 100;
    const y = Math.random() * 100;
    sparkle.style.left = x + '%';
    sparkle.style.top = y + '%';
    
    // éšæœºå¤§å°å’ŒæŒç»­æ—¶é—´
    const size = Math.random() * 3 + 1; 
    sparkle.style.width = size + 'px';
    sparkle.style.height = size + 'px';
    sparkle.style.animationDuration = (Math.random() * 2 + 2) + 's'; 
    
    screen.appendChild(sparkle);

    // åŠ¨ç”»ç»“æŸåç§»é™¤
    setTimeout(() => { sparkle.remove(); }, 4000);
}
setInterval(createSparkles, 200);


/**
 * DATA & CONFIG
 */
const TEXTS = {
    en: {
        subtitle: "The Virtual Ritual",
        lblLang: "Language",
        lblInput: "Input Method",
        enter: "ENTER VOID",
        statusWave: "Wave to Turn Â· Pinch Center Card",
        statusMouse: "Move to Turn Â· Hold to Grab",
        statusTouch: "Tap left or right to Turn Â· Hold to Grab",
        statusFist: "FIST TO REVEAL",
        statusSpace: "SPACE / HOLD TO REVEAL",
        statusReveal: "OBSERVING FATE...",
        statusDone: "RITUAL COMPLETE",
        rev: "Reversed",
        restart: "RESTART RITUAL",
        btnHand: "Hand Gesture âœ‹", 
        btnMouse: isMobile ? "Touch Control ğŸ‘†" : "Mouse Control ğŸ–±ï¸"        
    },
    zh: {
        subtitle: "è™šæ‹Ÿå¡”ç½—ä»ªå¼",
        lblLang: "è¯­è¨€è®¾ç½®",
        lblInput: "æ“æ§æ–¹å¼",
        enter: "è¿›å…¥è™šç©º",
        statusWave: "æŒ¥æ‰‹è½¬åŠ¨ç‰Œé˜µ Â· æåˆæ‰‹æŒ‡é€‰ä¸­",
        statusMouse: "ç§»åŠ¨é¼ æ ‡è½¬åŠ¨ Â· æŒ‰ä½å·¦é”®æŠ“å–",
        statusTouch: "å·¦å³è½»ç‚¹è½¬åŠ¨ Â· é•¿æŒ‰æŠ“å–/æ­ç¤º",
        statusFist: "æ¡æ‹³æ­ç¤ºå‘½è¿",
        statusSpace: "æŒ‰ç©ºæ ¼ / é•¿æŒ‰æ­ç¤º",
        statusReveal: "æ­£åœ¨è§‚æµ‹å‘½è¿...",
        statusDone: "ä»ªå¼å®Œæˆ",
        rev: "é€†ä½",
        restart: "é‡æ–°å¼€å§‹ä»ªå¼",
        btnHand: "æ‰‹åŠ¿æ§åˆ¶ âœ‹", 
        btnMouse: isMobile ? "è§¦å±æ§åˆ¶ ğŸ‘†" : "é¼ æ ‡æ§åˆ¶ ğŸ–±ï¸"  
    }
};

// åŸºç¡€æ•°æ® (å®Œæ•´22å¼ )
const RWS_DATA = [
    { id: 0, en: { name: "The Fool", meaning: "New beginnings, innocence, spontaneity" }, zh: { name: "æ„šè€…", meaning: "æ–°çš„å¼€å§‹ï¼Œå¤©çœŸï¼Œè‡ªå‘æ€§ï¼Œå†’é™©" } },
    { id: 1, en: { name: "The Magician", meaning: "Manifestation, resourcefulness, power" }, zh: { name: "é­”æœ¯å¸ˆ", meaning: "æ˜¾åŒ–ï¼Œèµ„æºä¸°å¯Œï¼ŒåŠ›é‡ï¼Œåˆ›é€ åŠ›" } },
    { id: 2, en: { name: "High Priestess", meaning: "Intuition, sacred knowledge" }, zh: { name: "å¥³ç¥­å¸", meaning: "ç›´è§‰ï¼Œç¥åœ£çŸ¥è¯†ï¼Œæ½œæ„è¯†ï¼Œç¥ç§˜" } },
    { id: 3, en: { name: "The Empress", meaning: "Femininity, beauty, nature" }, zh: { name: "çš‡å", meaning: "å¥³æ€§åŠ›é‡ï¼Œç¾ä¸½ï¼Œè‡ªç„¶ï¼Œå­•è‚²" } },
    { id: 4, en: { name: "The Emperor", meaning: "Authority, establishment" }, zh: { name: "çš‡å¸", meaning: "æƒå¨ï¼Œä½“åˆ¶ï¼Œç»“æ„ï¼Œæ§åˆ¶" } },
    { id: 5, en: { name: "The Hierophant", meaning: "Spiritual wisdom, beliefs" }, zh: { name: "æ•™çš‡", meaning: "ç²¾ç¥æ™ºæ…§ï¼Œä¿¡ä»°ï¼Œä¼ ç»Ÿï¼Œæ•™å¯¼" } },
    { id: 6, en: { name: "The Lovers", meaning: "Love, harmony, choices" }, zh: { name: "æ‹äºº", meaning: "çˆ±ï¼Œå’Œè°ï¼Œå…³ç³»ï¼Œé€‰æ‹©" } },
    { id: 7, en: { name: "The Chariot", meaning: "Control, willpower, success" }, zh: { name: "æˆ˜è½¦", meaning: "æ§åˆ¶ï¼Œæ„å¿—åŠ›ï¼ŒæˆåŠŸï¼Œè¡ŒåŠ¨" } },
    { id: 8, en: { name: "Strength", meaning: "Strength, courage, persuasion" }, zh: { name: "åŠ›é‡", meaning: "åŠ›é‡ï¼Œå‹‡æ°”ï¼Œè¯´æœï¼Œå½±å“åŠ›" } },
    { id: 9, en: { name: "The Hermit", meaning: "Soul-searching, introspection" }, zh: { name: "éšå£«", meaning: "æ¢ç´¢å†…å¿ƒï¼Œå†…çœï¼Œç‹¬å¤„ï¼ŒæŒ‡å¼•" } },
    { id: 10, en: { name: "Wheel of Fortune", meaning: "Good luck, karma, destiny" }, zh: { name: "å‘½è¿ä¹‹è½®", meaning: "å¥½è¿ï¼Œä¸šåŠ›ï¼Œç”Ÿå‘½å‘¨æœŸï¼Œå‘½è¿" } },
    { id: 11, en: { name: "Justice", meaning: "Justice, fairness, truth" }, zh: { name: "æ­£ä¹‰", meaning: "æ­£ä¹‰ï¼Œå…¬å¹³ï¼ŒçœŸç†ï¼Œå› æœ" } },
    { id: 12, en: { name: "Hanged Man", meaning: "Pause, surrender, letting go" }, zh: { name: "å€’åŠäºº", meaning: "æš‚åœï¼Œè‡£æœï¼Œæ”¾æ‰‹ï¼Œæ–°è§†è§’" } },
    { id: 13, en: { name: "Death", meaning: "Endings, change, transformation" }, zh: { name: "æ­»ç¥", meaning: "ç»“æŸï¼Œæ”¹å˜ï¼Œè½¬åŒ–ï¼Œè¿‡æ¸¡" } },
    { id: 14, en: { name: "Temperance", meaning: "Balance, moderation, patience" }, zh: { name: "èŠ‚åˆ¶", meaning: "å¹³è¡¡ï¼Œé€‚åº¦ï¼Œè€å¿ƒï¼Œç›®æ ‡" } },
    { id: 15, en: { name: "The Devil", meaning: "Shadow self, addiction" }, zh: { name: "æ¶é­”", meaning: "é˜´æš—é¢ï¼Œæ‰§ç€ï¼Œæˆç˜¾ï¼ŒæŸç¼š" } },
    { id: 16, en: { name: "The Tower", meaning: "Sudden change, upheaval" }, zh: { name: "é«˜å¡”", meaning: "çªå˜ï¼Œå‰§å˜ï¼Œæ··ä¹±ï¼Œå¯ç¤º" } },
    { id: 17, en: { name: "The Star", meaning: "Hope, faith, renewal" }, zh: { name: "æ˜Ÿæ˜Ÿ", meaning: "å¸Œæœ›ï¼Œä¿¡å¿µï¼Œç›®æ ‡ï¼Œæ–°ç”Ÿ" } },
    { id: 18, en: { name: "The Moon", meaning: "Illusion, fear, anxiety" }, zh: { name: "æœˆäº®", meaning: "å¹»è§‰ï¼Œææƒ§ï¼Œç„¦è™‘ï¼Œæ½œæ„è¯†" } },
    { id: 19, en: { name: "The Sun", meaning: "Positivity, fun, warmth" }, zh: { name: "å¤ªé˜³", meaning: "ç§¯æï¼Œå¿«ä¹ï¼Œæ¸©æš–ï¼ŒæˆåŠŸ" } },
    { id: 20, en: { name: "Judgement", meaning: "Judgement, rebirth, calling" }, zh: { name: "å®¡åˆ¤", meaning: "å®¡åˆ¤ï¼Œé‡ç”Ÿï¼Œå†…å¿ƒå¬å”¤ï¼Œèµ¦å…" } },
    { id: 21, en: { name: "The World", meaning: "Completion, integration" }, zh: { name: "ä¸–ç•Œ", meaning: "å®Œæˆï¼Œæ•´åˆï¼Œæˆå°±ï¼Œåœ†æ»¡" } }
];

let currentLang = 'en';
// å¦‚æœæ˜¯æ‰‹æœºï¼Œé»˜è®¤ä½¿ç”¨ Mouse/Touch æ¨¡å¼
let controlMode = isMobile ? 'mouse' : 'hand'; 
let isStarted = false;
let deckList = [];

// --- æ–°å¢ï¼šç‰©ç†å¼•æ“å˜é‡ ---
let touchStartX = 0;      // è§¦æ‘¸èµ·å§‹ä½ç½®
let lastTouchX = 0;       // ä¸Šä¸€å¸§çš„ä½ç½®
let touchVelocity = 0;    // å½“å‰æ»‘åŠ¨é€Ÿåº¦
let isDragging = false;   // æ˜¯å¦æ‰‹æŒ‡æŒ‰åœ¨å±å¹•ä¸Š
let isInertia = false;    // æ˜¯å¦å¤„äºæƒ¯æ€§æ»‘è¡ŒçŠ¶æ€
const FRICTION = 0.95;    // æ‘©æ“¦åŠ› (0.9-0.99ï¼Œè¶Šå¤§æ»‘å¾—è¶Šè¿œ)
const GRAB_THRESHOLD = 0.005; // æŠ“å–é€Ÿåº¦é˜ˆå€¼ (è¶Šå°è¶Šä¸¥æ ¼ï¼Œå¿…é¡»åœå¾—æ›´ç¨³æ‰èƒ½æŠ“)
let interactionLock = false; // äº¤äº’é”ï¼šé˜²æ­¢é•¿æŒ‰è¿å‘
let holdTimer = null;    // å­˜é•¿æŒ‰çš„é—¹é’ŸID
let hasRevealed = false; // æ ‡è®°ï¼šè¿™æ¬¡é•¿æŒ‰æ˜¯å¦å·²ç»æˆåŠŸæ­ç¤ºäº†
// --- æ–°å¢ï¼šäº¤äº’çŠ¶æ€å˜é‡ ---
let dragDirection = null; // 'X' (æ—‹è½¬) æˆ– 'Y' (ä¸‹æ‹‰)
let pullProgress = 0;     // ä¸‹æ‹‰è¿›åº¦ (0.0 ~ 1.0)
const PULL_THRESHOLD = 150; // ä¸‹æ‹‰å¤šå°‘åƒç´ ç®—ç¡®è®¤ç¿»ç‰Œ
let isCoolingDown = false; // å…¨å±€å†·å´é”
const COOLDOWN_TIME = 300; // å†·å´æ—¶é—´ (æ¯«ç§’)ï¼Œ0.3ç§’æ¯”è¾ƒåˆé€‚


// Game Logic Params
const MAX_SELECTION = 3; 
let selectionCount = 0;
let isRitualComplete = false;
let chosen3DMeshes = [];


const RADIUS = 10;
const CARD_W = 1.5;
const CARD_H = 2.58;
const CORNER_R = 0.08;
const GOLD_COLOR = 0xd4af37;
const BG_COLOR = 0x000000;

// åˆå§‹åŒ–æŒ‰é’®çŠ¶æ€
window.onload = function() {
    setInput(controlMode);
    updateStartScreenText();
};

function setLang(lang) {
    currentLang = lang;
    document.querySelectorAll('[onclick^="setLang"]').forEach(b => b.classList.remove('active'));
    document.getElementById(`btn-${lang}`).classList.add('active');
    updateStartScreenText();
}

function setInput(mode) {
    controlMode = mode;
    document.querySelectorAll('[onclick^="setInput"]').forEach(b => b.classList.remove('active'));
    document.getElementById(`btn-${mode}`).classList.add('active');
}

function updateStartScreenText() {
    const t = TEXTS[currentLang];
    document.getElementById('subtitle').innerText = t.subtitle;
    document.getElementById('lbl-language').innerText = t.lblLang;
    document.getElementById('lbl-input').innerText = t.lblInput;
    document.getElementById('enter-btn').innerText = t.enter;
    document.getElementById('restart-btn').innerText = t.restart;
    // æ›´æ–°æŒ‰é’®æ–‡å­—
    document.getElementById('btn-hand').innerText = t.btnHand;
    document.getElementById('btn-mouse').innerText = t.btnMouse;
}

function enterExperience() {
    isStarted = true;
    const screen = document.getElementById('start-screen');
    screen.style.opacity = 0;
    screen.style.pointerEvents = 'none'; 
    setTimeout(() => { screen.style.display = 'none'; }, 1500);
    const ui = document.getElementById('ui-layer');
    ui.style.opacity = 1;
    
    // åˆå§‹åŒ–è¾“å…¥ç›‘å¬
    if (controlMode === 'hand') {
        document.getElementById('video-feed').style.opacity = 0.3;
        initCamera();
    } else {
        initMouseListeners();
        initTouchListeners(); // å¢åŠ è§¦æ‘¸ç›‘å¬
    }
    
    updateCameraPos(); // ç¡®ä¿ç›¸æœºä½ç½®æ­£ç¡®
    updateStatusText();
    spawnDeck();
}

/**
 * THREE.JS SCENE SETUP
 */
const scene = new THREE.Scene();
scene.background = new THREE.Color(BG_COLOR);
scene.fog = new THREE.FogExp2(BG_COLOR, 0.012);
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
// åˆå§‹ä½ç½®ç”± updateCameraPos å†³å®š

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
document.getElementById('canvas-container').appendChild(renderer.domElement);

const texLoader = new THREE.TextureLoader();
// âš ï¸ é™æ€èµ„æºåŠ è½½ï¼šç›´æ¥åŠ è½½æœ¬åœ°å›¾ç‰‡ï¼Œä¸èµ°ä»£ç†
const texBackGlobal = texLoader.load('./cards/back.png'); 
texBackGlobal.anisotropy = renderer.capabilities.getMaxAnisotropy();
texBackGlobal.center.set(0.5, 0.5);

const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
scene.add(ambientLight);
const frontLight = new THREE.DirectionalLight(0xffeaac, 0.6);
frontLight.position.set(0, 2, 5);
scene.add(frontLight);

// Stars
const starGeo = new THREE.BufferGeometry();
const starPos = new Float32Array(2500*3);
for(let i=0;i<2500;i++) {
    const r = 20 + Math.random()*40;
    const theta = Math.random()*Math.PI*2;
    const phi = Math.acos(Math.random()*2-1);
    starPos[i*3] = r*Math.sin(phi)*Math.cos(theta);
    starPos[i*3+1] = r*Math.sin(phi)*Math.sin(theta);
    starPos[i*3+2] = r*Math.cos(phi);
}
starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
const starMat = new THREE.PointsMaterial({color: 0xcccccc, size: 0.06});
const starSystem = new THREE.Points(starGeo, starMat);
scene.add(starSystem);

/**
 * DECK CONSTRUCTION
 */
const deckGroup = new THREE.Group();
scene.add(deckGroup);
let cardObjects = [];

const shape = new THREE.Shape();
const w = CARD_W/2, h = CARD_H/2, r = CORNER_R;
shape.moveTo(-w+r, -h); shape.lineTo(w-r, -h); shape.quadraticCurveTo(w, -h, w, -h+r);
shape.lineTo(w, h-r); shape.quadraticCurveTo(w, h, w-r, h);
shape.lineTo(-w+r, h); shape.quadraticCurveTo(-w, h, -w, h-r);
shape.lineTo(-w, -h+r); shape.quadraticCurveTo(-w, -h, -w+r, -h);
const faceGeo = new THREE.ShapeGeometry(shape);

function fixUVs(geometry) {
    const posAttribute = geometry.attributes.position;
    const uvAttribute = geometry.attributes.uv;
    for (let i = 0; i < posAttribute.count; i++) {
        const x = posAttribute.getX(i);
        const y = posAttribute.getY(i);
        uvAttribute.setXY(i, (x / CARD_W) + 0.5, (y / CARD_H) + 0.5);
    }
    uvAttribute.needsUpdate = true;
}
fixUVs(faceGeo);

const matBase = { roughness: 0.6, metalness: 0.1 };
const edgeMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, ...matBase });
const outlineGeo = new THREE.EdgesGeometry(faceGeo);
const outlineMat = new THREE.LineBasicMaterial({ color: GOLD_COLOR, linewidth: 2 });

function createCardMesh(data, index, total) {
    const group = new THREE.Group();
    // âš ï¸ è¿™é‡ŒåŠ è½½å¡ç‰Œçº¹ç†ï¼šä½¿ç”¨æœ¬åœ°ç›¸å¯¹è·¯å¾„ï¼Œä¸èµ°ä»£ç†
    const texFront = texLoader.load(data.url);
    texFront.anisotropy = renderer.capabilities.getMaxAnisotropy();
    texFront.center.set(0.5, 0.5);
    
    const matBack = new THREE.MeshStandardMaterial({ map: texBackGlobal, ...matBase });
    const matFront = new THREE.MeshStandardMaterial({ map: texFront, ...matBase });

    const meshBack = new THREE.Mesh(faceGeo, matBack);
    meshBack.position.z = 0.005; 
    const meshFront = new THREE.Mesh(faceGeo, matFront);
    meshFront.rotation.y = Math.PI;
    meshFront.position.z = -0.005;
    const meshFiller = new THREE.Mesh(faceGeo, edgeMat);
    meshFiller.scale.set(0.995, 0.995, 1);
    
    // æ¢å¤é«˜å…‰çº¿æ¡† (Outline)ï¼Œç”¨äºæ ‡è®°â€œä¸­è½´å¡â€
    //const outlineMesh = new THREE.LineSegments(outlineGeo, outlineMat);
    //outlineMesh.position.z = 0.006; 
    //outlineMesh.visible = false; // é»˜è®¤éšè—
    //group.userData.outline = outlineMesh; // å­˜å…¥ userData æ–¹ä¾¿åç»­è°ƒç”¨

    group.add(meshBack, meshFront, meshFiller);
    
    const step = (Math.PI * 2) / total;
    const theta = index * step;
    group.position.x = RADIUS * Math.sin(theta);
    group.position.z = -RADIUS * Math.cos(theta);
    group.lookAt(0, 0, 0);

    group.userData = { id: data.id, rawData: data, state: 'IDLE', theta: theta, isChosen: false };
    return group;
}

function spawnDeck() {
    if(!isStarted) return;
   // åˆ¤æ–­æ˜¯å¦æ˜¯ç«–å±ï¼ˆæ‰‹æœºï¼‰
    const isPortrait = window.innerHeight > window.innerWidth;
    
    // è®¾ç½®é«˜åº¦
    deckGroup.position.y = isPortrait ? 2.0 : 0; 
    
    deckGroup.clear(); cardObjects = [];
    
    // âš ï¸ ç”Ÿæˆæœ¬åœ°è·¯å¾„æ•°æ®
    deckList = RWS_DATA.map(d => ({
        ...d,
        url: `./cards/${d.id}.png` // ç›¸å¯¹è·¯å¾„ï¼Œæµè§ˆå™¨ç›´æ¥åŠ è½½
    }));

    deckList.sort(() => Math.random() - 0.5);
    
    deckList.forEach((item, i) => {
        const card = createCardMesh(item, i, deckList.length);
        deckGroup.add(card);
        cardObjects.push(card);
    });
    document.getElementById('loader').style.display = 'none';
}

/**
 * INTERACTION LOGIC
 */
let handState = 'OPEN';
let handX = 0;
let ringRotation = 0;
let activeCard = null;
let centerCard = null;

// --- ä¿®æ”¹åï¼šå¸¦é€Ÿåº¦é™åˆ¶çš„é¼ æ ‡ç›‘å¬ ---
function initMouseListeners() {
    window.addEventListener('mousemove', (e) => {
        handX = (e.clientX / window.innerWidth) * 2 - 1;
    });

    window.addEventListener('mousedown', (e) => {
        if(e.button !== 0) return;

        // åŸºç¡€ä½ç½®æ£€æŸ¥
        const isHoveringCenter = Math.abs(handX) < 0.2; 
        
        // ğŸ›‘ æ ¸å¿ƒä¿®æ”¹ï¼šé€Ÿåº¦æ£€æµ‹
        // å¦‚æœæ­£åœ¨æƒ¯æ€§æ»‘è¡Œï¼Œä¸”é€Ÿåº¦å¤ªå¿« -> ç¦æ­¢ç‚¹å‡»
        const isTooFast = isInertia && Math.abs(touchVelocity) > GRAB_THRESHOLD;

        if (isHoveringCenter && !isTooFast) {
            // åªæœ‰è¿™é‡Œæ‰å…è®¸åˆ¹è½¦
            if (isInertia) {
                isInertia = false;
                touchVelocity = 0;
                snapToGrid();
            }
            handState = 'PINCH'; 
        } 
        updateCursorIcon();
    });

    window.addEventListener('mouseup', () => {
        handState = 'OPEN'; 
        updateCursorIcon();
    });

    // é”®ç›˜é€»è¾‘ä¿æŒä¸å˜
    window.addEventListener('keydown', (e) => {
        if(e.code === 'Space') handState = 'FIST'; 
        updateCursorIcon();
    });
    window.addEventListener('keyup', (e) => {
        if(e.code === 'Space' && handState === 'FIST') handState = 'PINCH'; 
        else if (e.code === 'Space') handState = 'OPEN';
        updateCursorIcon();
    });
}

// --- ä¿®æ”¹åï¼šæ‰‹åŠ¿åˆ†æµé€»è¾‘ (æ¨ªæ»‘æ—‹è½¬ / ä¸‹æ‹‰æŠ½å¡) ---
function initTouchListeners() {
    const container = document.getElementById('canvas-container');
    
    // 1. è§¦æ‘¸å¼€å§‹
    container.addEventListener('touchstart', (e) => {
        const touch = e.touches[0];
        
        // é‡ç½®ç‰©ç†çŠ¶æ€
        isDragging = true;
        isInertia = false; 
        touchVelocity = 0; 
        
        // è®°å½•èµ·å§‹ç‚¹
        touchStartX = touch.clientX;
        lastTouchX = touch.clientX;
        
        // è®°å½• Y è½´ (ç”¨äºä¸‹æ‹‰)
        touchStartY = touch.clientY;
        
        // é‡ç½®æ–¹å‘é”
        dragDirection = null; 
        pullProgress = 0;

        // å¦‚æœè¿™æ—¶å€™å·²ç»æœ‰é€‰ä¸­çš„å¡ï¼ˆä½†è¿˜æ²¡ç¿»å¼€ï¼‰ï¼Œå…è®¸ç”¨æˆ·å†æ¬¡æ‹–åŠ¨å®ƒ
        // æˆ–è€…å¦‚æœæ²¡é€‰å¡ï¼Œå‡†å¤‡æŠŠä¸­è½´å¡å¸è¿‡æ¥
    }, { passive: false });

    // 2. è§¦æ‘¸ç§»åŠ¨
    container.addEventListener('touchmove', (e) => {
        e.preventDefault(); 
        if (!isDragging) return;

        const touch = e.touches[0];
        const dx = touch.clientX - touchStartX; // Xè½´æ€»ä½ç§»
        const dy = touch.clientY - touchStartY; // Yè½´æ€»ä½ç§» (å‘ä¸‹ä¸ºæ­£)
        
        // --- A. è¿˜æ²¡å†³å®šæ–¹å‘æ—¶ï¼Œè¿›è¡Œåˆ¤æ–­ ---
        if (!dragDirection) {
            // è®¾ç½®ä¸€ä¸ªæ­»åŒº (10px)ï¼Œé˜²æŠ–åŠ¨
            if (Math.abs(dx) > 10 || Math.abs(dy) > 10) {
                // å¦‚æœæ¨ªå‘ç§»åŠ¨æ›´å¤š -> æ—‹è½¬æ¨¡å¼
                if (Math.abs(dx) > Math.abs(dy)) {
                    dragDirection = 'X';
                } 
                // å¦‚æœçºµå‘ç§»åŠ¨æ›´å¤šï¼Œä¸”æ˜¯å‘ä¸‹æ»‘ -> æŠ½å¡æ¨¡å¼
                // åªæœ‰åœ¨ä¸­è½´æœ‰å¡ï¼Œä¸”æ²¡é€‰æ»¡3å¼ æ—¶æ‰å…è®¸
                else if (dy > 0 && centerCard && selectionCount < MAX_SELECTION) {
                    dragDirection = 'Y';
                    
                    // ğŸ”’ æ—¢ç„¶å†³å®šä¸‹æ‹‰ï¼Œç«‹åˆ»å¼ºåˆ¶åˆ¹è½¦ã€å½’ä½ã€é€‰ä¸­
                    isInertia = false;
                    touchVelocity = 0;
                    snapToGrid(); 
                    
                    // æŠŠä¸­è½´å¡æ ‡è®°ä¸º Activeï¼Œå‡†å¤‡è·Ÿç€æ‰‹æŒ‡åŠ¨
                    if (!activeCard) {
                        selectCard(centerCard);
                    }
                }
            }
        }

        // --- B. æ‰§è¡Œé€»è¾‘ ---
        
        if (dragDirection === 'X') {
            // === æ—‹è½¬é€»è¾‘ ===
            const currentX = touch.clientX;
            const deltaX = currentX - lastTouchX;
            lastTouchX = currentX;
            
            touchVelocity = deltaX * 0.005; 
            ringRotation += touchVelocity * 3.0;
            deckGroup.rotation.y = ringRotation;
        } 
        else if (dragDirection === 'Y') {
            // === ä¸‹æ‹‰é€»è¾‘ ===
            // è®¡ç®—ä¸‹æ‹‰è¿›åº¦ï¼šæŠŠåƒç´ æ˜ å°„åˆ° 0~1
            // æ¯”å¦‚æ‹‰åŠ¨ 150px å°±ç®—æ»¡
            let progress = dy / PULL_THRESHOLD;
            
            // é™åˆ¶èŒƒå›´ 0 ~ 1.2 (å…è®¸ç¨å¾®æ‹‰è¿‡å¤´ä¸€ç‚¹ç‚¹ï¼Œæœ‰å¼¹æ€§)
            progress = Math.min(Math.max(progress, 0), 1.2);
            pullProgress = progress;
            
            // è§†è§‰åé¦ˆï¼šæ‰‹åŠ¨æ›´æ–° activeCard ä½ç½®ï¼Œè®©å®ƒè·Ÿæ‰‹
            if (activeCard) {
                updatePullingVisuals(activeCard, progress);
            }
        }
        
    }, { passive: false });

    // 3. è§¦æ‘¸ç»“æŸ
    container.addEventListener('touchend', (e) => {
        isDragging = false;
        
        if (dragDirection === 'X') {
            // æ—‹è½¬ç»“æŸ -> æƒ¯æ€§
            if (Math.abs(touchVelocity) > 0.002) {
                isInertia = true;
            } else {
                snapToGrid(); 
            }
        } 
        else if (dragDirection === 'Y') {
            // ä¸‹æ‹‰ç»“æŸ -> åˆ¤å®šç»“æœ
            if (pullProgress > 0.8) {
                // æ‹‰å¾—å¤Ÿé•¿ -> ç¡®è®¤ç¿»è½¬
                if (activeCard) revealCard(activeCard);
            } else {
                // æ‹‰å¾—å¤ªçŸ­ (è½»ç‚¹ä¹Ÿç®—å¤ªçŸ­) -> å¼¹å›
                if (activeCard) returnCard(activeCard);
            }
            
            // é‡ç½®è¿›åº¦
            pullProgress = 0;
        }
        
        dragDirection = null;
    });
}

// --- è¾…åŠ©ï¼šä¸‹æ‹‰æ—¶çš„è§†è§‰è®¡ç®— ---
function updatePullingVisuals(card, progress) {
    // ç›®æ ‡ä½ç½®è®¡ç®—ï¼š
    // Zè½´ï¼šä»åŸä½ (-RADIUS) æ‹‰è¿‘åˆ°çœ¼å‰ (-2.2)
    // Yè½´ï¼šéšç€ä¸‹æ‹‰ï¼Œç¨å¾®å¾€ä¸‹æ²‰ä¸€ç‚¹ç‚¹ï¼Œç¬¦åˆç‰©ç†ç›´è§‰
    
    // 0% çš„ä½ç½® (åœ¨ä¸­è½´ä¸Š)
    const startZ = -RADIUS; 
    const startY = 0;
    
    // 100% çš„ä½ç½® (çœ¼å‰ç¡®è®¤ä½)
    const endZ = isMobile ? -3.5 : -2.2;
    const endY = -1.5; // æ‹‰åˆ°å±å¹•ä¸‹æ–¹ä¸€ç‚¹
    
    // æ’å€¼è®¡ç®—
    const currentZ = THREE.MathUtils.lerp(startZ, endZ, progress);
    const currentY = THREE.MathUtils.lerp(startY, endY, progress * 0.5); // Yè½´åŠ¨å°‘ä¸€ç‚¹
    
    // æ—‹è½¬ï¼šä¸‹æ‹‰è¿‡ç¨‹ä¸­ï¼Œå¡ç‰‡å¯ä»¥ç¨å¾®ç¿˜èµ·ä¸€ç‚¹ (Xè½´æ—‹è½¬)
    const targetRotX = progress * 0.5; // å¾®å¾®æŠ¬å¤´
    
    card.position.set(0, currentY, currentZ);
    card.rotation.x = targetRotX;
    
    // æ­¤æ—¶æˆ‘ä»¬è¦æš‚æ—¶æ¥ç®¡ rotationï¼Œé˜²æ­¢ handleInput é‡Œçš„ lerp æ‰“æ¶
    card.userData.isManualDragging = true;
}


// --- ä¿®æ”¹åï¼šå›å½’æœ¬è´¨çš„æŒ‰é’®ç›‘å¬ ---
function initHUDListeners() {
    const hud = document.getElementById('hud-center');
    
    // æŒ‰ä¸‹ = å‘Šè¯‰ç³»ç»Ÿâ€œæˆ‘ç°åœ¨æ˜¯æåˆçŠ¶æ€â€
    const onPress = (e) => {
        if (!isMobile) return; 
        e.preventDefault(); 
        e.stopPropagation();

        // 1. é€Ÿåº¦æ£€æŸ¥ï¼šå¤ªå¿«äº†ä¸è®¸æŒ‰
        if (isInertia && Math.abs(touchVelocity) > GRAB_THRESHOLD) return;
        
        // 2. æ•°é‡æ£€æŸ¥ï¼šé€‰å¤Ÿäº†ä¸è®¸æŒ‰
        if (selectionCount >= MAX_SELECTION) return;

        // 3. åŠ¨ä½œï¼šå¼ºåˆ¶åœè½¦ï¼ŒçŠ¶æ€è®¾ä¸º PINCH
        isInertia = false;
        touchVelocity = 0;
        isDragging = false;
        snapToGrid(); 
        
        handState = 'PINCH'; // <--- å…³é”®ï¼šåªæ”¹å˜çŠ¶æ€ï¼Œå‰©ä¸‹çš„äº¤ç»™ä¸»å¾ªç¯
        updateCursorIcon();
    };

    // æ¾å¼€ = å‘Šè¯‰ç³»ç»Ÿâ€œæˆ‘ç°åœ¨æ¾æ‰‹äº†â€
    const onRelease = (e) => {
        if (!isMobile) return;
        e.preventDefault();

        handState = 'OPEN'; // <--- å…³é”®ï¼šçŠ¶æ€å¤ä½
        updateCursorIcon();

        // è§£å¼€è¿å‘é”ï¼Œå‡†å¤‡ä¸‹ä¸€æ¬¡æ“ä½œ
        interactionLock = false; 
    };

    hud.addEventListener('touchstart', onPress, {passive:false});
    hud.addEventListener('touchend', onRelease, {passive:false});
    hud.addEventListener('touchcancel', onRelease, {passive:false});
}


function updateCursorIcon() {
    const icon = handState==='FIST'?'âœŠ':(handState==='PINCH'?'ğŸ¤': (isMobile ? 'ğŸ‘†' : 'ğŸ–±ï¸'));
    document.getElementById('gesture-icon').innerText = icon;
}

function updateStatusText() {
    const t = TEXTS[currentLang];
    const el = document.getElementById('status-text');
    if (isRitualComplete) {
        el.innerText = t.statusDone;
        return;
    }
    if (activeCard && activeCard.userData.state === 'SELECTED') {
        el.innerText = controlMode === 'hand' ? t.statusFist : t.statusSpace;
    } else if (activeCard && activeCard.userData.state === 'REVEALING') {
        el.innerText = t.statusReveal;
    } else {
        if (controlMode === 'hand') el.innerText = t.statusWave;
        else el.innerText = isMobile ? t.statusTouch : t.statusMouse; // åŒºåˆ†è§¦æ‘¸å’Œé¼ æ ‡æç¤º
    }
}

// --- å®šä¹‰ï¼šæ ¸å¿ƒä¸­è½´è®¡ç®—é€»è¾‘ ---
// --- ä¿®æ”¹åï¼šå¸¦å†»ç»“é€»è¾‘çš„ä¸­è½´åˆ¤å®š ---
function getAxisCard() {
    // ğŸ›‘ å†»ç»“é€»è¾‘ (Step 8.1)
    // å¦‚æœå½“å‰æœ‰â€œä¸»è§’å¡â€ (é€‰ä¸­ã€ä¸‹æ‹‰ä¸­ã€æˆ–æ­£åœ¨å½’ä½)
    // ç›´æ¥é”å®šå®ƒä¸ºä¸­è½´å¡ï¼Œä¸å†è®¡ç®—è·ç¦»
    // è¿™æ ·å³ä½¿å¡ç‰‡è¢«æ‹‰åˆ°å±å¹•è¾¹ç¼˜ï¼Œç³»ç»Ÿä¾ç„¶è®¤ä¸ºå®ƒæ˜¯â€œä¸­å¿ƒâ€
    if (activeCard) {
        // ç¡®ä¿å®ƒä¸é«˜äº®è½®å»“ï¼ˆæˆ‘ä»¬ç”¨å…‰å½±æè´¨æ¥åšé«˜äº®ï¼Œä¸ç”¨ LineSegmentsï¼‰
        if (activeCard.userData.outline) activeCard.userData.outline.visible = false;
        return activeCard;
    }

    // --- ä»¥ä¸‹æ˜¯å¸¸è§„é€»è¾‘ (åªæœ‰æ²¡é€‰ä¸­å¡æ—¶æ‰è¿è¡Œ) ---
    
    let closestCard = null;
    let minAbsX = Infinity; 

    cardObjects.forEach(card => {
        // æ’é™¤å·²é€‰ä¸­çš„ï¼ˆè™½ç„¶ä¸Šé¢å·²ç»æ‹¦æˆªäº† activeCardï¼Œä½†ä¸ºäº†é˜²æ­¢é£èµ°çš„å¡å¹²æ‰°ï¼Œä¿ç•™æ­¤åˆ¤æ–­ï¼‰
        if (card.userData.isChosen) return;

        // è·å–ä¸–ç•Œåæ ‡ X
        const worldPos = new THREE.Vector3();
        card.getWorldPosition(worldPos);

        // åªçœ‹ç›¸æœºå‰æ–¹çš„å¡
        if (worldPos.z < 0) { 
            const absX = Math.abs(worldPos.x);
            if (absX < minAbsX) {
                minAbsX = absX;
                closestCard = card;
            }
        }
        
        // ç¡®ä¿å¹³æ—¶æ²¡æœ‰ outline
        if (card.userData.outline) card.userData.outline.visible = false;
    });

    return closestCard;
}

let isHandRotating = false; // æ–°å¢æ ‡è®°

function handleInput() {
    if (!isStarted) return;
    if (isRitualComplete) {
        animateFinalFormation();
        return;
    }
    // ğŸ›‘ æ–°å¢ï¼šå†·å´æœŸé”æ­»
    // å¦‚æœå¤„äºå†·å´æœŸï¼Œä»€ä¹ˆéƒ½ä¸è®¸åŠ¨ï¼Œä¿æŒä¸Šä¸€å¸§çš„ç”»é¢
    if (isCoolingDown) return;


    // ==========================================
    // 1. ç‰©ç†å¼•æ“ (æ²¡æŠ“ç‰Œæ—¶è¿è¡Œ)
    // ==========================================
    if (!activeCard) {
        if (isInertia) {
            ringRotation += touchVelocity * 15;
            touchVelocity *= FRICTION;
            if (Math.abs(touchVelocity) < 0.0005) {
                isInertia = false;
                touchVelocity = 0;
                snapToGrid();
            }
        }
        // PC å…¼å®¹
        if (!isDragging && !isInertia && handState === 'OPEN') {
             const deadZone = 0.15;
             const speed = isMobile ? 0.015 : 0.02;
             if (Math.abs(handX) > deadZone) {
                  ringRotation += (handX - Math.sign(handX)*deadZone) * speed;
                  isHandRotating = true;
             } else if (isHandRotating) {
                  snapToGrid();
                  isHandRotating = false;
             }
        }
        // åº”ç”¨æ—‹è½¬
        if (isDragging && dragDirection === 'X') {
            deckGroup.rotation.y = ringRotation;
        } else {
            deckGroup.rotation.y = THREE.MathUtils.lerp(deckGroup.rotation.y, ringRotation, 0.1);
        }
    }

    // ==========================================
    // 2. ä¸­è½´è®¡ç®—
    // ==========================================
    const newAxisCard = getAxisCard();
    centerCard = newAxisCard; 
    
    // PC é¼ æ ‡æ ·å¼
    if (!isMobile && !isDragging) {
        if (Math.abs(handX) < 0.2 && centerCard && !isInertia) document.body.classList.add('can-grab');
        else document.body.classList.remove('can-grab');
    }
    
    // PC é¼ æ ‡ç‚¹å‡»æŠ“å–ä¿ç•™
    if (!isMobile && handState === 'PINCH' && centerCard && !activeCard && !isDragging && !isInertia) {
        selectCard(centerCard);
    }

    // ==========================================
    // 3. é€‰ä¸­åçš„åŠ¨ç”» (åŒºåˆ† è‡ªåŠ¨åŠ¨ç”» vs æ‰‹åŠ¨ä¸‹æ‹‰)
    // ==========================================
    
    if (activeCard) {
        // ğŸš¨ æ ¸å¿ƒä¿®æ”¹ï¼šå¦‚æœæ˜¯ä¸‹æ‹‰æ¨¡å¼ï¼ŒHandleInput ä¸å¹²æ¶‰ä½ç½®
        if (dragDirection === 'Y') {
            // ä½ç½®ç”± touchmove é‡Œçš„ updatePullingVisuals æ§åˆ¶
            // è¿™é‡Œæˆ‘ä»¬åªéœ€è¦ç»´æŠ¤ä¸€ä¸‹çŠ¶æ€ï¼Œæ¯”å¦‚è®© outline æ¶ˆå¤±
            if (activeCard.userData.outline) activeCard.userData.outline.visible = false;
        } 
        else {
            // ğŸš¨ å¦åˆ™ (æ¯”å¦‚é¼ æ ‡ç‚¹å‡»ï¼Œæˆ–è€…æ¾æ‰‹åçš„è‡ªåŠ¨å›å¼¹)ï¼Œä½¿ç”¨è‡ªåŠ¨åŠ¨ç”»
            
            // é£åˆ°çœ¼å‰
            const targetZ = isMobile ? -3.5 : -2.2;
            activeCard.position.lerp(new THREE.Vector3(0, 0, targetZ), 0.1);
            // Yè½´å½’é›¶
            activeCard.position.y = THREE.MathUtils.lerp(activeCard.position.y, 0, 0.1);
            
            // è§’åº¦æ‰¶æ­£
            if (activeCard.userData.state === 'SELECTED') {
                const idleQ = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, 0, 0));
                activeCard.quaternion.slerp(idleQ, 0.1);
                
                // PC ç«¯é•¿æŒ‰é€»è¾‘ (Touchç«¯å·²ç»ç§»é™¤äº†è¿™é‡Œ)
                if (!isMobile) {
                    if (handState === 'PINCH') {
                        if(!activeCard.userData.revealTimer) activeCard.userData.revealTimer = Date.now();
                        if(Date.now() - activeCard.userData.revealTimer > 500) revealCard(activeCard);
                    } else if (handState === 'OPEN') {
                        activeCard.userData.revealTimer = null;
                        returnCard(activeCard);
                    }
                }
            }
        }
    } else {
        updateStatusText();
    }
}

// --- æ–°å¢ï¼šå¼ºåˆ¶å½’ä½é€»è¾‘ ---
function snapToGrid() {
    // 1. ç®—å‡ºæ¯å¼ ç‰Œçš„é—´éš”è§’åº¦ (å¼§åº¦)
    // 22å¼ ç‰Œï¼Œä¸€åœˆæ˜¯ 2PI
    const step = (Math.PI * 2) / deckList.length;

    // 2. ç®—å‡ºå½“å‰æ—‹è½¬è§’åº¦å¯¹åº”çš„æ˜¯â€œç¬¬å‡ ä¸ªå¡ä½â€
    // ä½¿ç”¨ Math.round è¿›è¡Œå››èˆäº”å…¥ï¼Œè¿™å°±æ˜¯â€œæ‰¾æœ€è¿‘â€çš„æ ¸å¿ƒ
    const closestIndex = Math.round(ringRotation / step);

    // 3. ç®—å‡ºé‚£ä¸ªå¡ä½çš„æ ‡å‡†è§’åº¦
    const targetRotation = closestIndex * step;

    // 4.ç³»ç»Ÿä¼šè®¤ä¸ºâ€œåŸæœ¬å°±åº”è¯¥è½¬åˆ°è¿™é‡Œâ€ï¼Œç„¶åé€šè¿‡ lerp æ…¢æ…¢æ»‘è¿‡å»
    ringRotation = targetRotation;
    
    // 5. å†æ¬¡å¼ºåˆ¶æ›´æ–°ä¸€ä¸‹ä¸­è½´å¡ï¼Œç¡®ä¿æ•°æ®åŒæ­¥
    centerCard = getAxisCard();
    // è°ƒè¯•æ—¥å¿—ï¼ˆå¯é€‰ï¼‰
    // console.log("Snap triggered! Target:", targetRotation);
}


function selectCard(card) {
    if (selectionCount >= MAX_SELECTION) return;
    activeCard = card;
    card.userData.state = 'SELECTED';
    card.userData.revealTimer = Date.now(); // åˆå§‹åŒ–è®¡æ—¶å™¨
    if(card.userData.outline) card.userData.outline.visible = false;
    scene.attach(card); 
}

function returnCard(card) {
    deckGroup.attach(card);
    card.userData.state = 'RETURNING';
    activeCard = null;
}

// --- ä¿®æ”¹åï¼šå½’ä½åå¸¦æœ‰å†·å´æœŸ ---
function updateReturningCards() {
    cardObjects.forEach(card => {
        if (card.userData.state === 'RETURNING') {
            // ... (åŸæœ¬çš„ä½ç§»/æ—‹è½¬ä»£ç ä¿æŒä¸å˜) ...
            const targetPos = new THREE.Vector3(
                RADIUS * Math.sin(card.userData.theta), 
                0, 
                -RADIUS * Math.cos(card.userData.theta)
            );
            card.position.lerp(targetPos, 0.08); // ç”¨ä½ ä¹‹å‰çš„å‚æ•°
            
            // ç®€å•çš„æ—‹è½¬æ’å€¼ï¼Œç¡®ä¿å½’ä½æ—¶æ˜¯æ­£çš„
            const dummy = new THREE.Object3D();
            dummy.position.copy(card.position);
            dummy.lookAt(0,0,0);
            card.quaternion.slerp(dummy.quaternion, 0.08);

            // ğŸ›‘ åˆ°è¾¾åˆ¤æ–­
            if (card.position.distanceTo(targetPos) < 0.05) {
                // 1. ç‰©ç†å½’ä½
                deckGroup.attach(card);
                card.position.set(
                    RADIUS * Math.sin(card.userData.theta),
                    0,
                    -RADIUS * Math.cos(card.userData.theta)
                );
                card.rotation.set(0, Math.PI, 0); // ç¡®ä¿æœå‘æ­£ç¡®
                
                // 2. æ ‡è®°çŠ¶æ€å·²å®Œæˆ
                card.userData.state = 'IDLE';

                // 3. ğŸ›‘ æ ¸å¿ƒä¿®æ”¹ï¼šè¿›å…¥å†·å´æœŸ
                isCoolingDown = true;
                
                // 4. å»¶è¿Ÿè§£é”
                setTimeout(() => {
                    // å†·å´ç»“æŸï¼Œæ‰å…è®¸ç³»ç»Ÿå»é€‰åˆ«çš„å¡ï¼Œæˆ–è€…å…è®¸ç”¨æˆ·è½¬åŠ¨
                    activeCard = null;
                    isCoolingDown = false;
                }, COOLDOWN_TIME);
            }
        }
    });
}



function revealCard(card) {
    if (card.userData.state === 'REVEALING') return;
    card.userData.state = 'REVEALING';
    updateStatusText();
    
    const isReversed = Math.random() < 0.5;
    card.userData.isReversed = isReversed;

    const startQ = card.quaternion.clone();
    const targetEuler = new THREE.Euler(0, Math.PI, isReversed ? Math.PI : 0);
    const targetQ = new THREE.Quaternion().setFromEuler(targetEuler);

    const data = card.userData.rawData;
    const name = data[currentLang].name;

    let p = 0;
    function animateFlip() {
        p += 0.03; 
        card.quaternion.slerpQuaternions(startQ, targetQ, p);
        if (p < 1) {
            requestAnimationFrame(animateFlip);
        } else {
            card.rotation.set(0, Math.PI, isReversed ? Math.PI : 0);
            document.getElementById('status-text').innerText = name.toUpperCase();
            setTimeout(() => { dissolve(card, isReversed); }, 2000);
        }
    }
    animateFlip();
}

// --- ä¿®æ”¹åï¼šç¿»ç‰Œåå¸¦æœ‰å†·å´æœŸ ---
function dissolve(card, isReversed) {
    spawnParticles(card.position);
    selectionCount++;
    addToHistory(card.userData.rawData, isReversed);
    
    // éšè—å¡ç‰‡
    card.visible = false;
    card.userData.isChosen = true;
    chosen3DMeshes.push(card); 

    // ğŸ›‘ æ ¸å¿ƒä¿®æ”¹ï¼šè¿›å…¥å†·å´æœŸ
    isCoolingDown = true;

    // å»¶è¿Ÿè§£é”
    setTimeout(() => {
        // åªæœ‰å†·å´ç»“æŸåï¼Œæ‰é‡Šæ”¾ activeCard
        // è¿™æœŸé—´ getAxisCard ä¾ç„¶ä¼šè®¤ä¸º activeCard æ˜¯ä¸»è§’ï¼Œä»è€Œé”å®šä¸­è½´
        activeCard = null;
        isCoolingDown = false;
        
        // æ£€æŸ¥æ˜¯å¦ç»“æŸ
        if (selectionCount >= MAX_SELECTION) startEndRitual();
    }, COOLDOWN_TIME);
}
function startEndRitual() {
    isRitualComplete = true;
    updateStatusText();
    
    document.getElementById('history-container').style.opacity = 0;
    document.getElementById('hud-center').style.opacity = 0;
    
    setTimeout(() => {
        // æ˜¾ç¤ºåº•éƒ¨UI
        document.getElementById('end-ui').style.opacity = 1;
        document.getElementById('end-ui').style.pointerEvents = 'auto';
        document.getElementById('credits').style.opacity = 1;

        // --- é€»è¾‘å˜æ›´ï¼šå…ˆæ˜¾ç¤ºæŸ¥çœ‹æŒ‡å¼•æŒ‰é’®ï¼Œéšè—é‡å¯æŒ‰é’® ---
        document.getElementById('view-reading-btn').style.display = 'block';
        document.getElementById('restart-btn').style.display = 'none';

        // è®¾ç½®æŒ‰é’®è¯­è¨€
        const btnText = currentLang === 'zh' ? "æ­ç¤ºæŒ‡å¼•" : "REVEAL FATE";
        document.getElementById('view-reading-btn').innerText = btnText;

    }, 3500);

    cardObjects.forEach(c => {
        if (!c.userData.isChosen) {
            c.userData.dropSpeed = 0.05 + Math.random() * 0.1;
        }
    });

    chosen3DMeshes.forEach((card, index) => {
        card.visible = true;
        scene.attach(card); 
        // ç»“æŸåŠ¨ç”»èµ·å§‹ä½ç½®
        card.position.set(4 + index*0.5, 3, -4); 
        card.scale.set(0.2, 0.2, 0.2);

        // å“åº”å¼æœ€ç»ˆä½ç½®è®¡ç®—
        const isPortrait = window.innerHeight > window.innerWidth;
        const gap = isPortrait ? 1.8 : 2.2;      
        const depth = isPortrait ? -7.0 : -6.0; 
        const targetY = isPortrait ? 3.0 : 0;
        
        card.userData.finalTargetPos = new THREE.Vector3((index - 1) * gap, targetY, depth);
        card.userData.finalTargetScale = 0.8;
        card.userData.animProgress = 0;
        card.userData.animDelay = index * 30; 
    });

    const textContainer = document.getElementById('final-text-container');
    const t = TEXTS[currentLang];
    
    chosen3DMeshes.forEach(card => {
        const div = document.createElement('div');
        div.className = 'final-card-label';
        const data = card.userData.rawData[currentLang];
        const revText = card.userData.isReversed ? ` (${t.rev})` : "";
        div.innerHTML = `<div class="final-name">${data.name}${revText}</div><div class="final-meaning">${data.meaning}</div>`;
        textContainer.appendChild(div);
    });
    setTimeout(() => { textContainer.style.opacity = 1; }, 2000);
}

// --- ä¿®æ”¹ï¼šè¿›å…¥æ˜Ÿç©ºè§£è¯´æ¨¡å¼ (æ”¯æŒå¼‚æ­¥ API) ---
async function enterStarryVoid() {
    // éšè—æŒ‰é’®å’Œæ ‡ç­¾
    document.getElementById('view-reading-btn').style.display = 'none';
    document.getElementById('final-text-container').style.opacity = 0;
    
    // éšè—æ‰€æœ‰3Då¡ç‰Œ
    chosen3DMeshes.forEach(mesh => { mesh.visible = false; });
    cardObjects.forEach(mesh => { mesh.visible = false; });

    const overlay = document.getElementById('oracle-overlay');
    
    // æ˜¾ç¤º Loading åŠ¨ç”»
    const loadingText = currentLang === 'zh' ? "æ­£åœ¨ä¸æ˜Ÿè¾°è¿æ¥..." : "Connecting with the stars...";
    overlay.innerHTML = `<div style="opacity:0.7; animation: pulse 1.5s infinite;">${loadingText}</div>`;

    // å®šä¹‰æ‰“å­—ç»“æŸåçš„å›è°ƒå‡½æ•°
    const onTypingComplete = () => {
        const restartBtn = document.getElementById('restart-btn');
        restartBtn.style.display = 'block';
        restartBtn.style.opacity = 0;
        let op = 0;
        const fadeTimer = setInterval(() => {
            if(op >= 1) clearInterval(fadeTimer);
            restartBtn.style.opacity = op;
            op += 0.05;
        }, 30);
    };

    // å°è¯•è°ƒç”¨ API
    if (API_KEY && API_KEY.length > 5) {
        try {
            const apiText = await callTarotAPI(chosen3DMeshes);
            typeWriter(apiText, overlay, onTypingComplete);
        } catch (e) {
            console.error("API Error:", e);
            
            // ğŸ”´ è°ƒè¯•æ¨¡å¼ï¼šå¼¹å‡ºé”™è¯¯è­¦å‘Š
            if (DEBUG_MODE) {
                // æç¤ºç”¨æˆ·å®‰è£…æ’ä»¶
                alert(`API è°ƒç”¨å¤±è´¥: ${e.message}\n\nã€è§£å†³æ–¹æ¡ˆã€‘\nDeepSeek API åœ¨æµè§ˆå™¨ç›´æ¥è°ƒç”¨æ—¶ä¼šè¢«æ‹¦æˆª (CORS Error)ã€‚\nè¯·ç¡®ä¿ä»£ç† URL æœ‰æ•ˆã€‚`);
            }
            
            // å¤±è´¥åˆ™é™çº§åˆ°æœ¬åœ°æ–‡æ¡ˆ
            const fallbackText = generateReadingText(); 
            typeWriter(fallbackText, overlay, onTypingComplete);
        }
    } else {
        // æ²¡æœ‰ Keyï¼Œç›´æ¥ä½¿ç”¨æœ¬åœ°é€»è¾‘
        setTimeout(() => {
            const text = generateReadingText();
            typeWriter(text, overlay, onTypingComplete);
        }, 1500);
    }
}

// --- æ–°å¢ï¼šè°ƒç”¨ LLM API è·å–è§£è¯» (åŒ…å« Proxy é€»è¾‘) ---
async function callTarotAPI(cards) {
    const cardDescriptions = cards.map((c, i) => {
        const name = c.userData.rawData[currentLang].name;
        const posName = currentLang === 'zh' ? ["è¿‡å»", "ç°åœ¨", "æœªæ¥"][i] : ["Past", "Present", "Future"][i];
        const status = c.userData.isReversed 
            ? (currentLang === 'zh' ? "é€†ä½ (Reversed)" : "Reversed") 
            : (currentLang === 'zh' ? "æ­£ä½ (Upright)" : "Upright");
        return `${posName}: ${name} [${status}]`;
    }).join("\n");

    const prompt = currentLang === 'zh' 
        ? `ä½ æ˜¯ä¸€ä½ç¥ç§˜çš„å¡”ç½—ç‰Œå åœå¸ˆã€‚è¯·æ ¹æ®ä»¥ä¸‹ç‰Œé˜µä¸ºæ±‚é—®è€…è§£è¯»å‘½è¿ï¼š\n${cardDescriptions}\n\nè¦æ±‚ï¼š\n1. ç”¨ä¸­æ–‡å›ç­”ã€‚\n2. é£æ ¼ç¥ç§˜ã€è¯—æ„ã€å¸¦æœ‰å®¿å‘½æ„Ÿã€‚\n3. ä¸è¦ç½—åˆ—ç‰Œæ„ï¼Œè€Œæ˜¯å°†ä¸‰å¼ ç‰Œä¸²è”æˆä¸€ä¸ªå®Œæ•´çš„æ•…äº‹æˆ–æŒ‡å¼•ã€‚\n4. å­—æ•°æ§åˆ¶åœ¨150å­—ä»¥å†…ã€‚`
        : `You are a mystical Tarot reader. Interpret the following spread for the seeker:\n${cardDescriptions}\n\nRequirements:\n1. Answer in English.\n2. Tone: Mystical, poetic, ominous yet hopeful.\n3. Do not list meanings separately; weave them into a coherent narrative.\n4. Keep it under 150 words.`;

    // å¢åŠ  AbortController ç”¨äºè¶…æ—¶æ§åˆ¶
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 20000); // 20ç§’è¶…æ—¶

    // --- âš ï¸ å…³é”®ä¿®æ­£ï¼šåªæœ‰è¿™é‡Œä½¿ç”¨ä»£ç† ---
    let url = API_ENDPOINT;
    if (USE_PROXY_FOR_API) {
        console.log("æ­£åœ¨åº”ç”¨ä»£ç†ä»¥è§£å†³è·¨åŸŸé—®é¢˜...");
        // å°†ç›®æ ‡ API åœ°å€ç¼–ç åæ‹¼æ¥åˆ°ä»£ç†åœ°å€åé¢
        url = PROXY_BASE_URL + encodeURIComponent(API_ENDPOINT);
    }
    // -------------------------------------

    try {
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${API_KEY}`
            },
            body: JSON.stringify({
                model: API_MODEL,
                messages: [{ role: "user", content: prompt }],
                temperature: 0.7,
                max_tokens: 300
            }),
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);

        if (!response.ok) {
            const errText = await response.text();
            throw new Error(`HTTP ${response.status}: ${errText}`);
        }

        const data = await response.json();
        return data.choices[0].message.content;
    } catch (err) {
        clearTimeout(timeoutId);
        throw err;
    }
}

// --- å¤‡é€‰ï¼šç”Ÿæˆæœ¬åœ°è§£è¯´æ–‡æ¡ˆ ---
function generateReadingText() {
    const m1 = chosen3DMeshes[0].userData.rawData[currentLang].meaning;
    const m2 = chosen3DMeshes[1].userData.rawData[currentLang].meaning;
    const m3 = chosen3DMeshes[2].userData.rawData[currentLang].meaning;
    
    if (currentLang === 'zh') {
        return `å‘½è¿çš„è½¨è¿¹å·²åœ¨æ˜Ÿè¾°ä¸­æ˜¾ç°...<br><br>` +
               `è¿‡å»ï¼Œä½ ç»å†äº† ${m1}ã€‚<br>` +
               `æ­¤åˆ»ï¼Œæ­£å¦‚ ${m2} æ‰€æ˜­ç¤ºçš„ï¼Œä½ éœ€è¦ä¸“æ³¨äºå½“ä¸‹çš„åŠ›é‡ã€‚<br>` +
               `è€Œæœªæ¥ï¼Œ${m3} å°†ä¼šæ˜¯ä½ çš„æŒ‡å¼•ã€‚<br><br>` +
               `ç›¸ä¿¡ç›´è§‰ï¼Œæ‹¥æŠ±å˜åŒ–ã€‚`;
    } else {
        return `The stars have aligned to reveal your path...<br><br>` +
               `In the past, you walked through ${m1}.<br>` +
               `Presently, as shown by ${m2}, focus on your inner power.<br>` +
               `For the future, let ${m3} be your guiding light.<br><br>` +
               `Trust your intuition. Embrace the change.`;
    }
}

// --- æ‰“å­—æœºç‰¹æ•ˆ ---
function typeWriter(htmlText, element, callback) {
    element.innerHTML = "";
    const plainText = htmlText.replace(/<br>/g, '\n'); 
    let i = 0;
    const speed = 50; 
    
    function type() {
        if (i < plainText.length) {
            const char = plainText.charAt(i);
            element.innerHTML += (char === '\n') ? '<br>' : char;
            i++;
            setTimeout(type, speed);
        } else {
            if (callback) callback();
        }
    }
    type();
}

function animateFinalFormation() {
    cardObjects.forEach(c => {
        if (!c.userData.isChosen && c.position.y > -10) {
            c.position.y -= c.userData.dropSpeed;
            c.rotation.x += 0.05;
        }
    });

    chosen3DMeshes.forEach(card => {
        if (card.userData.animDelay > 0) {
            card.userData.animDelay--;
            return;
        }
        if (card.userData.animProgress < 1) {
            card.userData.animProgress += 0.015; 
            const t = card.userData.animProgress;
            const easeT = t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t; 
            card.position.lerp(card.userData.finalTargetPos, 0.05);
            const s = THREE.MathUtils.lerp(0.2, card.userData.finalTargetScale, easeT);
            card.scale.set(s, s, s);
            const isRev = card.userData.isReversed;
            card.rotation.set(0, Math.PI, isRev ? Math.PI : 0);
        }
    });
}

function addToHistory(rawData, isRev) {
    const con = document.getElementById('history-container'); 
    const slot = document.createElement('div'); 
    slot.className = `history-slot ${isRev?'is-reversed':''}`;
    const t = TEXTS[currentLang];
    const data = rawData[currentLang];
    slot.innerHTML = `<img src="${rawData.url}"><div class="history-info"><div class="history-name">${data.name}</div><div class="history-rev">${t.rev}</div></div>`;
    con.appendChild(slot); 
}

const particles = [];
function spawnParticles(pos) {
    const count = 500; const geo = new THREE.BufferGeometry(); const pArr = new Float32Array(count*3); const vArr = new Float32Array(count*3);
    for(let i=0;i<count;i++) {
        pArr[i*3]=pos.x+(Math.random()-0.5)*CARD_W; pArr[i*3+1]=pos.y+(Math.random()-0.5)*CARD_H; pArr[i*3+2]=pos.z;
        vArr[i*3]=(Math.random()-0.5)*0.02; vArr[i*3+1]=Math.random()*0.03; vArr[i*3+2]=(Math.random()-0.5)*0.02;
    }
    geo.setAttribute('position', new THREE.BufferAttribute(pArr,3));
    const mat = new THREE.PointsMaterial({color: GOLD_COLOR, size:0.04, transparent:true});
    const sys = new THREE.Points(geo,mat); sys.userData={life:1.0, vels:vArr}; scene.add(sys); particles.push(sys);
}
function updateParticles() {
    for(let i=particles.length-1;i>=0;i--) {
        const sys=particles[i], p=sys.geometry.attributes.position.array, v=sys.userData.vels; sys.userData.life-=0.02;
        for(let j=0;j<p.length/3;j++){ p[j*3]+=v[j*3]; p[j*3+1]+=v[j*3+1]; p[j*3+2]+=v[j*3+2]; }
        sys.geometry.attributes.position.needsUpdate=true; sys.material.opacity=sys.userData.life;
        if(sys.userData.life<=0){scene.remove(sys); particles.splice(i,1);}
    }
}

function initCamera() {
    const videoElem = document.getElementById('video-feed');
    // âš ï¸ Mediapipe æ¨¡å‹ï¼šç›´æ¥ä½¿ç”¨ CDNï¼Œä¸èµ°ä»£ç†
    const hands = new Hands({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
    hands.setOptions({maxNumHands:1, modelComplexity:0, minDetectionConfidence:0.5});
    hands.onResults(res => {
        if(res.multiHandLandmarks && res.multiHandLandmarks.length>0) {
            const lm = res.multiHandLandmarks[0];
            handX += ((1-lm[8].x)*2-1 - handX)*0.2;
            const pinch = Math.hypot(lm[8].x-lm[4].x, lm[8].y-lm[4].y);
            const fist = lm[12].y>lm[9].y && lm[16].y>lm[13].y;
            handState = fist ? 'FIST' : (pinch<0.05 ? 'PINCH' : 'OPEN');
            if (!isRitualComplete) {
                document.getElementById('gesture-icon').innerText = handState==='FIST'?'âœŠ':(handState==='PINCH'?'ğŸ‘Œ':'âœ‹');
            }
        }
    });
    const cam = new Camera(videoElem, {onFrame: async()=>{await hands.send({image:videoElem})}, width:320, height:240});
    cam.start();
}

// å“åº”å¼ç›¸æœºä½ç½®æ›´æ–°
function updateCameraPos() {
    const aspect = window.innerWidth / window.innerHeight;
    camera.aspect = aspect;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    
    // å…³é”®ï¼šç«–å±æ¨¡å¼ä¸‹ç›¸æœºåé€€ï¼Œä»¥ä¾¿çœ‹åˆ°å®Œæ•´çš„ç‰Œé˜µç¯
    if (aspect < 1) { // ç«–å±
        camera.position.z = 1; // è·ç¦»æ›´è¿œ
        camera.position.y = 1;
    } else { // æ¨ªå±
        camera.position.z = 0;
        camera.position.y = 0;
    }
}

function animate() {
    requestAnimationFrame(animate);
    starSystem.rotation.y += 0.0002;
    if (isStarted) {
        handleInput(); 
        updateReturningCards(); 
        updateParticles();
        // ğŸ‘‰ æ–°å¢ï¼šåœ¨è¿™é‡Œè°ƒç”¨è§†è§‰åˆ·æ–°
        updateCardVisuals();
    }
    renderer.render(scene, camera);
}
animate();


// --- ä¿®æ”¹åï¼šè§†è§‰èšå…‰ç¯é€»è¾‘ (éœ¸é“æ¨¡å¼) ---
function updateCardVisuals() {
    // å®šä¹‰é¢œè‰²
    const colorActive = new THREE.Color(0xffffff); // äº® (èšå…‰)
    const colorDimmed = new THREE.Color(0x333333); // æš— (èƒŒæ™¯å‹æš—ï¼Œæ¯”ä¹‹å‰æ›´æš—ä¸€ç‚¹ä»¥çªå‡ºä¸»è§’)
    
    // å‘å…‰å¼ºåº¦
    const emissiveActive = new THREE.Color(0x222222);
    const emissiveDimmed = new THREE.Color(0x000000);

    cardObjects.forEach(card => {
        // 1. å·²ç»é£èµ°/æ¶ˆå¤±çš„å¡ï¼Œç›´æ¥è·³è¿‡ï¼Œä¸å¤„ç†
        if (card.userData.isChosen) return;

        let isTarget = false;

        // --- æ ¸å¿ƒåˆ¤æ–­é€»è¾‘ ---
        if (activeCard) {
            // åœºæ™¯ Aï¼šç©å®¶æ‰‹é‡Œæ‹¿ç€å¡ (Active å­˜åœ¨)
            // åªæœ‰æ‰‹é‡Œè¿™å¼ æ˜¯äº®çš„ç›®æ ‡ï¼Œå…¶ä»–å…¨æš—
            if (card === activeCard) {
                isTarget = true;
            }
        } else {
            // åœºæ™¯ Bï¼šç©å®¶æ²¡æ‹¿å¡ (æµè§ˆæ¨¡å¼)
            // åªæœ‰æ­£å¯¹ä¸­è½´çš„é‚£å¼ æ˜¯äº®çš„ç›®æ ‡
            if (card === centerCard) {
                isTarget = true;
            }
        }
        // --------------------

        const targetColor = isTarget ? colorActive : colorDimmed;
        const targetEmissive = isTarget ? emissiveActive : emissiveDimmed;

        // æ‰§è¡Œé¢œè‰²æ¸å˜
        card.children.forEach(mesh => {
            if (mesh.isMesh && mesh.material) {
                // é¢œè‰²è¿‡æ¸¡
                mesh.material.color.lerp(targetColor, 0.1);
                
                // è‡ªå‘å…‰è¿‡æ¸¡ (å¢åŠ ç¥åœ£æ„Ÿ)
                if (mesh.material.emissive) {
                    mesh.material.emissive.lerp(targetEmissive, 0.1);
                }
            }
        });
    });
}

window.onresize = updateCameraPos;
</script>
</body>
</html>
