<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Arcanum: The Complete Ritual</title>
    <style>
        /* --- æ ¸å¿ƒåŸºç¡€æ ·å¼ --- */
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Cinzel', 'Noto Serif SC', serif; 
            user-select: none; 
            -webkit-tap-highlight-color: transparent; 
            -webkit-touch-callout: none;
        }
        #canvas-container { 
            width: 100vw; 
            height: 100vh; 
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 1; 
            touch-action: none; /* ç¦æ­¢æµè§ˆå™¨é»˜è®¤æ‰‹åŠ¿ */
        }
        
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;800&family=Noto+Serif+SC:wght@300;500&display=swap');

        /* --- åˆå§‹åŠ è½½ç•Œé¢ --- */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 100;
            background: radial-gradient(circle at center, rgba(0,0,0,0.6) 0%, #000000 95%);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 1.5s cubic-bezier(0.25, 1, 0.5, 1);
            color: #d4af37;
            backdrop-filter: blur(5px);
        }

        .title-group { 
            text-align: center; margin-bottom: 50px; 
            padding: 0 20px;
            animation: floatTitle 6s ease-in-out infinite; 
        }
        
        /* å“åº”å¼æ ‡é¢˜ */
        h1 { 
            font-size: 42px; margin: 0; letter-spacing: 8px; font-weight: 800;
            background: linear-gradient(135deg, #fff 0%, #d4af37 50%, #996515 100%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 20px rgba(212, 175, 55, 0.4));
        }
        h2 { 
            font-size: 11px; font-weight: 400; letter-spacing: 4px; color: #a0a0a0; 
            margin-top: 15px; text-transform: uppercase; opacity: 0.8;
            border-top: 1px solid rgba(212, 175, 55, 0.3); display: inline-block; padding-top: 15px; 
        }

        /* æ¡Œé¢ç«¯è°ƒæ•´ */
        @media (min-width: 768px) {
            h1 { font-size: 72px; letter-spacing: 20px; }
            h2 { font-size: 14px; letter-spacing: 8px; }
        }

        @keyframes floatTitle { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }

        /* é€‰é¡¹å¸ƒå±€ */
        .options-grid { 
            display: flex; flex-direction: column; gap: 25px; 
            margin-bottom: 50px; text-align: center; 
            opacity: 0; animation: fadeUp 1s ease-out 0.5s forwards; 
        }
        @media (min-width: 768px) {
            .options-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 60px; }
        }

        .option-group { display: flex; flex-direction: column; gap: 12px; align-items: center; }
        .option-label { font-size: 10px; letter-spacing: 2px; color: #666; text-transform: uppercase; font-weight: 600; }

        /* èƒ¶å›ŠæŒ‰é’® */
        .choice-btn {
            background: rgba(255, 255, 255, 0.03); border: 1px solid rgba(212, 175, 55, 0.3); color: #888;
            padding: 12px 0; width: 160px; font-family: inherit; font-size: 12px; cursor: pointer;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            border-radius: 50px; position: relative; overflow: hidden; backdrop-filter: blur(2px);
        }
        .choice-btn.active { 
            border-color: #d4af37; color: #fff; 
            background: rgba(212, 175, 55, 0.15); box-shadow: 0 0 25px rgba(212, 175, 55, 0.15); 
        }
        .choice-btn:hover { border-color: #fff; color: #fff; transform: scale(1.05); }

        #enter-btn {
            background: transparent; color: #d4af37; border: 1px solid #d4af37;
            padding: 16px 80px; font-size: 14px; letter-spacing: 6px; cursor: pointer;
            font-family: inherit; font-weight: 600; border-radius: 50px; 
            transition: all 0.5s; opacity: 0; animation: fadeUp 1s ease-out 0.8s forwards;
        }
        #enter-btn:hover { background: #d4af37; color: #000; box-shadow: 0 0 40px rgba(212, 175, 55, 0.4); transform: scale(1.05); }
        
        @keyframes fadeUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

        /* --- æ¸¸æˆå†… UI --- */
        #ui-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 20; pointer-events: none; opacity: 0; transition: opacity 1.5s; 
        }
        
        /* å†å²è®°å½• */
        #history-container {
            position: absolute; top: 20px; right: 20px;
            display: flex; flex-direction: row; gap: 8px;
            pointer-events: auto; z-index: 30; align-items: flex-start;
        }
        .history-slot {
            width: 40px; height: 68px; background: #111; border: 1px solid #d4af37; border-radius: 4px; overflow: hidden;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.8); animation: slotEnter 0.6s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        @media (min-width: 768px) { .history-slot { width: 50px; height: 85px; border-radius: 6px; } }
        
        @keyframes slotEnter { from { opacity:0; transform: translateY(-20px); } to { opacity:1; transform: translateY(0); } }
        .history-slot img { width: 100%; height: 100%; object-fit: cover; }
        .is-reversed img { transform: rotate(180deg); }

        /* çŠ¶æ€æŒ‡ç¤º HUD */
        #hud-center {
            position: absolute; bottom: 8%; left: 50%; transform: translateX(-50%);
            text-align: center; color: #d4af37; pointer-events: none; width: 90%; transition: opacity 1s;
        }
        #gesture-icon { font-size: 24px; display: block; margin-bottom: 10px; opacity: 0.9; text-shadow: 0 0 15px #d4af37;}
        #status-text { font-size: 10px; letter-spacing: 3px; text-transform: uppercase; font-weight: 600; opacity: 0.8; }
        @media (min-width: 768px) { #gesture-icon { font-size: 32px; } #status-text { font-size: 12px; } }

        /* æœ€ç»ˆç»“æœå±•ç¤º */
        #final-text-container {
            position: absolute; top: 65%; left: 0; width: 100%;
            text-align: center; opacity: 0; transition: opacity 2s;
            pointer-events: none; display: flex; justify-content: center; 
            gap: 10px; flex-wrap: nowrap;
        }
        @media (min-width: 768px) { #final-text-container { top: 72%; gap: 60px; } }

        .final-card-label {
            display: flex; flex-direction: column; 
            width: 30vw; max-width: 200px;
            color: #fff; text-shadow: 0 0 10px #d4af37; text-align: center;
            animation: textFloat 3s ease-in-out infinite alternate;
        }
        @keyframes textFloat { from { transform: translateY(0); } to { transform: translateY(-5px); } }
        
        .final-name { 
            font-size: 12px; font-weight: bold; color: #d4af37; 
            margin-bottom: 5px; border-bottom: 1px solid rgba(212, 175, 55, 0.3); padding-bottom: 5px; 
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .final-meaning { font-size: 10px; color: #ccc; font-style: italic; line-height: 1.4; opacity: 0.8; }
        @media (min-width: 768px) { .final-name { font-size: 15px; } .final-meaning { font-size: 12px; } }

        /* åº•éƒ¨é‡å¯æŒ‰é’® */
        #end-ui {
            position: absolute; bottom: 12%; left: 0; width: 100%;
            display: flex; justify-content: center;
            opacity: 0; pointer-events: none; transition: opacity 1.5s; z-index: 50;
        }
        #restart-btn {
            background: rgba(0,0,0,0.7); border: 1px solid #d4af37; color: #d4af37;
            padding: 12px 50px; font-size: 12px; letter-spacing: 4px; 
            border-radius: 50px; cursor: pointer; font-family: inherit; transition: 0.4s;
            backdrop-filter: blur(5px); pointer-events: auto;
        }
        #restart-btn:hover { background: #d4af37; color: #000; box-shadow: 0 0 25px rgba(212, 175, 55, 0.6); }

        /* åˆ¶ä½œäººå‘˜ */
        #credits {
            position: absolute; bottom: 15px; right: 20px;
            text-align: right; color: #666; font-size: 9px; line-height: 1.6; 
            opacity: 0; transition: opacity 1.5s; pointer-events: none; z-index: 50; 
        }

        #video-feed { position: absolute; bottom: 10px; right: 10px; width: 80px; opacity: 0; transform: scaleX(-1); pointer-events: none; border: 1px solid #d4af37; transition: opacity 0.5s; }
        #loader { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); color: #d4af37; letter-spacing: 6px; font-size: 12px; font-weight: bold; z-index: 200; }
        
        /* è£…é¥°ç²’å­ */
        .sparkle { position: absolute; background: white; border-radius: 50%; pointer-events: none; opacity: 0; box-shadow: 0 0 10px #d4af37; animation: sparkleFloat linear forwards; }
        @keyframes sparkleFloat { 0% { opacity: 0; transform: scale(0); } 50% { opacity: 1; transform: translateY(-30px) scale(1); } 100% { opacity: 0; transform: translateY(-60px) scale(0); } }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>
    <div id="loader"></div>

    <div id="start-screen">
        <div class="title-group">
            <h1>ARCANUM</h1>
            <h2 id="subtitle">The Virtual Ritual</h2>
        </div>

        <div class="options-grid">
            <div class="option-group">
                <div class="option-label" id="lbl-language">Language / è¯­è¨€</div>
                <button class="choice-btn active" onclick="setLang('en')" id="btn-en">English</button>
                <button class="choice-btn" onclick="setLang('zh')" id="btn-zh">ä¸­æ–‡</button>
            </div>
            <div class="option-group">
                <div class="option-label" id="lbl-input">Input / æ“æ§</div>
                <button class="choice-btn active" onclick="setInput('hand')" id="btn-hand">Hand Gesture âœ‹</button>
                <button class="choice-btn" onclick="setInput('mouse')" id="btn-mouse">Touch / Mouse ğŸ–±ï¸</button>
            </div>
        </div>

        <button id="enter-btn" onclick="enterExperience()">ENTER</button>
    </div>

    <div id="ui-layer">
        <div id="history-container"></div>
        <div id="final-text-container"></div>
        
        <div id="end-ui">
            <button id="restart-btn" onclick="location.reload()">RESTART RITUAL</button>
        </div>
        
        <div id="credits">
            Jerry Hu & Gemini åˆ¶ä½œ<br>huqiuzhi10@gmail.com
        </div>

        <div id="hud-center">
            <span id="gesture-icon">âœ‹</span>
            <div id="status-text">Wave to Turn Â· Pinch to Select</div>
        </div>
    </div>

    <video id="video-feed" playsinline></video>
    <div id="canvas-container"></div>

<script>
// --- è£…é¥°æ€§ï¼šèƒŒæ™¯é—ªå…‰ç‰¹æ•ˆ ---
function createSparkles() {
    const screen = document.getElementById('start-screen');
    if(screen.style.display === 'none') return; 
    const sparkle = document.createElement('div');
    sparkle.className = 'sparkle';
    sparkle.style.left = Math.random() * 100 + '%';
    sparkle.style.top = Math.random() * 100 + '%';
    const size = Math.random() * 3 + 1; 
    sparkle.style.width = size + 'px';
    sparkle.style.height = size + 'px';
    sparkle.style.animationDuration = (Math.random() * 2 + 1) + 's'; 
    screen.appendChild(sparkle);
    setTimeout(() => { sparkle.remove(); }, 3000);
}
setInterval(createSparkles, 300);

/**
 * å…¨å±€çŠ¶æ€ç®¡ç† (STATE & CONFIG)
 */
const CONFIG = {
    radius: 6.5,
    cardW: 1.5,
    cardH: 2.58,
    maxSelection: 3,
    dragThreshold: 5 // åƒç´ ï¼Œè¶…è¿‡è¿™ä¸ªè·ç¦»è§†ä¸ºæ‹–æ‹½ï¼Œå¦åˆ™è§†ä¸ºç‚¹å‡»
};

const STATE = {
    lang: 'en',
    mode: 'hand', // 'hand' | 'mouse'
    isStarted: false,
    isRitualComplete: false,
    deckList: [],
    cardObjects: [], // Three.js objects
    chosenCards: [],
    activeCard: null,
    selectionCount: 0,
    ringRotation: 0,
    targetRotation: 0
};

// å°„çº¿æ£€æµ‹ (ç”¨äºç‚¹å‡»)
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

/**
 * æ–‡æœ¬æ•°æ® (i18n)
 */
const TEXTS = {
    en: {
        subtitle: "The Virtual Ritual", lblLang: "Language", lblInput: "Input Method", enter: "ENTER VOID",
        statusWave: "Wave to Turn Â· Pinch Center Card",
        statusMouse: "Drag to Spin Â· Click Card to Select",
        statusFist: "FIST TO REVEAL",
        statusTap: "CLICK AGAIN TO REVEAL",
        statusSpace: "SPACE TO REVEAL",
        statusReveal: "OBSERVING FATE...", statusDone: "RITUAL COMPLETE", rev: "Reversed", restart: "RESTART RITUAL",
        btnHand: "Hand Gesture âœ‹", btnMouse: "Touch / Mouse ğŸ–±ï¸"
    },
    zh: {
        subtitle: "è™šæ‹Ÿå¡”ç½—ä»ªå¼", lblLang: "è¯­è¨€è®¾ç½®", lblInput: "æ“æ§æ–¹å¼", enter: "è¿›å…¥è™šç©º",
        statusWave: "æŒ¥æ‰‹è½¬åŠ¨ç‰Œé˜µ Â· æåˆæ‰‹æŒ‡é€‰ä¸­",
        statusMouse: "å·¦å³æ»‘åŠ¨è½¬åŠ¨ Â· ç‚¹å‡»ç‰Œé¢é€‰ä¸­",
        statusFist: "æ¡æ‹³æ­ç¤ºå‘½è¿",
        statusTap: "å†æ¬¡ç‚¹å‡»ç‰Œé¢æ­ç¤º",
        statusSpace: "æŒ‰ç©ºæ ¼é”®æ­ç¤º",
        statusReveal: "æ­£åœ¨è§‚æµ‹å‘½è¿...", statusDone: "ä»ªå¼å®Œæˆ", rev: "é€†ä½", restart: "é‡æ–°å¼€å§‹ä»ªå¼",
        btnHand: "æ‰‹åŠ¿æ§åˆ¶ âœ‹", btnMouse: "è§¦æ§ / é¼ æ ‡ ğŸ–±ï¸"
    }
};

// 22å¼ å¤§é˜¿å¡çº³æ•°æ®
const RWS_DATA = [
    { id: 0, en: { name: "The Fool", meaning: "New beginnings, innocence, spontaneity" }, zh: { name: "æ„šè€…", meaning: "æ–°çš„å¼€å§‹ï¼Œå¤©çœŸï¼Œè‡ªå‘æ€§ï¼Œå†’é™©" } },
    { id: 1, en: { name: "The Magician", meaning: "Manifestation, resourcefulness, power" }, zh: { name: "é­”æœ¯å¸ˆ", meaning: "æ˜¾åŒ–ï¼Œèµ„æºä¸°å¯Œï¼ŒåŠ›é‡ï¼Œåˆ›é€ åŠ›" } },
    { id: 2, en: { name: "High Priestess", meaning: "Intuition, sacred knowledge" }, zh: { name: "å¥³ç¥­å¸", meaning: "ç›´è§‰ï¼Œç¥åœ£çŸ¥è¯†ï¼Œæ½œæ„è¯†ï¼Œç¥ç§˜" } },
    { id: 3, en: { name: "The Empress", meaning: "Femininity, beauty, nature" }, zh: { name: "çš‡å", meaning: "å¥³æ€§åŠ›é‡ï¼Œç¾ä¸½ï¼Œè‡ªç„¶ï¼Œå­•è‚²" } },
    { id: 4, en: { name: "The Emperor", meaning: "Authority, establishment" }, zh: { name: "çš‡å¸", meaning: "æƒå¨ï¼Œä½“åˆ¶ï¼Œç»“æ„ï¼Œæ§åˆ¶" } },
    { id: 5, en: { name: "The Hierophant", meaning: "Spiritual wisdom, beliefs" }, zh: { name: "æ•™çš‡", meaning: "ç²¾ç¥æ™ºæ…§ï¼Œä¿¡ä»°ï¼Œä¼ ç»Ÿï¼Œæ•™å¯¼" } },
    { id: 6, en: { name: "The Lovers", meaning: "Love, harmony, choices" }, zh: { name: "æ‹äºº", meaning: "çˆ±ï¼Œå’Œè°ï¼Œå…³ç³»ï¼Œé€‰æ‹©" } },
    { id: 7, en: { name: "The Chariot", meaning: "Control, willpower, success" }, zh: { name: "æˆ˜è½¦", meaning: "æ§åˆ¶ï¼Œæ„å¿—åŠ›ï¼ŒæˆåŠŸï¼Œè¡ŒåŠ¨" } },
    { id: 8, en: { name: "Strength", meaning: "Strength, courage, persuasion" }, zh: { name: "åŠ›é‡", meaning: "åŠ›é‡ï¼Œå‹‡æ°”ï¼Œè¯´æœï¼Œå½±å“åŠ›" } },
    { id: 9, en: { name: "The Hermit", meaning: "Soul-searching, introspection" }, zh: { name: "éšå£«", meaning: "æ¢ç´¢å†…å¿ƒï¼Œå†…çœï¼Œç‹¬å¤„ï¼ŒæŒ‡å¼•" } },
    { id: 10, en: { name: "Wheel of Fortune", meaning: "Good luck, karma, destiny" }, zh: { name: "å‘½è¿ä¹‹è½®", meaning: "å¥½è¿ï¼Œä¸šåŠ›ï¼Œç”Ÿå‘½å‘¨æœŸï¼Œå‘½è¿" } },
    { id: 11, en: { name: "Justice", meaning: "Justice, fairness, truth" }, zh: { name: "æ­£ä¹‰", meaning: "æ­£ä¹‰ï¼Œå…¬å¹³ï¼ŒçœŸç†ï¼Œå› æœ" } },
    { id: 12, en: { name: "Hanged Man", meaning: "Pause, surrender, letting go" }, zh: { name: "å€’åŠäºº", meaning: "æš‚åœï¼Œè‡£æœï¼Œæ”¾æ‰‹ï¼Œæ–°è§†è§’" } },
    { id: 13, en: { name: "Death", meaning: "Endings, change, transformation" }, zh: { name: "æ­»ç¥", meaning: "ç»“æŸï¼Œæ”¹å˜ï¼Œè½¬åŒ–ï¼Œè¿‡æ¸¡" } },
    { id: 14, en: { name: "Temperance", meaning: "Balance, moderation, patience" }, zh: { name: "èŠ‚åˆ¶", meaning: "å¹³è¡¡ï¼Œé€‚åº¦ï¼Œè€å¿ƒï¼Œç›®æ ‡" } },
    { id: 15, en: { name: "The Devil", meaning: "Shadow self, addiction" }, zh: { name: "æ¶é­”", meaning: "é˜´æš—é¢ï¼Œæ‰§ç€ï¼Œæˆç˜¾ï¼ŒæŸç¼š" } },
    { id: 16, en: { name: "The Tower", meaning: "Sudden change, upheaval" }, zh: { name: "é«˜å¡”", meaning: "çªå˜ï¼Œå‰§å˜ï¼Œæ··ä¹±ï¼Œå¯ç¤º" } },
    { id: 17, en: { name: "The Star", meaning: "Hope, faith, renewal" }, zh: { name: "æ˜Ÿæ˜Ÿ", meaning: "å¸Œæœ›ï¼Œä¿¡å¿µï¼Œç›®æ ‡ï¼Œæ–°ç”Ÿ" } },
    { id: 18, en: { name: "The Moon", meaning: "Illusion, fear, anxiety" }, zh: { name: "æœˆäº®", meaning: "å¹»è§‰ï¼Œææƒ§ï¼Œç„¦è™‘ï¼Œæ½œæ„è¯†" } },
    { id: 19, en: { name: "The Sun", meaning: "Positivity, fun, warmth" }, zh: { name: "å¤ªé˜³", meaning: "ç§¯æï¼Œå¿«ä¹ï¼Œæ¸©æš–ï¼ŒæˆåŠŸ" } },
    { id: 20, en: { name: "Judgement", meaning: "Judgement, rebirth, calling" }, zh: { name: "å®¡åˆ¤", meaning: "å®¡åˆ¤ï¼Œé‡ç”Ÿï¼Œå†…å¿ƒå¬å”¤ï¼Œèµ¦å…" } },
    { id: 21, en: { name: "The World", meaning: "Completion, integration" }, zh: { name: "ä¸–ç•Œ", meaning: "å®Œæˆï¼Œæ•´åˆï¼Œæˆå°±ï¼Œåœ†æ»¡" } }
];

// --- ç•Œé¢æ§åˆ¶é€»è¾‘ ---
function setLang(lang) {
    STATE.lang = lang;
    updateStartUI();
}
function setInput(mode) {
    STATE.mode = mode;
    updateStartUI();
}
function updateStartUI() {
    document.querySelectorAll('.choice-btn').forEach(b => b.classList.remove('active'));
    document.getElementById(`btn-${STATE.lang}`).classList.add('active');
    document.getElementById(`btn-${STATE.mode}`).classList.add('active');
    
    const t = TEXTS[STATE.lang];
    document.getElementById('subtitle').innerText = t.subtitle;
    document.getElementById('lbl-language').innerText = t.lblLang;
    document.getElementById('lbl-input').innerText = t.lblInput;
    document.getElementById('enter-btn').innerText = t.enter;
    document.getElementById('restart-btn').innerText = t.restart;
    document.getElementById('btn-hand').innerText = t.btnHand;
    document.getElementById('btn-mouse').innerText = t.btnMouse;
}

function enterExperience() {
    STATE.isStarted = true;
    const screen = document.getElementById('start-screen');
    screen.style.opacity = 0;
    screen.style.pointerEvents = 'none'; 
    setTimeout(() => { screen.style.display = 'none'; }, 1500);
    
    const ui = document.getElementById('ui-layer');
    ui.style.opacity = 1;

    // æ‰‹åŠ¿æ¨¡å¼ä¸‹å°è¯•å¼€å¯æ‘„åƒå¤´ï¼Œå¤±è´¥ä¸æŠ¥é”™ï¼Œé™é»˜é™çº§ä¸ºè§¦æ‘¸
    if (STATE.mode === 'hand') {
        document.getElementById('video-feed').style.opacity = 0.3;
        initCamera();
    } else {
        // çº¯é¼ æ ‡/è§¦æ‘¸æ¨¡å¼ï¼Œä¸æ˜¾ç¤ºè§†é¢‘æ¡†
        document.getElementById('video-feed').style.display = 'none';
    }
    
    spawnDeck();
    updateStatusText();
    handleResize(); // ç«‹å³é€‚é…å±å¹•
}

// --- Three.js åˆå§‹åŒ– ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);
scene.fog = new THREE.FogExp2(0x000000, 0.012);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
camera.position.set(0, 0, 0); // åˆå§‹å€¼ï¼Œä¼šè¢« resize è¦†ç›–

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
document.getElementById('canvas-container').appendChild(renderer.domElement);

// ç¯å…‰
const texLoader = new THREE.TextureLoader();
const texBackGlobal = texLoader.load('./cards/back.png'); 
texBackGlobal.anisotropy = renderer.capabilities.getMaxAnisotropy();
texBackGlobal.center.set(0.5, 0.5);

const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
scene.add(ambientLight);
const frontLight = new THREE.DirectionalLight(0xffeaac, 0.6);
frontLight.position.set(0, 2, 5);
scene.add(frontLight);

// æ˜Ÿç©ºèƒŒæ™¯
const starGeo = new THREE.BufferGeometry();
const starPos = new Float32Array(3000*3);
for(let i=0;i<3000*3;i++) starPos[i] = (Math.random() - 0.5) * 80;
starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
const starMat = new THREE.PointsMaterial({color: 0x888888, size: 0.06});
const starSystem = new THREE.Points(starGeo, starMat);
scene.add(starSystem);

// --- ç²’å­ç³»ç»Ÿ ---
const particles = [];
function spawnParticles(pos) {
    const count = 300; 
    const geo = new THREE.BufferGeometry(); 
    const pArr = new Float32Array(count*3); 
    const vArr = new Float32Array(count*3);
    for(let i=0;i<count;i++) {
        pArr[i*3] = pos.x + (Math.random()-0.5)*CONFIG.cardW;
        pArr[i*3+1] = pos.y + (Math.random()-0.5)*CONFIG.cardH;
        pArr[i*3+2] = pos.z;
        vArr[i*3] = (Math.random()-0.5)*0.03;
        vArr[i*3+1] = (Math.random()-0.5)*0.03;
        vArr[i*3+2] = (Math.random()-0.5)*0.03;
    }
    geo.setAttribute('position', new THREE.BufferAttribute(pArr,3));
    const mat = new THREE.PointsMaterial({color: GOLD_COLOR, size:0.05, transparent:true});
    const sys = new THREE.Points(geo,mat); 
    sys.userData = { life: 1.0, vels: vArr }; 
    scene.add(sys); 
    particles.push(sys);
}
function updateParticles() {
    for(let i=particles.length-1;i>=0;i--) {
        const sys = particles[i];
        const p = sys.geometry.attributes.position.array;
        const v = sys.userData.vels; 
        sys.userData.life -= 0.02;
        for(let j=0; j<p.length/3; j++){ 
            p[j*3] += v[j*3]; 
            p[j*3+1] += v[j*3+1]; 
            p[j*3+2] += v[j*3+2]; 
        }
        sys.geometry.attributes.position.needsUpdate = true; 
        sys.material.opacity = sys.userData.life;
        if(sys.userData.life <= 0){ scene.remove(sys); particles.splice(i,1); }
    }
}

// --- å¡ç‰Œç”Ÿæˆ ---
const deckGroup = new THREE.Group();
scene.add(deckGroup);

const shape = new THREE.Shape();
const w=CONFIG.cardW/2, h=CONFIG.cardH/2, r=CONFIG.cardH*0.05; // åŠ¨æ€åœ†è§’
shape.moveTo(-w+r, -h); shape.lineTo(w-r, -h); shape.quadraticCurveTo(w, -h, w, -h+r);
shape.lineTo(w, h-r); shape.quadraticCurveTo(w, h, w-r, h);
shape.lineTo(-w+r, h); shape.quadraticCurveTo(-w, h, -w, h-r);
shape.lineTo(-w, -h+r); shape.quadraticCurveTo(-w, -h, -w+r, -h);
const faceGeo = new THREE.ShapeGeometry(shape);

// ä¿®å¤ UV
const posAttribute = faceGeo.attributes.position;
const uvAttribute = faceGeo.attributes.uv;
for (let i = 0; i < posAttribute.count; i++) {
    const x = posAttribute.getX(i);
    const y = posAttribute.getY(i);
    uvAttribute.setXY(i, (x / CONFIG.cardW) + 0.5, (y / CONFIG.cardH) + 0.5);
}
uvAttribute.needsUpdate = true;

const matBase = { roughness: 0.6, metalness: 0.1 };
const edgeMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, ...matBase });
const outlineMat = new THREE.LineBasicMaterial({ color: GOLD_COLOR, linewidth: 2 });

function createCardMesh(data, index, total) {
    const group = new THREE.Group();
    const texFront = texLoader.load(data.url);
    texFront.anisotropy = renderer.capabilities.getMaxAnisotropy();
    texFront.center.set(0.5, 0.5);
    
    const matBack = new THREE.MeshStandardMaterial({ map: texBackGlobal, ...matBase });
    const matFront = new THREE.MeshStandardMaterial({ map: texFront, ...matBase });

    const meshBack = new THREE.Mesh(faceGeo, matBack);
    meshBack.position.z = 0.005; 
    const meshFront = new THREE.Mesh(faceGeo, matFront);
    meshFront.rotation.y = Math.PI;
    meshFront.position.z = -0.005;
    const meshFiller = new THREE.Mesh(faceGeo, edgeMat);
    meshFiller.scale.set(0.995, 0.995, 1);
    
    const outlineGeo = new THREE.EdgesGeometry(faceGeo);
    const outlineMesh = new THREE.LineSegments(outlineGeo, outlineMat);
    outlineMesh.position.z = 0.006; outlineMesh.visible = false;
    group.userData.outline = outlineMesh;

    group.add(meshBack, meshFront, meshFiller, outlineMesh);
    
    // åˆå§‹ç¯å½¢æ’åˆ—
    const step = (Math.PI * 2) / total;
    const theta = index * step;
    group.position.set(CONFIG.radius * Math.sin(theta), 0, -CONFIG.radius * Math.cos(theta));
    group.lookAt(0, 0, 0);

    group.userData = { id: data.id, rawData: data, state: 'IDLE', theta: theta, isChosen: false };
    return group;
}

function spawnDeck() {
    deckGroup.clear(); 
    STATE.cardObjects = [];
    
    // ç”Ÿæˆå¹¶æ´—ç‰Œ
    let deckData = RWS_DATA.map(d => ({ ...d, url: `./cards/${d.id}.png` }));
    deckData.sort(() => Math.random() - 0.5);
    
    deckData.forEach((item, i) => {
        const card = createCardMesh(item, i, deckData.length);
        deckGroup.add(card);
        STATE.cardObjects.push(card);
    });
    document.getElementById('loader').style.display = 'none';
}

/**
 * --- äº¤äº’é€»è¾‘ (Touch & Mouse æ··åˆå¼•æ“) ---
 */
let interaction = {
    isDragging: false,
    startX: 0,
    startTime: 0,
    handState: 'OPEN' // 'OPEN', 'PINCH', 'FIST'
};

function initMouseListeners() {
    const canvas = document.getElementById('canvas-container');

    // é¼ æ ‡
    canvas.addEventListener('mousedown', e => onInputStart(e.clientX));
    window.addEventListener('mousemove', e => onInputMove(e.clientX, e.clientY));
    window.addEventListener('mouseup', onInputEnd);
    
    // è§¦æ‘¸
    canvas.addEventListener('touchstart', e => onInputStart(e.touches[0].clientX), {passive: false});
    window.addEventListener('touchmove', e => onInputMove(e.touches[0].clientX, e.touches[0].clientY), {passive: false});
    window.addEventListener('touchend', onInputEnd);

    // é”®ç›˜è¾…åŠ©
    window.addEventListener('keydown', e => {
        if(e.code === 'Space') { interaction.handState = 'FIST'; updateCursorIcon(); }
    });
    window.addEventListener('keyup', e => {
        if(e.code === 'Space') { interaction.handState = (STATE.activeCard ? 'PINCH' : 'OPEN'); updateCursorIcon(); }
    });
}

// ç»Ÿä¸€è¾“å…¥å¤„ç†
function onInputStart(x) {
    interaction.isDragging = false;
    interaction.startX = x;
    interaction.startTime = Date.now();
    // å¦‚æœæ²¡æœ‰æ‰‹åŠ¿ï¼Œé¼ æ ‡æŒ‰ä¸‹é»˜è®¤ä¸ºæåˆ
    if(STATE.mode === 'mouse') {
        interaction.handState = 'PINCH';
        updateCursorIcon();
    }
}

function onInputMove(x, y) {
    if (STATE.isRitualComplete) return;

    // æ›´æ–°å°„çº¿æ£€æµ‹ç”¨çš„åæ ‡
    mouse.x = (x / window.innerWidth) * 2 - 1;
    mouse.y = -(y / window.innerHeight) * 2 + 1;

    // æ‹–æ‹½æ—‹è½¬é€»è¾‘
    if (interaction.handState !== 'OPEN' || STATE.mode === 'mouse') { // åœ¨æŒ‰ä¸‹çŠ¶æ€
        // è®¡ç®—ç§»åŠ¨è·ç¦»
        const deltaX = x - interaction.startX;
        if (Math.abs(deltaX) > CONFIG.dragThreshold) {
            interaction.isDragging = true;
            // åªæœ‰åœ¨æ²¡æœ‰é€‰ä¸­å¡ç‰Œæ—¶ï¼Œæ‰å…è®¸æ—‹è½¬åœ†ç¯
            if (!STATE.activeCard) {
                STATE.targetRotation += deltaX * 0.005; // æ—‹è½¬é€Ÿåº¦
            }
            interaction.startX = x; // é‡ç½®åŸºå‡†ç‚¹
        }
    }
}

function onInputEnd() {
    const duration = Date.now() - interaction.startTime;
    
    // å¦‚æœä¸æ˜¯æ‹–æ‹½ï¼Œä¸”æ—¶é—´çŸ­ï¼Œè§†ä¸ºç‚¹å‡»/è½»è§¦
    if (!interaction.isDragging && duration < 300) {
        handleTap();
    }

    interaction.isDragging = false;
    // å¦‚æœä¸æ˜¯é”®ç›˜å¼ºåˆ¶çš„ FISTï¼Œå°±æ¢å¤ OPEN
    if (interaction.handState !== 'FIST') {
        interaction.handState = 'OPEN';
        updateCursorIcon();
    }
}

// æ ¸å¿ƒç‚¹å‡»é€»è¾‘
function handleTap() {
    if (STATE.isRitualComplete) return;

    // 1. å‘å°„å°„çº¿
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(STATE.cardObjects, true);

    let clickedCard = null;
    if (intersects.length > 0) {
        // æ‰¾åˆ°çˆ¶çº§ Group
        let obj = intersects[0].object;
        while(obj.parent && obj.parent !== deckGroup && obj.parent !== scene) {
            obj = obj.parent;
        }
        clickedCard = obj;
    }

    // 2. çŠ¶æ€æœºåˆ¤æ–­
    if (STATE.activeCard) {
        // --- åœºæ™¯ï¼šå·²ç»æœ‰ä¸€å¼ ç‰Œè¢«é€‰ä¸­äº† ---
        if (clickedCard === STATE.activeCard) {
            // ç‚¹å‡»äº†åŒä¸€å¼ ç‰Œ -> æ­ç¤º
            revealCard(STATE.activeCard);
        } else {
            // ç‚¹å‡»äº†ç©ºç™½å¤„ æˆ– å…¶ä»–ç‰Œ -> å–æ¶ˆé€‰ä¸­ (æ”¾å›)
            // å³ä½¿ç‚¹äº†å…¶ä»–ç‰Œï¼Œä¹Ÿå…ˆæ”¾å›å½“å‰ç‰Œï¼Œç¬¦åˆç›´è§‰
            returnCard(STATE.activeCard);
        }
    } else {
        // --- åœºæ™¯ï¼šå½“å‰æ²¡æœ‰é€‰ä¸­ç‰Œ ---
        if (clickedCard && clickedCard.userData.state === 'IDLE' && !clickedCard.userData.isChosen) {
            selectCard(clickedCard);
        }
    }
}

function updateCursorIcon() {
    const icon = interaction.handState==='FIST'?'âœŠ':(interaction.handState==='PINCH'?'ğŸ¤':'âœ‹');
    document.getElementById('gesture-icon').innerText = icon;
}

// --- æ¸¸æˆæµç¨‹é€»è¾‘ ---

function updateStatusText() {
    const t = TEXTS[STATE.lang];
    const el = document.getElementById('status-text');
    if (STATE.isRitualComplete) {
        el.innerText = t.statusDone; return;
    }
    
    const isMobile = window.innerWidth < 768;
    if (STATE.activeCard && STATE.activeCard.userData.state === 'SELECTED') {
        // é€‰ä¸­çŠ¶æ€
        el.innerText = isMobile ? t.statusTap : (STATE.mode === 'hand' ? t.statusFist : t.statusTap);
    } else if (STATE.activeCard && STATE.activeCard.userData.state === 'REVEALING') {
        el.innerText = t.statusReveal;
    } else {
        // é—²ç½®çŠ¶æ€
        el.innerText = isMobile ? t.statusMouse : (STATE.mode === 'hand' ? t.statusWave : t.statusMouse);
    }
}

function selectCard(card) {
    if (STATE.selectionCount >= CONFIG.maxSelection) return;
    
    STATE.activeCard = card;
    card.userData.state = 'SELECTED';
    scene.attach(card); // ä» deckGroup ç§»å‡ºï¼Œæ–¹ä¾¿ç‹¬ç«‹æ§åˆ¶
    updateStatusText();
}

function returnCard(card) {
    deckGroup.attach(card); // æ”¾å›ç»„é‡Œ
    card.userData.state = 'RETURNING';
    STATE.activeCard = null;
    updateStatusText();
}

function updateReturningCards() {
    STATE.cardObjects.forEach(card => {
        if (card.userData.state === 'RETURNING') {
            const targetPos = new THREE.Vector3(
                CONFIG.radius * Math.sin(card.userData.theta), 
                0, 
                -CONFIG.radius * Math.cos(card.userData.theta)
            );
            // æ’å€¼å¹³æ»‘å½’ä½
            card.position.lerp(targetPos, 0.1); 
            // æ—‹è½¬å½’é›¶
            const zeroQ = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, 0, 0)); // Group é»˜è®¤æ˜¯ 0
            // ç”±äºæˆ‘ä»¬åœ¨ spawnDeck é‡Œæ˜¯ç”¨ lookAt(0,0,0) è®¾ç½®æ—‹è½¬çš„ï¼Œæˆ‘ä»¬éœ€è¦é‡æ–°è®¡ç®—é‚£ä¸ªæ—‹è½¬
            const dummy = new THREE.Object3D();
            dummy.position.copy(targetPos);
            dummy.lookAt(0,0,0);
            card.quaternion.slerp(dummy.quaternion, 0.1);

            if (card.position.distanceTo(targetPos) < 0.05) {
                card.userData.state = 'IDLE';
                card.position.copy(targetPos);
                card.quaternion.copy(dummy.quaternion);
            }
        }
    });
}

function revealCard(card) {
    if (card.userData.state === 'REVEALING') return;
    card.userData.state = 'REVEALING';
    updateStatusText();
    
    const isReversed = Math.random() < 0.5;
    card.userData.isReversed = isReversed;

    // ç¿»è½¬åŠ¨ç”»
    const targetZ = isReversed ? Math.PI : 0;
    // ä½¿ç”¨ TWEEN åšç¿»è½¬
    new TWEEN.Tween(card.rotation)
        .to({ y: Math.PI, z: targetZ }, 800)
        .easing(TWEEN.Easing.Back.Out)
        .onComplete(() => {
            // ç¿»è½¬å®Œæˆåï¼Œå»¶è¿Ÿä¸€ä¼šå†æ¶ˆå¤±
            setTimeout(() => dissolve(card, isReversed), 1000);
        })
        .start();
}

function dissolve(card, isReversed) {
    spawnParticles(card.position); // ç²’å­ç‰¹æ•ˆ
    STATE.selectionCount++;
    addToHistory(card.userData.rawData, isReversed);
    
    card.visible = false;
    card.userData.isChosen = true;
    STATE.chosenCards.push(card);
    STATE.activeCard = null;
    
    if (STATE.selectionCount >= CONFIG.maxSelection) {
        startEndRitual();
    } else {
        updateStatusText();
    }
}

function startEndRitual() {
    STATE.isRitualComplete = true;
    updateStatusText();
    
    // UI æ·¡å‡º
    document.getElementById('history-container').style.opacity = 0;
    document.getElementById('hud-center').style.opacity = 0;
    
    // UI æ·¡å…¥ (é‡å¯ & åˆ¶ä½œåå•)
    setTimeout(() => {
        document.getElementById('end-ui').style.opacity = 1;
        document.getElementById('end-ui').style.pointerEvents = 'auto';
        document.getElementById('credits').style.opacity = 1;
    }, 3000);

    // æœªé€‰ä¸­çš„ç‰Œä¸‹è½
    STATE.cardObjects.forEach(c => {
        if (!c.userData.isChosen) {
            new TWEEN.Tween(c.position)
                .to({ y: -20 }, 2000)
                .delay(Math.random() * 500)
                .start();
        }
    });

    // é€‰ä¸­çš„ç‰Œé£å›å±•ç¤º
    const textContainer = document.getElementById('final-text-container');
    const t = TEXTS[STATE.lang];
    
    STATE.chosenCards.forEach((card, index) => {
        card.visible = true;
        scene.attach(card);
        
        // åˆå§‹ä½ç½®ï¼šå±å¹•ä¸Šæ–¹
        card.position.set(0, 10, -5);
        card.scale.set(0.1, 0.1, 0.1);

        // ç›®æ ‡ä½ç½®è®¡ç®— (å“åº”å¼)
        const isMobile = window.innerWidth < 768;
        const gap = isMobile ? 1.8 : 2.4; 
        const zDepth = isMobile ? -8 : -6;
        const targetX = (index - 1) * gap;

        // é£å…¥åŠ¨ç”»
        new TWEEN.Tween(card.position)
            .to({ x: targetX, y: 0, z: zDepth }, 1500)
            .easing(TWEEN.Easing.Cubic.Out)
            .delay(index * 200)
            .start();
            
        new TWEEN.Tween(card.scale)
            .to({ x: 0.8, y: 0.8, z: 0.8 }, 1500)
            .delay(index * 200)
            .start();
            
        // æ—‹è½¬ä¿®æ­£
        card.rotation.set(0, Math.PI, card.userData.isReversed ? Math.PI : 0);

        // ç”Ÿæˆæ–‡å­—
        const div = document.createElement('div');
        div.className = 'final-card-label';
        const data = card.userData.rawData[STATE.lang];
        const revText = card.userData.isReversed ? ` (${t.rev})` : "";
        div.innerHTML = `<div class="final-name">${data.name}${revText}</div><div class="final-meaning">${data.meaning}</div>`;
        textContainer.appendChild(div);
    });
    
    setTimeout(() => { textContainer.style.opacity = 1; }, 1500);
}

function addToHistory(rawData, isRev) {
    const con = document.getElementById('history-container'); 
    const slot = document.createElement('div'); 
    slot.className = `history-slot ${isRev?'is-reversed':''}`;
    // ä½¿ç”¨åŸå§‹æ•°æ®çš„ url
    slot.innerHTML = `<img src="${rawData.url}">`;
    con.appendChild(slot); 
}

// --- æ‘„åƒå¤´ (æ‰‹åŠ¿è¯†åˆ«) ---
function initCamera() {
    const videoElem = document.getElementById('video-feed');
    const hands = new Hands({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
    hands.setOptions({maxNumHands:1, modelComplexity:0, minDetectionConfidence:0.5});
    
    hands.onResults(res => {
        if(res.multiHandLandmarks && res.multiHandLandmarks.length>0) {
            const lm = res.multiHandLandmarks[0];
            // æ‰‹åŠ¿æ§åˆ¶è½¬åŠ¨
            const x = lm[8].x; // é£ŸæŒ‡å°–
            // ç®€å•çš„æ˜ å°„ï¼šå¦‚æœé£ŸæŒ‡åœ¨å±å¹•å·¦ä¾§/å³ä¾§è¾¹ç¼˜ï¼Œåˆ™æ—‹è½¬
            if (x < 0.2) STATE.targetRotation -= 0.02;
            if (x > 0.8) STATE.targetRotation += 0.02;

            const pinch = Math.hypot(lm[8].x-lm[4].x, lm[8].y-lm[4].y);
            const fist = lm[12].y>lm[9].y && lm[16].y>lm[13].y;
            interaction.handState = fist ? 'FIST' : (pinch<0.05 ? 'PINCH' : 'OPEN');
            
            // å¦‚æœæ‰‹åŠ¿è§¦å‘åŠ¨ä½œ
            if (!STATE.isRitualComplete) updateCursorIcon();
            
            // æ‰‹åŠ¿ PINCH ç­‰åŒäº ç‚¹å‡»
            if (interaction.handState === 'PINCH' && !STATE.activeCard) {
                // è¿™é‡Œå…¶å®å¾ˆéš¾ç”¨æ‰‹åŠ¿ç²¾ç¡® Raycastï¼Œé€šå¸¸ç»“åˆå‡è§†æˆ–è€…å±å¹•ä¸­å¿ƒ
                // ç®€å•èµ·è§ï¼Œæ‰‹åŠ¿æ¨¡å¼ä¸‹ï¼Œæåˆ é€‰å– å±å¹•æ­£ä¸­å¤®çš„ç‰Œ
                pickCenterCard();
            }
            if (interaction.handState === 'FIST' && STATE.activeCard) {
                revealCard(STATE.activeCard);
            }
        }
    });

    const cam = new Camera(videoElem, {
        onFrame: async()=>{ await hands.send({image:videoElem}); },
        width:320, height:240
    });
    
    // é”™è¯¯æ•è·ï¼šå¦‚æœæ‘„åƒå¤´æ‰“ä¸å¼€ï¼Œé™é»˜å¤±è´¥ï¼Œä¸å½±å“æ¸¸æˆ
    cam.start().catch(err => {
        console.warn("Camera init failed:", err);
        // å¯ä»¥åœ¨è¿™é‡Œæç¤ºç”¨æˆ·åˆ‡æ¢åˆ°è§¦æ§æ¨¡å¼ï¼Œæˆ–è€…ä»€ä¹ˆéƒ½ä¸åšç›´æ¥è¿è¡Œ
    });
}

// è¾…åŠ©æ‰‹åŠ¿é€‰å–ä¸­å¿ƒå¡ç‰Œ
function pickCenterCard() {
    let closestDist = Infinity;
    let target = null;
    STATE.cardObjects.forEach(card => {
        if (card.userData.state === 'IDLE' && !card.userData.isChosen) {
            const worldPos = new THREE.Vector3();
            card.getWorldPosition(worldPos);
            // ç®€å•çš„ä¸­å¿ƒåˆ¤æ–­
            if (worldPos.z < 0 && Math.abs(worldPos.x) < 1.0) {
                const dist = worldPos.distanceTo(camera.position);
                if (dist < closestDist) { closestDist = dist; target = card; }
            }
        }
    });
    if (target) selectCard(target);
}

// --- åŠ¨ç”»å¾ªç¯ ---
function animate() {
    requestAnimationFrame(animate);
    
    // å¹³æ»‘è½¬åŠ¨åœ†ç¯
    if (!STATE.activeCard && !STATE.isRitualComplete) {
        deckGroup.rotation.y += (STATE.targetRotation - deckGroup.rotation.y) * 0.1;
    }
    
    // æ˜Ÿç©ºè‡ªè½¬
    starSystem.rotation.y += 0.0003;

    // é€‰ä¸­å¡ç‰Œçš„æ‚¬æµ®åŠ¨ç”» (Lerp)
    if (STATE.activeCard && STATE.activeCard.userData.state === 'SELECTED') {
        const targetPos = new THREE.Vector3(0, 0, camera.position.z - 2.5);
        STATE.activeCard.position.lerp(targetPos, 0.1);
        
        // ç¼“æ…¢å¤ä½æ—‹è½¬ï¼Œé¢å‘æ‘„åƒæœº
        STATE.activeCard.lookAt(camera.position);
        // å¾®è°ƒï¼šä¿®æ­£ LookAt åçš„å€’ç½®é—®é¢˜ (å› ä¸ºæˆ‘ä»¬çš„ç‰Œæ­£é¢æ˜¯æ—‹è½¬äº† PI çš„)
        // è¿™é‡Œéœ€è¦æŠ€å·§ï¼šå› ä¸ºèƒŒé¢æœå¤–æ˜¯ IDLEï¼Œé€‰ä¸­åè¦æ­£é¢æœå±å¹•
        // ç®€å•å¤„ç†ï¼šè®©å®ƒä¿æŒç›´ç«‹
        STATE.activeCard.rotation.z = 0;
        STATE.activeCard.rotation.x = 0;
    }

    TWEEN.update(); // æ‰€æœ‰çš„ TWEEN åŠ¨ç”»æ›´æ–°
    updateReturningCards(); // æ”¾å›åŠ¨ç”»
    updateParticles(); // ç²’å­ç‰¹æ•ˆ
    
    renderer.render(scene, camera);
}

// --- çª—å£è‡ªé€‚åº” ---
function handleResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    
    // æ‰‹æœºç«–å±é€‚é…ï¼šæ‹‰è¿œæ‘„åƒæœº
    if (window.innerWidth < window.innerHeight) {
        camera.position.z = 6; 
        CONFIG.radius = 5.0; // ç¼©å°åœ†ç¯åŠå¾„é˜²æ­¢å¤ªå®½
    } else {
        camera.position.z = 0;
        CONFIG.radius = 6.5;
    }
}

// å¯åŠ¨
initMouseListeners();
window.addEventListener('resize', handleResize);
animate();

</script>
</body>
</html>
