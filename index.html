<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Arcanum: Wheel of Fate</title>
    <style>
        /* --- å…¨å±€æ ·å¼ --- */
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Times New Roman', 'Songti SC', 'SimSun', serif; 
            user-select: none; 
            -webkit-tap-highlight-color: transparent; 
        }
        #canvas-container { 
            width: 100vw; 
            height: 100vh; 
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 1; 
            cursor: grab;
        }
        #canvas-container:active {
            cursor: grabbing;
        }
        
        /* --- åˆå§‹ç•Œé¢ --- */
        #start-screen {
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            z-index: 100;
            background: radial-gradient(circle at center, rgba(0,0,0,0.4) 0%, rgba(0,0,0,0.95) 90%);
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center;
            transition: opacity 1.5s cubic-bezier(0.25, 1, 0.5, 1);
            color: #d4af37;
        }

        .title-group { 
            text-align: center; 
            margin-bottom: 5vh; 
            animation: floatTitle 6s ease-in-out infinite; 
        }
        
        h1 { 
            font-size: 72px; 
            margin: 0; 
            letter-spacing: 20px; 
            font-weight: 800;
            background: linear-gradient(135deg, #fff 0%, #d4af37 50%, #996515 100%);
            -webkit-background-clip: text; 
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 20px rgba(212, 175, 55, 0.4));
        }
        
        h2 { 
            font-size: 14px; 
            font-weight: 400; 
            letter-spacing: 8px; 
            color: #a0a0a0; 
            margin-top: 15px; 
            text-transform: uppercase; 
            border-top: 1px solid rgba(212, 175, 55, 0.3); 
            display: inline-block; 
            padding-top: 15px; 
        }

        @keyframes floatTitle {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .options-grid { 
            display: grid; 
            grid-template-columns: 1fr 1fr; 
            gap: 40px; 
            margin-bottom: 5vh; 
            text-align: center; 
            opacity: 0; 
            animation: fadeUp 1s ease-out 0.5s forwards; 
        }
        
        .choice-btn {
            background: rgba(255, 255, 255, 0.03); 
            border: 1px solid rgba(212, 175, 55, 0.3); 
            color: #888;
            padding: 12px 0; 
            width: 140px;
            font-family: inherit; 
            font-size: 12px; 
            cursor: pointer;
            transition: 0.3s;
            border-radius: 50px; 
            backdrop-filter: blur(2px);
        }
        
        .choice-btn.active { 
            border-color: #d4af37; 
            color: #fff; 
            background: rgba(212, 175, 55, 0.15); 
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.15);
        }

        #enter-btn {
            background: transparent; 
            color: #d4af37; 
            border: 1px solid #d4af37;
            padding: 15px 60px; 
            font-size: 16px; 
            letter-spacing: 8px; 
            cursor: pointer;
            border-radius: 50px; 
            transition: all 0.5s;
            opacity: 0; 
            animation: fadeUp 1s ease-out 0.8s forwards;
        }
        
        #enter-btn:hover { 
            background: #d4af37; 
            color: #000; 
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.4); 
            transform: scale(1.05); 
        }

        @keyframes fadeUp { 
            from { opacity: 0; transform: translateY(20px); } 
            to { opacity: 1; transform: translateY(0); } 
        }

        /* --- UI å±‚ --- */
        #ui-layer { 
            position: absolute; 
            top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 20; 
            pointer-events: none; 
            color: #d4af37; 
            opacity: 0; 
            transition: opacity 1.5s; 
        }
        
        /* é€‰ä¸­çº¿ - å¢å¼ºè§†è§‰æ§½ */
        #selection-line {
            position: absolute;
            top: 50%;
            left: 50%;
            height: 60%; /* é™åˆ¶é«˜åº¦ï¼Œåªè¦†ç›–ä¸­é—´åŒºåŸŸ */
            width: 2px;
            background: linear-gradient(to bottom, transparent, rgba(212, 175, 55, 0.8), transparent);
            transform: translate(-50%, -50%);
            z-index: 10;
            pointer-events: none;
            display: none; 
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.5);
        }
        /* å¢åŠ ä¸€ä¸ªæ¨ªå‘çš„æ§½ä½æŒ‡ç¤ºï¼Œå¢å¼ºâ€œå¡æ§½â€æ„Ÿ */
        #selection-line::before {
            content: ''; position: absolute; top: 0; left: -20px; right: -20px; height: 100%;
            /* border-left: 1px solid rgba(212,175,55,0.2);
            border-right: 1px solid rgba(212,175,55,0.2); */
        }

        #history-container {
            position: absolute; top: 20px; right: 20px;
            display: flex; gap: 10px;
            pointer-events: auto; z-index: 30;
        }
        .history-slot {
            width: 40px; height: 60px; 
            background: #000; border: 1px solid #d4af37; 
            border-radius: 4px; overflow: hidden;
            opacity: 0; animation: slotEnter 0.5s forwards;
        }
        .history-slot img { width: 100%; height: 100%; object-fit: cover; }
        @keyframes slotEnter { from {opacity:0; transform:translateY(-10px);} to {opacity:1; transform:translateY(0);} }

        #hud-center {
            position: absolute; bottom: 10%; left: 0; width: 100%;
            text-align: center; pointer-events: none;
            transition: opacity 0.5s;
        }
        #gesture-icon { font-size: 28px; display: block; margin-bottom: 5px; opacity: 0.8; text-shadow: 0 0 10px #d4af37;}
        #status-text { 
            font-size: 14px; letter-spacing: 3px; font-weight: bold; 
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            font-family: 'Times New Roman', serif;
        }
        #sub-status { font-size: 10px; opacity: 0.6; letter-spacing: 1px; margin-top: 5px;}

        /* æœ€ç»ˆç»“æœ */
        #final-text-container {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 80%; text-align: center; opacity: 0; pointer-events: none;
            display: flex; flex-direction: column; gap: 20px; align-items: center;
        }
        .final-card-row { display: flex; gap: 20px; justify-content: center; flex-wrap: wrap; }
        .final-card-label { color: #fff; width: 200px; text-shadow: 0 0 10px #d4af37; }
        .final-name { font-size: 18px; font-weight: bold; color: #d4af37; border-bottom: 1px solid #d4af37; padding-bottom: 5px; margin-bottom: 5px; }
        
        #end-ui {
            position: absolute; bottom: 15%; width: 100%; text-align: center;
            opacity: 0; pointer-events: none; transition: opacity 1s; z-index: 50;
        }
        #view-reading-btn {
            background: #d4af37; color: #000; border: none;
            padding: 12px 40px; font-size: 14px; letter-spacing: 3px; border-radius: 50px;
            cursor: pointer; font-weight: bold; box-shadow: 0 0 20px rgba(212, 175, 55, 0.4);
            pointer-events: auto;
        }

        #oracle-overlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 80%; max-width: 600px; text-align: center; color: #fff;
            font-size: 16px; line-height: 1.8; font-family: 'Songti SC', serif;
            text-shadow: 0 0 10px #d4af37; z-index: 60; pointer-events: none;
        }

        #video-feed { position: absolute; bottom: 10px; right: 10px; width: 80px; opacity: 0; transform: scaleX(-1); border: 1px solid #d4af37; pointer-events: none; }
        
        /* ç§»åŠ¨ç«¯è°ƒæ•´ */
        @media (max-width: 768px) {
            h1 { font-size: 40px; }
            .options-grid { grid-template-columns: 1fr; gap: 20px; }
            #hud-center { bottom: 15%; }
            #final-text-container { top: 45%; max-height: 50vh; overflow-y: auto; }
        }
    </style>
    
    <!-- èµ„æºåŠ è½½ -->
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
    <div id="start-screen">
        <div class="title-group">
            <h1>ARCANUM</h1>
            <h2>Wheel of Fate</h2>
        </div>
        <div class="options-grid">
            <div>
                <button class="choice-btn active" onclick="setLang('en')" id="btn-en">English</button>
                <button class="choice-btn" onclick="setLang('zh')" id="btn-zh">ä¸­æ–‡</button>
            </div>
            <div>
                <button class="choice-btn" onclick="setInput('hand')" id="btn-hand">Gesture âœ‹</button>
                <button class="choice-btn active" onclick="setInput('mouse')" id="btn-mouse">Touch ğŸ–±ï¸</button>
            </div>
        </div>
        <button id="enter-btn" onclick="enterExperience()">ENTER RITUAL</button>
    </div>

    <div id="ui-layer">
        <div id="selection-line"></div>
        <div id="history-container"></div>
        <div id="final-text-container"></div>
        <div id="oracle-overlay"></div>
        <div id="end-ui">
            <button id="view-reading-btn" onclick="enterStarryVoid()">REVEAL DESTINY</button>
        </div>
        <div id="hud-center">
            <span id="gesture-icon">ğŸ–±ï¸</span>
            <div id="status-text">DRAG TO SPIN</div>
            <div id="sub-status">Wait for the wheel to stop</div>
        </div>
    </div>

    <video id="video-feed" playsinline></video>
    <div id="canvas-container"></div>

<script>
// ================= é…ç½®ä¸å¸¸é‡ =================
const API_KEY = "sk-92c5cec08baf4941a5ab5a185cd9c22f"; 
const API_ENDPOINT = "https://api.deepseek.com/chat/completions"; 
const USE_PROXY = true;
const PROXY_URL = "https://corsproxy.io/?";

const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

// ================= ç‰©ç†å¼•æ“é…ç½® (Apple Picker Style) =================
const PHYSICS = {
    friction: 0.96,        // æƒ¯æ€§é˜»å°¼ (é€å¸§è¡°å‡ v *= 0.96)
    stopThreshold: 0.0008, // åœæ­¢é˜ˆå€¼ (ä½äºæ­¤é€Ÿåº¦è§¦å‘å¸é™„)
    snapDuration: 100,     // å¸é™„åŠ¨ç”»æ—¶é•¿ (æ¯«ç§’) - å¹²è„†æœ‰åŠ›
    // dragSensitivity ä¼šåœ¨ initThreeJS ä¸­åŠ¨æ€è®¡ç®—ï¼Œä»¥å®ç° 1:1 è·Ÿæ‰‹
    dragSensitivity: 0.003 
};

const TEXTS = {
    en: {
        statusDrag: "DRAG TO SPIN",
        statusWait: "SPINNING...",
        statusPick: "TAP TO SELECT",
        statusFull: "RITUAL COMPLETE",
        subDrag: "Flick to spin",
        subPick: "The wheel has stopped",
        reveal: "REVEAL DESTINY"
    },
    zh: {
        statusDrag: "æ‹–åŠ¨è½¬ç›˜",
        statusWait: "å‘½è¿æµè½¬ä¸­...",
        statusPick: "ç‚¹å‡»é€‰ä¸­",
        statusFull: "ä»ªå¼å®Œæˆ",
        subDrag: "å¿«é€Ÿæ»‘åŠ¨ä»¥æ—‹è½¬",
        subPick: "å‘½è¿ä¹‹è½®å·²é™æ­¢",
        reveal: "æ­ç¤ºå‘½è¿"
    }
};

const RWS_DATA = [
    { id: 0, en: { name: "The Fool", meaning: "New beginnings" }, zh: { name: "æ„šè€…", meaning: "æ–°çš„å¼€å§‹" } },
    { id: 1, en: { name: "The Magician", meaning: "Manifestation" }, zh: { name: "é­”æœ¯å¸ˆ", meaning: "æ˜¾åŒ–" } },
    { id: 2, en: { name: "High Priestess", meaning: "Intuition" }, zh: { name: "å¥³ç¥­å¸", meaning: "ç›´è§‰" } },
    { id: 3, en: { name: "The Empress", meaning: "Femininity" }, zh: { name: "çš‡å", meaning: "å¥³æ€§åŠ›é‡" } },
    { id: 4, en: { name: "The Emperor", meaning: "Authority" }, zh: { name: "çš‡å¸", meaning: "æƒå¨" } },
    { id: 5, en: { name: "The Hierophant", meaning: "Tradition" }, zh: { name: "æ•™çš‡", meaning: "ä¼ ç»Ÿ" } },
    { id: 6, en: { name: "The Lovers", meaning: "Choices" }, zh: { name: "æ‹äºº", meaning: "é€‰æ‹©" } },
    { id: 7, en: { name: "The Chariot", meaning: "Willpower" }, zh: { name: "æˆ˜è½¦", meaning: "æ„å¿—åŠ›" } },
    { id: 8, en: { name: "Strength", meaning: "Courage" }, zh: { name: "åŠ›é‡", meaning: "å‹‡æ°”" } },
    { id: 9, en: { name: "The Hermit", meaning: "Introspection" }, zh: { name: "éšå£«", meaning: "å†…çœ" } },
    { id: 10, en: { name: "Wheel of Fortune", meaning: "Destiny" }, zh: { name: "å‘½è¿ä¹‹è½®", meaning: "å‘½è¿" } },
    { id: 11, en: { name: "Justice", meaning: "Truth" }, zh: { name: "æ­£ä¹‰", meaning: "çœŸç†" } },
    { id: 12, en: { name: "Hanged Man", meaning: "Surrender" }, zh: { name: "å€’åŠäºº", meaning: "è‡£æœ" } },
    { id: 13, en: { name: "Death", meaning: "Transformation" }, zh: { name: "æ­»ç¥", meaning: "è½¬åŒ–" } },
    { id: 14, en: { name: "Temperance", meaning: "Balance" }, zh: { name: "èŠ‚åˆ¶", meaning: "å¹³è¡¡" } },
    { id: 15, en: { name: "The Devil", meaning: "Addiction" }, zh: { name: "æ¶é­”", meaning: "æŸç¼š" } },
    { id: 16, en: { name: "The Tower", meaning: "Upheaval" }, zh: { name: "é«˜å¡”", meaning: "å‰§å˜" } },
    { id: 17, en: { name: "The Star", meaning: "Hope" }, zh: { name: "æ˜Ÿæ˜Ÿ", meaning: "å¸Œæœ›" } },
    { id: 18, en: { name: "The Moon", meaning: "Illusion" }, zh: { name: "æœˆäº®", meaning: "å¹»è§‰" } },
    { id: 19, en: { name: "The Sun", meaning: "Positivity" }, zh: { name: "å¤ªé˜³", meaning: "å¿«ä¹" } },
    { id: 20, en: { name: "Judgement", meaning: "Rebirth" }, zh: { name: "å®¡åˆ¤", meaning: "é‡ç”Ÿ" } },
    { id: 21, en: { name: "The World", meaning: "Completion" }, zh: { name: "ä¸–ç•Œ", meaning: "åœ†æ»¡" } }
];

let currentLang = 'en';
let controlMode = 'mouse';
let isStarted = false;
let deckList = [];
let chosenCards = [];
const MAX_SELECTION = 3;

// ================= THREE.JS æ ¸å¿ƒå˜é‡ =================
const RADIUS = 9; 
const CARD_W = 1.5;
const CARD_H = 2.58;

let scene, camera, renderer, deckGroup;
let cardObjects = [];

// ================= æ»šè½®ç‰©ç†å¼•æ“çŠ¶æ€æœº =================
const WheelState = {
    IDLE: 0,       // å®Œå…¨é™æ­¢ (å·²å¸é™„ï¼Œç­‰å¾…é€‰æ‹©)
    DRAGGING: 1,   // æ‰‹æŒ‡æ‹–åŠ¨ä¸­ (1:1 è·Ÿæ‰‹)
    INERTIA: 2,    // æƒ¯æ€§æ»šåŠ¨ä¸­ (è‡ªç”±è¡°å‡)
    SNAPPING: 3,   // å¼ºåˆ¶å¸é™„å¯¹é½ä¸­ (åŠ¨ç”»)
    LOCKED: 4      // ä»ªå¼ç»“æŸé”å®š
};

let wheel = {
    state: WheelState.IDLE,
    rotation: 0,           // å½“å‰å®é™…æ—‹è½¬è§’åº¦ (å¼§åº¦)
    velocity: 0,           // å½“å‰è§’é€Ÿåº¦
    lastInputX: 0,         // ä¸Šä¸€å¸§çš„è¾“å…¥åæ ‡
    lastInputTime: 0,      // ä¸Šä¸€å¸§çš„æ—¶é—´ (è®¡ç®—é€Ÿåº¦ç”¨)
    snapTarget: 0,         // å¸é™„ç›®æ ‡è§’åº¦
    snapStartTime: 0,      // å¸é™„å¼€å§‹æ—¶é—´
    snapStartRotation: 0,  // å¸é™„å¼€å§‹æ—¶çš„è§’åº¦
    stepAngle: (Math.PI * 2) / 22, // æ¯å¼ å¡ç‰Œçš„è§’åº¦é—´éš”
    activeCardIndex: -1    // å½“å‰æ­£å¯¹ä¸­é—´çš„å¡ç‰Œç´¢å¼•
};

// ================= åˆå§‹åŒ– =================
window.onload = () => {
    setLang('en');
    setInput(isMobile ? 'mouse' : 'mouse'); 
};

function setLang(l) { 
    currentLang = l; 
    document.querySelectorAll('[onclick^="setLang"]').forEach(b=>b.classList.remove('active'));
    document.getElementById(`btn-${l}`).classList.add('active');
}
function setInput(m) { 
    controlMode = m;
    document.querySelectorAll('[onclick^="setInput"]').forEach(b=>b.classList.remove('active'));
    document.getElementById(`btn-${m}`).classList.add('active');
}

function enterExperience() {
    isStarted = true;
    document.getElementById('start-screen').style.opacity = 0;
    setTimeout(() => document.getElementById('start-screen').style.display = 'none', 1500);
    document.getElementById('ui-layer').style.opacity = 1;
    document.getElementById('selection-line').style.display = 'block';
    
    initThreeJS();
    initInputs();
    updateHUD();
    
    if(controlMode === 'hand') {
        document.getElementById('video-feed').style.opacity = 0.3;
        initHandTracking();
    }
}

// ================= THREE.JS åœºæ™¯æ„å»º =================
function initThreeJS() {
    const container = document.getElementById('canvas-container');
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    scene.fog = new THREE.FogExp2(0x000000, 0.02);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
    updateCameraLayout();

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    const ambient = new THREE.AmbientLight(0xffffff, 0.2);
    scene.add(ambient);
    
    // ä¾§é¢è¡¥å…‰ï¼Œè®©ä¾§é¢ä¸è‡³äºæ­»é»‘
    const sideLight = new THREE.DirectionalLight(0xffaa00, 0.5);
    sideLight.position.set(10, 0, 5);
    scene.add(sideLight);
    const sideLight2 = new THREE.DirectionalLight(0xffaa00, 0.5);
    sideLight2.position.set(-10, 0, 5);
    scene.add(sideLight2);

    createStars();
    
    deckGroup = new THREE.Group();
    scene.add(deckGroup);
    spawnDeck();
}

function createStars() {
    const geo = new THREE.BufferGeometry();
    const pos = [];
    for(let i=0; i<3000; i++) {
        const x = (Math.random()-0.5)*100;
        const y = (Math.random()-0.5)*100;
        const z = (Math.random()-0.5)*100;
        pos.push(x,y,z);
    }
    geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
    const mat = new THREE.PointsMaterial({color: 0x888888, size: 0.05});
    scene.add(new THREE.Points(geo, mat));
}

function spawnDeck() {
    const texLoader = new THREE.TextureLoader();
    const backTex = texLoader.load('./cards/back.png');
    
    const shape = new THREE.Shape();
    const w = CARD_W/2, h = CARD_H/2, r = 0.08;
    shape.absarc(w-r, h-r, r, 0, Math.PI/2, false);
    shape.absarc(-w+r, h-r, r, Math.PI/2, Math.PI, false);
    shape.absarc(-w+r, -h+r, r, Math.PI, Math.PI*3/2, false);
    shape.absarc(w-r, -h+r, r, Math.PI*3/2, Math.PI*2, false);
    const geo = new THREE.ShapeGeometry(shape);
    
    const posAttr = geo.attributes.position;
    const uvAttr = geo.attributes.uv;
    for(let i=0; i<posAttr.count; i++){
        const x = posAttr.getX(i);
        const y = posAttr.getY(i);
        uvAttr.setXY(i, (x/CARD_W)+0.5, (y/CARD_H)+0.5);
    }

    deckList = RWS_DATA.map(d => ({...d, url: `./cards/${d.id}.png`}));
    deckList.sort(() => Math.random() - 0.5);

    deckList.forEach((data, i) => {
        const grp = new THREE.Group();
        const frontTex = texLoader.load(data.url);
        
        // Emissive ç”¨äºé«˜äº®æ§åˆ¶
        const matFront = new THREE.MeshStandardMaterial({ map: frontTex, roughness: 0.4, emissive: 0x000000 });
        const matBack = new THREE.MeshStandardMaterial({ map: backTex, roughness: 0.5 });
        const matEdge = new THREE.MeshBasicMaterial({ color: 0x333333 });

        const mFront = new THREE.Mesh(geo, matFront);
        mFront.position.z = -0.01;
        mFront.rotation.y = Math.PI; 
        
        const mBack = new THREE.Mesh(geo, matBack);
        mBack.position.z = 0.01;
        
        const mEdge = new THREE.Mesh(geo, matEdge);
        mEdge.scale.set(1.02, 1.02, 1);
        mEdge.position.z = -0.005;

        grp.add(mFront, mBack, mEdge);

        // ç¯å½¢å¸ƒå±€
        const angle = i * wheel.stepAngle;
        grp.position.set(Math.sin(angle)*RADIUS, 0, -Math.cos(angle)*RADIUS);
        grp.rotation.y = -angle; 

        grp.userData = { id: i, data: data, originalAngle: angle };
        deckGroup.add(grp);
        cardObjects.push(grp);
    });
}

// ================= ç‰©ç†å¼•æ“é€»è¾‘ (Revised Apple Picker Style) =================

function initInputs() {
    const el = document.getElementById('canvas-container');

    const onStart = (x) => {
        if(wheel.state === WheelState.LOCKED) return;
        wheel.state = WheelState.DRAGGING;
        wheel.lastInputX = x;
        wheel.lastInputTime = Date.now();
        wheel.velocity = 0; 
    };

    const onMove = (x) => {
        if(wheel.state !== WheelState.DRAGGING) return;
        
        const now = Date.now();
        const dt = now - wheel.lastInputTime;
        const dx = x - wheel.lastInputX;
        
        // 1:1 è·Ÿæ‰‹ç§»åŠ¨: ä½¿ç”¨åŠ¨æ€è®¡ç®—çš„ sensitivity
        const dRotation = dx * PHYSICS.dragSensitivity; 
        wheel.rotation += dRotation; 
        
        // è®¡ç®—ç¬æ—¶é€Ÿåº¦ (ç”¨äºæ¾æ‰‹æ—¶çš„æƒ¯æ€§)
        if (dt > 0) {
            // å¹³æ»‘é€Ÿåº¦è®¡ç®— (é¿å…æŠ–åŠ¨å¯¼è‡´é€Ÿåº¦æå€¼)
            const instVel = dRotation; 
            wheel.velocity = (wheel.velocity * 0.5) + (instVel * 0.5); 
        }

        wheel.lastInputX = x;
        wheel.lastInputTime = now;
    };

    const onEnd = () => {
        if(wheel.state === WheelState.DRAGGING) {
            // å¦‚æœæ‰‹æŒ‡åœæ­¢è¶…è¿‡ 60ms æ‰æ¾å¼€ï¼Œè§†ä¸ºåœæ­¢è€Œéç”©åŠ¨
            const timeSinceLastMove = Date.now() - wheel.lastInputTime;
            if (timeSinceLastMove > 60) {
                wheel.velocity = 0;
            }
            wheel.state = WheelState.INERTIA;
        }
    };

    el.addEventListener('mousedown', e => onStart(e.clientX));
    window.addEventListener('mousemove', e => onMove(e.clientX));
    window.addEventListener('mouseup', onEnd);

    el.addEventListener('touchstart', e => onStart(e.touches[0].clientX), {passive: false});
    window.addEventListener('touchmove', e => { e.preventDefault(); onMove(e.touches[0].clientX); }, {passive: false});
    window.addEventListener('touchend', onEnd);
    
    el.addEventListener('click', handleCardSelection);
}

function updatePhysics() {
    if (wheel.state === WheelState.LOCKED) return;

    // --- æƒ¯æ€§é˜¶æ®µ (Inertia) ---
    // é€»è¾‘: è‡ªç”±æ»šåŠ¨ -> å‡é€Ÿ -> ä½äºé˜ˆå€¼ -> è§¦å‘å¸é™„
    if (wheel.state === WheelState.INERTIA) {
        wheel.rotation += wheel.velocity;
        wheel.velocity *= PHYSICS.friction; // é€Ÿåº¦è¡°å‡

        // å½“é€Ÿåº¦æä½æ—¶ï¼Œè§¦å‘å¸é™„ (é˜ˆå€¼éå¸¸å°ï¼Œç¡®ä¿æ˜¯â€œå¿«åœä¸‹äº†â€æ‰å¸é™„)
        if (Math.abs(wheel.velocity) < PHYSICS.stopThreshold) {
            startSnapping();
        }
    }

    // --- å¸é™„é˜¶æ®µ (Hard Snap) ---
    // é€»è¾‘: å¼ºåˆ¶å¯¹é½åˆ°æœ€è¿‘çš„æ§½ä½ï¼Œæ›²çº¿ä¸º easeOutQuart (å¹²è„†æœ‰åŠ›)
    if (wheel.state === WheelState.SNAPPING) {
        const now = Date.now();
        const progress = Math.min((now - wheel.snapStartTime) / PHYSICS.snapDuration, 1);
        
        // Quartic Ease-Out: æå¿«å½’ä½ï¼Œæ— å›å¼¹
        const ease = 1 - Math.pow(1 - progress, 4);
        
        wheel.rotation = wheel.snapStartRotation + (wheel.snapTarget - wheel.snapStartRotation) * ease;

        if (progress >= 1) {
            wheel.state = WheelState.IDLE;
            wheel.rotation = wheel.snapTarget; // ä¿®æ­£å¾®å°è¯¯å·®
            updateHUD(); 
        }
    }

    // åº”ç”¨æ—‹è½¬
    deckGroup.rotation.y = wheel.rotation;

    // --- è§†è§‰é«˜äº®è®¡ç®— (èšç„¦æ§½) ---
    updateVisualHighlights();
}

function updateVisualHighlights() {
    // å½’ä¸€åŒ–å½“å‰çš„ group rotation åˆ°ç´¢å¼•
    const rawIndex = -wheel.rotation / wheel.stepAngle;
    
    // å¤„ç†å¾ªç¯ç´¢å¼•
    let normalizedIndex = Math.round(rawIndex) % 22;
    if (normalizedIndex < 0) normalizedIndex += 22;
    
    wheel.activeCardIndex = normalizedIndex;

    // æ›´æ–°æ¯å¼ ç‰Œçš„äº®åº¦
    cardObjects.forEach((grp, i) => {
        // è®¡ç®—è¿™å¼ ç‰Œè·ç¦»ä¸­å¿ƒçš„â€œè§’åº¦å·®â€
        let worldAngle = (i * wheel.stepAngle) + wheel.rotation;
        
        // å½’ä¸€åŒ–åˆ° -PI ~ PI
        while (worldAngle > Math.PI) worldAngle -= Math.PI*2;
        while (worldAngle < -Math.PI) worldAngle += Math.PI*2;
        
        // è·ç¦»ä¸­å¿ƒçš„å¼§åº¦è·ç¦»
        const distRad = Math.abs(worldAngle);
        
        // é«˜äº®å› å­: 
        // ä¹‹å‰æ˜¯ exp(-x^2 * 6.5) -> æ¯”è¾ƒå®½
        // ç°åœ¨æ”¹æˆ exp(-x^2 * 50) -> éå¸¸çª„ï¼Œåªæœ‰æ­£å¯¹æ—¶æ‰äº®ï¼Œç¨å¾®åä¸€ç‚¹å°±æš—
        // è¿™æ¨¡æ‹Ÿäº†â€œæ§½ä½â€çš„å…‰å­¦æ•ˆæœ
        const highlight = Math.exp(-Math.pow(distRad, 2) * 80); 
        
        const mesh = grp.children[0]; // Front face
        if (mesh && mesh.material) {
            // Emissive: 0x000000 -> 0x888888 (éå¸¸äº®)
            const val = Math.floor(highlight * 160); 
            mesh.material.emissive.setRGB(val/255, val/255, val/255);
            
            // é€‰ä¸­æ—¶æ”¾å¤§ (1.0 -> 1.1)
            const scale = 1 + (highlight * 0.1);
            grp.scale.setScalar(scale);
        }
    });
}

function startSnapping() {
    wheel.state = WheelState.SNAPPING;
    
    // æ‰¾æœ€è¿‘çš„æ•´æ•°åˆ»åº¦
    const currentStep = wheel.rotation / wheel.stepAngle;
    const targetStep = Math.round(currentStep);
    
    wheel.snapTarget = targetStep * wheel.stepAngle;
    wheel.snapStartRotation = wheel.rotation;
    wheel.snapStartTime = Date.now();
    
    // å¦‚æœå·²ç»åœ¨ä½ç½®ä¸Š (è¯¯å·®æå°)ï¼Œç›´æ¥è·³è¿‡
    if (Math.abs(wheel.snapTarget - wheel.rotation) < 0.0001) {
        wheel.rotation = wheel.snapTarget;
        wheel.state = WheelState.IDLE;
        updateHUD();
    }
}

// ================= äº¤äº’ä¸æµç¨‹ =================

function handleCardSelection() {
    // åªæœ‰åœ¨ IDLE çŠ¶æ€ä¸‹ç‚¹å‡»æ‰æœ‰æ•ˆ
    if (wheel.state !== WheelState.IDLE) return;
    if (chosenCards.length >= MAX_SELECTION) return;

    const idx = wheel.activeCardIndex;
    if (idx === -1) return;
    
    const cardGroup = cardObjects[idx];
    if (!cardGroup.visible) return; 

    selectCard(cardGroup, idx);
}

function selectCard(cardGroup, index) {
    cardGroup.visible = false;
    
    const data = cardGroup.userData.data;
    const isReversed = Math.random() < 0.5; 
    chosenCards.push({ ...data, isReversed });
    
    addHistoryItem(data.url, isReversed);
    spawnSparkles();

    if (chosenCards.length >= MAX_SELECTION) {
        wheel.state = WheelState.LOCKED;
        finishRitual();
    }
}

function updateHUD() {
    const t = TEXTS[currentLang];
    const elMain = document.getElementById('status-text');
    const elSub = document.getElementById('sub-status');

    if (chosenCards.length >= MAX_SELECTION) {
        elMain.innerText = t.statusFull;
        elSub.innerText = "";
        return;
    }

    if (wheel.state === WheelState.IDLE) {
        elMain.innerText = t.statusPick;
        if (wheel.activeCardIndex !== -1 && cardObjects[wheel.activeCardIndex].visible) {
             const name = cardObjects[wheel.activeCardIndex].userData.data[currentLang].name;
             elMain.innerText = name.toUpperCase();
        }
        elSub.innerText = t.subPick;
    } else {
        elMain.innerText = wheel.state === WheelState.DRAGGING ? "" : t.statusWait; // æ‹–åŠ¨æ—¶ä¸æ˜¾ç¤ºæ–‡å­—
        elSub.innerText = t.subDrag;
    }
}

function addHistoryItem(url, isRev) {
    const div = document.createElement('div');
    div.className = 'history-slot';
    div.innerHTML = `<img src="${url}" style="${isRev ? 'transform:rotate(180deg)' : ''}">`;
    document.getElementById('history-container').appendChild(div);
}

function spawnSparkles() {
    for(let i=0; i<10; i++) {
        const p = document.createElement('div');
        p.style.position = 'absolute';
        p.style.left = '50%'; p.style.top = '50%';
        p.style.width = '4px'; p.style.height = '4px';
        p.style.background = '#d4af37';
        p.style.borderRadius = '50%';
        p.style.pointerEvents = 'none';
        p.style.transition = 'all 0.8s ease-out';
        p.style.zIndex = '100';
        document.body.appendChild(p);
        
        setTimeout(()=>{
            const angle = Math.random()*Math.PI*2;
            const dist = 50 + Math.random()*100;
            p.style.transform = `translate(${Math.cos(angle)*dist}px, ${Math.sin(angle)*dist}px) scale(0)`;
            p.style.opacity = 0;
        }, 10);
        setTimeout(()=>p.remove(), 800);
    }
}

function finishRitual() {
    document.getElementById('hud-center').style.opacity = 0;
    document.getElementById('selection-line').style.opacity = 0;
    
    const container = document.getElementById('final-text-container');
    container.style.opacity = 1;
    container.innerHTML = `<div class="final-card-row"></div>`;
    const row = container.querySelector('.final-card-row');
    
    chosenCards.forEach(c => {
        const div = document.createElement('div');
        div.className = 'final-card-label';
        const name = c[currentLang].name + (c.isReversed ? (currentLang==='zh'?" (é€†ä½)":" (Rev.)") : "");
        div.innerHTML = `<div class="final-name">${name}</div><div>${c[currentLang].meaning}</div>`;
        row.appendChild(div);
    });

    document.getElementById('end-ui').style.opacity = 1;
}

// ================= æ‰‹åŠ¿æ§åˆ¶ (å¢åŠ ä½é€šæ»¤æ³¢) =================
let handPinching = false;
// æ»¤æ³¢å™¨å˜é‡
let filteredHandX = 0; 

function initHandTracking() {
    const videoElem = document.getElementById('video-feed');
    const hands = new Hands({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
    hands.setOptions({maxNumHands:1, modelComplexity:0, minDetectionConfidence:0.5});
    
    hands.onResults(res => {
        if(!isStarted || chosenCards.length >= MAX_SELECTION) return;

        if(res.multiHandLandmarks && res.multiHandLandmarks.length>0) {
            const lm = res.multiHandLandmarks[0];
            const rawX = (1 - lm[8].x) * window.innerWidth;
            
            // ä½é€šæ»¤æ³¢ï¼šå¹³æ»‘æ‰‹åŠ¿åæ ‡ (0.3 æ–°å€¼, 0.7 æ—§å€¼)
            // é˜²æ­¢æ‰‹åŠ¿æŠ–åŠ¨é€ æˆç‰©ç†å¼•æ“ä¸ç¨³
            if (filteredHandX === 0) filteredHandX = rawX;
            filteredHandX = filteredHandX * 0.7 + rawX * 0.3;

            const dist = Math.hypot(lm[8].x-lm[4].x, lm[8].y-lm[4].y);
            const isPinch = dist < 0.05;
            
            // çŠ¶æ€æ˜ å°„: æ‰‹åŠ¿ Pinch -> ç‰©ç† Dragging
            if (isPinch) {
                if (!handPinching) {
                    // Start Drag
                    if(wheel.state !== WheelState.LOCKED) {
                        wheel.state = WheelState.DRAGGING;
                        wheel.lastInputX = filteredHandX;
                        wheel.lastInputTime = Date.now();
                        wheel.velocity = 0;
                        handPinching = true;
                    }
                } else {
                    // Continue Drag
                    if(wheel.state === WheelState.DRAGGING) {
                        const now = Date.now();
                        const dx = filteredHandX - wheel.lastInputX;
                        const dRotation = dx * PHYSICS.dragSensitivity;
                        wheel.rotation += dRotation;
                        
                        // è®¡ç®—é€Ÿåº¦
                        if ((now - wheel.lastInputTime) > 0) {
                            wheel.velocity = (wheel.velocity * 0.5) + (dRotation * 0.5); 
                        }
                        wheel.lastInputX = filteredHandX;
                        wheel.lastInputTime = now;
                    }
                }
            } else {
                if (handPinching) {
                    // End Drag
                    if(wheel.state === WheelState.DRAGGING) {
                        wheel.state = WheelState.INERTIA;
                    }
                    handPinching = false;
                }
                
                // å¦‚æœæ˜¯ IDLE ä¸”ç¨³å®šï¼Œå°è¯•æ£€æµ‹ç‚¹å‡»åŠ¨ä½œ (ç•¥å¤æ‚ï¼Œæš‚æ—¶ç®€åŒ–ä¸ºIDLEæ—¶è‡ªåŠ¨é€‰ä¸­ä¹Ÿè¡Œï¼Œä½†è¿™é‡Œä¿æŒç‚¹å‡»é€»è¾‘)
                // ä¸ºäº†æ‰‹åŠ¿ä½“éªŒï¼Œå¦‚æœå®Œå…¨é™æ­¢ä¸”æ˜¯æåˆæ¾å¼€ç¬é—´ï¼Œå¯ä»¥è§†ä¸ºé€‰ä¸­ã€‚
                // ä½†ç›®å‰çš„é€»è¾‘æ˜¯ "ç‚¹å‡»" = selectã€‚æ‰‹åŠ¿æ¨¡å¼ä¸‹ï¼Œå¯èƒ½éœ€è¦é¢å¤–çš„è§¦å‘æ–¹å¼ã€‚
                // è¿™é‡Œä¿ç•™: æ‰‹åŠ¿è´Ÿè´£è½¬åŠ¨ï¼Œç¡®è®¤éœ€è¦ç‚¹å‡»å±å¹•æˆ–é•¿æ—¶é—´æ‚¬åœ(æœªå®ç°)ã€‚
                // ç°ç»´æŒ: è½¬åŠ¨ -> åœä¸‹ -> ç‚¹å‡»å±å¹•(Touch)é€‰ä¸­ã€‚
            }
            document.getElementById('gesture-icon').innerText = isPinch ? "âœŠ" : "âœ‹";
        }
    });
    
    const cam = new Camera(videoElem, {onFrame: async()=>{await hands.send({image:videoElem})}, width:320, height:240});
    cam.start();
}

function animate() {
    requestAnimationFrame(animate);
    updatePhysics();
    renderer.render(scene, camera);
}
animate();

// åŠ¨æ€è®¡ç®— Sensitivity ä»¥å®ç° 1:1 è·Ÿæ‰‹
function updateCameraLayout() {
    const isPortrait = window.innerHeight > window.innerWidth;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    
    // è°ƒæ•´ç›¸æœºè·ç¦»
    const camZ = isPortrait ? 16 : 11;
    camera.position.z = camZ;
    camera.position.y = isPortrait ? 2 : 0;

    // è®¡ç®— Sensitivity:
    // ç›®æ ‡: å±å¹•ç§»åŠ¨ 1px = 3Dä¸–ç•Œä¸­å¡ç‰‡ç§»åŠ¨ 1px çš„è§†è§‰è·ç¦»
    // 1. è®¡ç®—ç›¸æœºè§†è§’ä¸‹çš„å¯è§†é«˜åº¦ (Visible Height at z=0)
    //    vH = 2 * dist * tan(fov/2)
    const dist = camZ; // å‡è®¾å¡ç‰‡åœ¨ z=0
    const vH = 2 * dist * Math.tan((camera.fov * Math.PI / 180) / 2);
    
    // 2. ç®—å‡º 1 å±å¹•åƒç´ å¯¹åº”å¤šå°‘ 3D å•å…ƒ
    const unitsPerPixel = vH / window.innerHeight;
    
    // 3. ç®—å‡º 1 3Då•å…ƒå¯¹åº”çš„æ—‹è½¬å¼§åº¦ (å¼§é•¿å…¬å¼ L = r * theta => theta = L / r)
    //    Rotation = units / RADIUS
    //    Sensitivity = unitsPerPixel / RADIUS
    PHYSICS.dragSensitivity = unitsPerPixel / RADIUS;
}

window.addEventListener('resize', () => {
    updateCameraLayout();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

async function enterStarryVoid() {
    document.getElementById('view-reading-btn').style.display = 'none';
    const overlay = document.getElementById('oracle-overlay');
    overlay.innerText = TEXTS[currentLang].statusWait;

    const cardsText = chosenCards.map(c => 
        `${c[currentLang].name} (${c.isReversed ? 'Reversed' : 'Upright'})`
    ).join(', ');

    const prompt = currentLang === 'zh' 
        ? `ç”¨å¡”ç½—ç‰Œè§£è¯»ï¼š${cardsText}ã€‚100å­—ä»¥å†…ï¼Œç¥ç§˜é£æ ¼ã€‚` 
        : `Interpret tarot spread: ${cardsText}. Under 100 words, mystical style.`;

    try {
        let url = API_ENDPOINT;
        if(USE_PROXY) url = PROXY_URL + encodeURIComponent(API_ENDPOINT);
        
        const res = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${API_KEY}` },
            body: JSON.stringify({ model: "deepseek-chat", messages: [{role:"user", content: prompt}] })
        });
        const data = await res.json();
        const text = data.choices[0].message.content;
        
        let i = 0;
        overlay.innerHTML = "";
        const timer = setInterval(() => {
            overlay.textContent += text.charAt(i);
            i++;
            if(i >= text.length) clearInterval(timer);
        }, 50);
        
    } catch(e) {
        overlay.innerText = currentLang==='zh' ? "æ˜Ÿè¾°é™é»˜..." : "The stars are silent...";
    }
}
</script>
</body>
</html>
