<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Arcanum: Final Ritual</title>
    <style>
        /* --- ÂÖ®Â±ÄÊ†∑Âºè (Global Styles) --- */
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Cinzel', 'Noto Serif SC', serif; 
            user-select: none; 
            -webkit-tap-highlight-color: transparent;
        }
        #canvas-container { 
            width: 100vw; 
            height: 100vh; 
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 1; 
        }
        
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;800&family=Noto+Serif+SC:wght@300;500&display=swap');

        /* --- ÂàùÂßãÁïåÈù¢ (Start Screen) --- */
        #start-screen {
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            z-index: 100;
            background: radial-gradient(circle at center, rgba(0,0,0,0.4) 0%, rgba(0,0,0,0.95) 90%);
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center;
            transition: opacity 1.5s cubic-bezier(0.25, 1, 0.5, 1);
            color: #d4af37;
            padding: 20px;
            box-sizing: border-box;
        }

        .title-group { 
            text-align: center; 
            margin-bottom: 5vh; 
            position: relative;
            animation: floatTitle 6s ease-in-out infinite; 
        }
        
        h1 { 
            font-size: 72px; 
            margin: 0; 
            letter-spacing: 20px; 
            font-weight: 800;
            background: linear-gradient(135deg, #fff 0%, #d4af37 50%, #996515 100%);
            -webkit-background-clip: text; 
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 20px rgba(212, 175, 55, 0.4));
        }
        
        h2 { 
            font-size: 14px; 
            font-weight: 400; 
            letter-spacing: 8px; 
            color: #a0a0a0; 
            margin-top: 15px; 
            text-transform: uppercase; 
            opacity: 0.8;
            border-top: 1px solid rgba(212, 175, 55, 0.3); 
            display: inline-block; 
            padding-top: 15px; 
            width: 120%; 
            margin-left: -10%;
        }

        @keyframes floatTitle {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .options-grid { 
            display: grid; 
            grid-template-columns: 1fr 1fr; 
            gap: 60px; 
            margin-bottom: 5vh; 
            text-align: center; 
            opacity: 0; 
            animation: fadeUp 1s ease-out 0.5s forwards; 
        }
        .option-group { 
            display: flex; 
            flex-direction: column; 
            gap: 20px; 
            align-items: center; 
        }
        .option-label { 
            font-size: 11px; 
            letter-spacing: 3px; 
            color: #666; 
            text-transform: uppercase; 
            margin-bottom: 5px; 
            font-weight: 600;
        }

        .choice-btn {
            background: rgba(255, 255, 255, 0.03); 
            border: 1px solid rgba(212, 175, 55, 0.3); 
            color: #888;
            padding: 12px 0; 
            width: 160px;
            font-family: inherit; 
            font-size: 12px; 
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
            border-radius: 50px; 
            position: relative; 
            overflow: hidden;
            backdrop-filter: blur(2px);
        }
        
        .choice-btn.active { 
            border-color: #d4af37; 
            color: #fff; 
            background: rgba(212, 175, 55, 0.15); 
            box-shadow: 0 0 25px rgba(212, 175, 55, 0.15);
        }
        
        .choice-btn:hover { 
            border-color: #fff; 
            color: #fff; 
            transform: translateY(-2px); 
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }

        #enter-btn {
            background: transparent; 
            color: #d4af37; 
            border: 1px solid #d4af37;
            padding: 18px 80px; 
            font-size: 16px; 
            letter-spacing: 8px; 
            cursor: pointer;
            font-family: inherit; 
            font-weight: 600; 
            border-radius: 50px; 
            transition: all 0.5s;
            position: relative; 
            overflow: hidden;
            opacity: 0; 
            animation: fadeUp 1s ease-out 0.8s forwards;
        }
        
        #enter-btn:hover { 
            background: #d4af37; 
            color: #000; 
            box-shadow: 0 0 40px rgba(212, 175, 55, 0.4); 
            transform: scale(1.05); 
            letter-spacing: 10px;
        }

        @keyframes fadeUp { 
            from { opacity: 0; transform: translateY(20px); } 
            to { opacity: 1; transform: translateY(0); } 
        }

        .sparkle {
            position: absolute; 
            background: white; 
            border-radius: 50%;
            pointer-events: none; 
            opacity: 0;
            box-shadow: 0 0 10px #d4af37, 0 0 20px #d4af37;
            animation: sparkleFloat linear forwards;
        }
        @keyframes sparkleFloat {
            0% { opacity: 0; transform: translateY(0) scale(0); }
            50% { opacity: 1; transform: translateY(-50px) scale(1); }
            100% { opacity: 0; transform: translateY(-100px) scale(0); }
        }

        /* --- Ê∏∏ÊàèÂÜÖ UI Â±Ç --- */
        #ui-layer { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: 20; 
            pointer-events: none; 
            color: #d4af37; 
            opacity: 0; 
            transition: opacity 1.5s; 
        }
        
        #history-container {
            position: absolute; 
            top: 20px; 
            right: 20px;
            display: flex; 
            flex-direction: row; 
            gap: 15px;
            pointer-events: auto; 
            z-index: 30; 
            height: 100px; 
            align-items: flex-start;
            transition: opacity 1s ease;
        }
        .history-slot {
            width: 50px; 
            height: 85px; 
            background: #fff; 
            border: 2px solid #d4af37; 
            border-radius: 8px; 
            overflow: hidden;
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: flex-end;
            box-shadow: 0 4px 15px rgba(0,0,0,0.8); 
            flex-shrink: 0; 
            position: relative;
            animation: slotEnter 0.6s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        @keyframes slotEnter { from { opacity:0; transform: translateY(-20px); } to { opacity:1; transform: translateY(0); } }
        .history-slot img { position: absolute; top:0; left:0; width: 100%; height: 100%; object-fit: cover; }
        .history-info { position: relative; z-index: 2; width: 100%; background: rgba(0,0,0,0.8); text-align: center; padding: 2px 0; border-top: 1px solid #d4af37; }
        .history-name { font-size: 8px; color: #d4af37; font-weight: 700; white-space: nowrap; transform: scale(0.9); }
        .history-rev { font-size: 7px; color: #ff3333; display: none; font-weight: bold; background: rgba(0,0,0,0.5); width:100%; }
        .is-reversed img { transform: rotate(180deg); }
        .is-reversed .history-rev { display: block; }

        #hud-center {
            position: absolute; 
            bottom: 8%; 
            left: 50%; 
            transform: translateX(-50%);
            text-align: center; 
            color: #d4af37; 
            pointer-events: none;
            width: 100%; 
            transition: opacity 1s;
        }
        #gesture-icon { font-size: 32px; display: block; margin-bottom: 10px; opacity: 0.9; text-shadow: 0 0 15px #d4af37;}
        #status-text { font-size: 11px; letter-spacing: 4px; text-transform: uppercase; font-weight: 600; opacity: 0.8; }

        /* --- ÊúÄÁªàÁªìÊûúÊñáÂ≠óÂÆπÂô® (ÂÖ≥ÈîÆË∞ÉÊï¥) --- */
        #final-text-container {
            position: absolute; 
            /* ÁßªÂä®Á´ØË∞ÉÊï¥Ôºö‰ªé65%‰∏äÁßªÂà∞50%Â∑¶Âè≥ÔºåÈÅøÂÖçÊñáÂ≠óÂ§™Èù†‰∏ã */
            top: 52%; 
            left: 0; 
            width: 100%;
            text-align: center; 
            opacity: 0; 
            transition: opacity 2s;
            pointer-events: none; 
            display: flex; 
            justify-content: center; 
            gap: 40px; 
            flex-wrap: wrap; 
            padding: 0 20px;
            box-sizing: border-box;
        }
        .final-card-label {
            display: flex; 
            flex-direction: column; 
            width: 220px; 
            color: #fff; 
            text-shadow: 0 0 10px #d4af37; 
            text-align: center;
            animation: textFloat 3s ease-in-out infinite alternate;
            margin-bottom: 20px;
        }
        @keyframes textFloat { from { transform: translateY(0); } to { transform: translateY(-5px); } }
        
        .final-name { font-size: 15px; font-weight: bold; color: #d4af37; margin-bottom: 8px; border-bottom: 1px solid rgba(212, 175, 55, 0.3); padding-bottom: 5px; }
        .final-meaning { font-size: 11px; color: #ccc; font-style: italic; line-height: 1.5; opacity: 0.8; }

        #end-ui {
            position: absolute; 
            bottom: 12%; 
            left: 0; 
            width: 100%;
            display: flex; 
            justify-content: center;
            opacity: 0; 
            pointer-events: none; 
            transition: opacity 1.5s; 
            z-index: 50;
        }
        #restart-btn {
            background: rgba(0,0,0,0.7); 
            border: 1px solid #d4af37; 
            color: #d4af37;
            padding: 12px 50px; 
            font-size: 13px; 
            letter-spacing: 4px; 
            border-radius: 50px; 
            cursor: pointer; 
            font-family: inherit; 
            transition: 0.4s;
            backdrop-filter: blur(5px);
        }
        #restart-btn:hover { background: #d4af37; color: #000; box-shadow: 0 0 25px rgba(212, 175, 55, 0.6); }

        #credits {
            position: absolute; 
            bottom: 20px; 
            right: 25px;
            text-align: right; 
            color: #a0a0a0; 
            font-size: 10px;
            line-height: 1.6; 
            opacity: 0; 
            transition: opacity 1.5s;
            pointer-events: none; 
            z-index: 50; 
            font-family: 'Noto Serif SC', serif;
            letter-spacing: 1px;
        }

        #video-feed { position: absolute; bottom: 10px; right: 10px; width: 100px; opacity: 0; transform: scaleX(-1); pointer-events: none; border: 1px solid #d4af37; transition: opacity 0.5s; }
        
        /* 1. ÁßªÈô§ Loading Assets ÊñáÂ≠ó */
        #loader { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%,-50%); 
            z-index: 200; 
            /* Â¶ÇÊûúÈúÄË¶Å‰øùÁïôËΩ¨ÂúàÂúàÂèØ‰ª•Âú®ËøôÈáåÂä† CSS spinnerÔºåÁõÆÂâçÁïôÁ©∫ */
        }

        /* --- ÁßªÂä®Á´ØÈÄÇÈÖç (Responsive Styles) --- */
        @media (max-width: 768px) {
            h1 { font-size: 42px; letter-spacing: 8px; }
            h2 { font-size: 10px; letter-spacing: 4px; }
            .options-grid { grid-template-columns: 1fr; gap: 30px; margin-bottom: 30px; }
            .choice-btn { padding: 10px 0; width: 200px; }
            #enter-btn { padding: 15px 60px; font-size: 14px; }
            
            /* ÁßªÂä®Á´ØÂéÜÂè≤ËÆ∞ÂΩï - Á®çÂæÆÊîæÂ§ß‰∏ÄÁÇπ */
            #history-container {
                top: 15px;
                right: 50%;
                transform: translateX(50%);
                height: 80px; /* Â¢ûÂä†È´òÂ∫¶ */
                gap: 12px;
            }
            .history-slot { width: 50px; height: 75px; } /* Â¢ûÂä†ÂÆΩÂ∫¶ÔºåËÆ©ÂõæÁâáÁúãÊ∏ÖÊ•öÁÇπ */
            .history-name { font-size: 7px; }

            /* HUD Ë∞ÉÊï¥ */
            #hud-center { bottom: 15%; }
            #status-text { font-size: 10px; letter-spacing: 2px; }
            
            /* Âà∂‰Ωú‰∫∫Âëò‰ø°ÊÅØÁº©Â∞è */
            #credits { text-align: center; right: 0; width: 100%; bottom: 10px; font-size: 8px; }
            
            /* ÊúÄÁªàÁªìÊûúÊñáÂ≠óË∞ÉÊï¥ - ÂæÄ‰∏äÊèêÊõ¥Â§ö */
            #final-text-container { top: 48%; gap: 15px; }
            .final-card-label { width: 100%; max-width: 280px; margin-bottom: 5px; }
            .final-meaning { font-size: 11px; line-height: 1.4; }
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>
    <div id="loader"></div>

    <div id="start-screen">
        <div class="title-group">
            <h1>ARCANUM</h1>
            <h2 id="subtitle">The Virtual Ritual</h2>
        </div>

        <div class="options-grid">
            <div class="option-group">
                <div class="option-label" id="lbl-language">Language / ËØ≠Ë®Ä</div>
                <button class="choice-btn active" onclick="setLang('en')" id="btn-en">English</button>
                <button class="choice-btn" onclick="setLang('zh')" id="btn-zh">‰∏≠Êñá</button>
            </div>
            <div class="option-group">
                <div class="option-label" id="lbl-input">Input / ÊìçÊéß</div>
                <button class="choice-btn active" onclick="setInput('hand')" id="btn-hand">Hand Gesture ‚úã</button>
                <button class="choice-btn" onclick="setInput('mouse')" id="btn-mouse">Mouse / Touch üñ±Ô∏è</button>
            </div>
        </div>

        <button id="enter-btn" onclick="enterExperience()">ENTER</button>
    </div>

    <div id="ui-layer">
        <div id="history-container"></div>
        <div id="final-text-container"></div>
        
        <div id="end-ui">
            <button id="restart-btn" onclick="location.reload()">RESTART RITUAL</button>
        </div>
        
        <div id="credits">
            Jerry Hu & Gemini Âà∂‰Ωú<br>huqiuzhi10@gmail.com
        </div>

        <div id="hud-center">
            <span id="gesture-icon">‚úã</span>
            <div id="status-text">Wave to Turn ¬∑ Pinch to Select</div>
        </div>
    </div>

    <video id="video-feed" playsinline></video>
    <div id="canvas-container"></div>

<script>
// Ê£ÄÊµãÊòØÂê¶ÁßªÂä®ËÆæÂ§á
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

// 1. Èó™ÂÖâÁâπÊïàÈÄªËæë
function createSparkles() {
    const screen = document.getElementById('start-screen');
    if(screen.style.display === 'none') return; 

    const sparkle = document.createElement('div');
    sparkle.className = 'sparkle';
    
    // ÈöèÊú∫‰ΩçÁΩÆ
    const x = Math.random() * 100;
    const y = Math.random() * 100;
    sparkle.style.left = x + '%';
    sparkle.style.top = y + '%';
    
    // ÈöèÊú∫Â§ßÂ∞èÂíåÊåÅÁª≠Êó∂Èó¥
    const size = Math.random() * 3 + 1; 
    sparkle.style.width = size + 'px';
    sparkle.style.height = size + 'px';
    sparkle.style.animationDuration = (Math.random() * 2 + 2) + 's'; 
    
    screen.appendChild(sparkle);

    // Âä®ÁîªÁªìÊùüÂêéÁßªÈô§
    setTimeout(() => { sparkle.remove(); }, 4000);
}
setInterval(createSparkles, 200);


/**
 * DATA & CONFIG
 */
const TEXTS = {
    en: {
        subtitle: "The Virtual Ritual",
        lblLang: "Language",
        lblInput: "Input Method",
        enter: "ENTER VOID",
        statusWave: "Wave to Turn ¬∑ Pinch Center Card",
        statusMouse: "Move to Turn ¬∑ Hold to Grab",
        statusTouch: "Drag to Turn ¬∑ Hold to Grab",
        statusFist: "FIST TO REVEAL",
        statusSpace: "SPACE / HOLD TO REVEAL",
        statusReveal: "OBSERVING FATE...",
        statusDone: "RITUAL COMPLETE",
        rev: "Reversed",
        restart: "RESTART RITUAL",
        btnHand: "Hand Gesture ‚úã", 
        btnMouse: isMobile ? "Touch Control üëÜ" : "Mouse Control üñ±Ô∏è"        
    },
    zh: {
        subtitle: "ËôöÊãüÂ°îÁΩó‰ª™Âºè",
        lblLang: "ËØ≠Ë®ÄËÆæÁΩÆ",
        lblInput: "ÊìçÊéßÊñπÂºè",
        enter: "ËøõÂÖ•ËôöÁ©∫",
        statusWave: "Êå•ÊâãËΩ¨Âä®ÁâåÈòµ ¬∑ ÊçèÂêàÊâãÊåáÈÄâ‰∏≠",
        statusMouse: "ÁßªÂä®Èº†Ê†áËΩ¨Âä® ¬∑ Êåâ‰ΩèÂ∑¶ÈîÆÊäìÂèñ",
        statusTouch: "ÊªëÂä®ËΩ¨Âä® ¬∑ ÈïøÊåâÊäìÂèñ/Êè≠Á§∫",
        statusFist: "Êè°Êã≥Êè≠Á§∫ÂëΩËøê",
        statusSpace: "ÊåâÁ©∫Ê†º / ÈïøÊåâÊè≠Á§∫",
        statusReveal: "Ê≠£Âú®ËßÇÊµãÂëΩËøê...",
        statusDone: "‰ª™ÂºèÂÆåÊàê",
        rev: "ÈÄÜ‰Ωç",
        restart: "ÈáçÊñ∞ÂºÄÂßã‰ª™Âºè",
        btnHand: "ÊâãÂäøÊìçÊéß ‚úã",
        btnMouse: isMobile ? "Ëß¶Â±èÊìçÊéß üëÜ" : "Èº†Ê†áÊìçÊéß üñ±Ô∏è"
    }
};

const TAROT_DATA = [
    { name_en: "The Fool", name_zh: "ÊÑö‰∫∫", img: "https://upload.wikimedia.org/wikipedia/commons/9/90/RWS_Tarot_00_Fool.jpg", meaning_en: "New beginnings, innocence, spontaneity.", meaning_zh: "Êñ∞ÁöÑÂºÄÂßãÔºåÂ§©ÁúüÔºåËá™ÂèëÊÄßÔºåÊó†ÈôêÂèØËÉΩ„ÄÇ" },
    { name_en: "The Magician", name_zh: "È≠îÊúØÂ∏à", img: "https://upload.wikimedia.org/wikipedia/commons/d/de/RWS_Tarot_01_Magician.jpg", meaning_en: "Manifestation, resourcefulness, power.", meaning_zh: "ÂàõÈÄ†ÂäõÔºåËµÑÊ∫ê‰∏∞ÂØåÔºåÊÑèÂøóÂäõÔºåÊòæÂåñ„ÄÇ" },
    { name_en: "The High Priestess", name_zh: "Â•≥Á•≠Âè∏", img: "https://upload.wikimedia.org/wikipedia/commons/8/88/RWS_Tarot_02_High_Priestess.jpg", meaning_en: "Intuition, sacred knowledge, divine feminine.", meaning_zh: "Áõ¥ËßâÔºåÊΩúÊÑèËØÜÔºåÁ•ûÁßòÁü•ËØÜÔºåÂÜÖÂú®Êô∫ÊÖß„ÄÇ" },
    { name_en: "The Empress", name_zh: "ÁöáÂêé", img: "https://upload.wikimedia.org/wikipedia/commons/d/d2/RWS_Tarot_03_Empress.jpg", meaning_en: "Femininity, beauty, nature, nurturing.", meaning_zh: "‰∏∞È•∂ÔºåÊØçÊÄßÔºåËá™ÁÑ∂ÔºåÊÑüÂÆò‰∫´Âèó„ÄÇ" },
    { name_en: "The Emperor", name_zh: "ÁöáÂ∏ù", img: "https://upload.wikimedia.org/wikipedia/commons/c/c3/RWS_Tarot_04_Emperor.jpg", meaning_en: "Authority, structure, control, fatherhood.", meaning_zh: "ÊùÉÂ®ÅÔºåÁªìÊûÑÔºåÊéßÂà∂ÔºåÁà∂ÊÄßÂäõÈáè„ÄÇ" },
    { name_en: "The Hierophant", name_zh: "ÊïôÁöá", img: "https://upload.wikimedia.org/wikipedia/commons/8/8d/RWS_Tarot_05_Hierophant.jpg", meaning_en: "Spiritual wisdom, religious beliefs, conformity.", meaning_zh: "‰º†ÁªüÔºåÁ≤æÁ•ûÊåáÂºïÔºå‰ø°‰ª∞ÔºåÂæ™ËßÑËπàÁü©„ÄÇ" },
    { name_en: "The Lovers", name_zh: "ÊÅã‰∫∫", img: "https://upload.wikimedia.org/wikipedia/commons/3/3a/RWS_Tarot_06_Lovers.jpg", meaning_en: "Love, harmony, relationships, values alignment.", meaning_zh: "Áà±ÊÉÖÔºåÂíåË∞êÔºå‰∫∫ÈôÖÂÖ≥Á≥ªÔºå‰ª∑ÂÄºËßÇÊäâÊã©„ÄÇ" },
    { name_en: "The Chariot", name_zh: "ÊàòËΩ¶", img: "https://upload.wikimedia.org/wikipedia/commons/9/9b/RWS_Tarot_07_Chariot.jpg", meaning_en: "Control, willpower, success, action.", meaning_zh: "ÊÑèÂøóÂäõÔºåËÉúÂà©ÔºåÂÜ≥ÂøÉÔºåÊéåÊéßÊñπÂêë„ÄÇ" },
    { name_en: "Strength", name_zh: "ÂäõÈáè", img: "https://upload.wikimedia.org/wikipedia/commons/f/f5/RWS_Tarot_08_Strength.jpg", meaning_en: "Strength, courage, persuasion, influence.", meaning_zh: "ÂÜÖÂú®ÂäõÈáèÔºåÂãáÊ∞îÔºåËÄêÂøÉÔºå‰ª•ÊüîÂÖãÂàö„ÄÇ" },
    { name_en: "The Hermit", name_zh: "ÈöêÂ£´", img: "https://upload.wikimedia.org/wikipedia/commons/4/4d/RWS_Tarot_09_Hermit.jpg", meaning_en: "Soul-searching, introspection, being alone.", meaning_zh: "ÂÜÖÁúÅÔºåÂ≠§Áã¨ÔºåÂØªÊâæÁúüÁêÜÔºåÁ≤æÁ•ûÊåáÂºï„ÄÇ" },
    { name_en: "Wheel of Fortune", name_zh: "ÂëΩËøê‰πãËΩÆ", img: "https://upload.wikimedia.org/wikipedia/commons/3/3c/RWS_Tarot_10_Wheel_of_Fortune.jpg", meaning_en: "Good luck, karma, life cycles, destiny.", meaning_zh: "ÂëΩËøêËΩ¨ÊäòÔºåÂõ†ÊûúÂæ™ÁéØÔºåÊú∫ÈÅáÔºåÊîπÂèò„ÄÇ" },
    { name_en: "Justice", name_zh: "Ê≠£‰πâ", img: "https://upload.wikimedia.org/wikipedia/commons/e/e0/RWS_Tarot_11_Justice.jpg", meaning_en: "Justice, fairness, truth, cause and effect.", meaning_zh: "ÂÖ¨Ê≠£ÔºåÁúüÁêÜÔºåÂõ†ÊûúÔºåÊ≥ïÂæã‰∏éÁß©Â∫è„ÄÇ" },
    { name_en: "The Hanged Man", name_zh: "ÂÄíÂêä‰∫∫", img: "https://upload.wikimedia.org/wikipedia/commons/2/2b/RWS_Tarot_12_Hanged_Man.jpg", meaning_en: "Pause, surrender, letting go, new perspectives.", meaning_zh: "Áâ∫Áâ≤ÔºåÊç¢‰ΩçÊÄùËÄÉÔºåÁ≠âÂæÖÔºåÈÄöËøáÊîæÊâãËé∑ÂæóÊô∫ÊÖß„ÄÇ" },
    { name_en: "Death", name_zh: "Ê≠ªÁ•û", img: "https://upload.wikimedia.org/wikipedia/commons/d/d7/RWS_Tarot_13_Death.jpg", meaning_en: "Endings, change, transformation, transition.", meaning_zh: "ÁªìÊùüÔºåÈáçÁîüÔºåÂΩªÂ∫ïÁöÑÊîπÂèòÔºåÂøÖÁÑ∂ÁöÑËΩ¨Âûã„ÄÇ" },
    { name_en: "Temperance", name_zh: "ËäÇÂà∂", img: "https://upload.wikimedia.org/wikipedia/commons/f/f8/RWS_Tarot_14_Temperance.jpg", meaning_en: "Balance, moderation, patience, purpose.", meaning_zh: "Âπ≥Ë°°ÔºåË∞ÉÂíåÔºåËÄêÂøÉÔºå‰∏≠Â∫∏‰πãÈÅì„ÄÇ" },
    { name_en: "The Devil", name_zh: "ÊÅ∂È≠î", img: "https://upload.wikimedia.org/wikipedia/commons/5/55/RWS_Tarot_15_Devil.jpg", meaning_en: "Shadow self, attachment, addiction, restriction.", meaning_zh: "ÊùüÁºöÔºåÊ¨≤ÊúõÔºåÁâ©Ë¥®‰∏ª‰πâÔºåÊ≤âËø∑„ÄÇ" },
    { name_en: "The Tower", name_zh: "È´òÂ°î", img: "https://upload.wikimedia.org/wikipedia/commons/5/53/RWS_Tarot_16_Tower.jpg", meaning_en: "Sudden change, upheaval, chaos, revelation.", meaning_zh: "Á™ÅÂèòÔºåÊØÅÁÅ≠ÔºåÂêØÁ§∫ÔºåÊóßÁªìÊûÑÁöÑÂ¥©Â°å„ÄÇ" },
    { name_en: "The Star", name_zh: "ÊòüÊòü", img: "https://upload.wikimedia.org/wikipedia/commons/d/db/RWS_Tarot_17_Star.jpg", meaning_en: "Hope, faith, purpose, renewal, spirituality.", meaning_zh: "Â∏åÊúõÔºåÁÅµÊÑüÔºåÊ≤ªÊÑàÔºåÊú™Êù•ÁöÑÊåáÂºï„ÄÇ" },
    { name_en: "The Moon", name_zh: "Êúà‰∫Æ", img: "https://upload.wikimedia.org/wikipedia/commons/7/7f/RWS_Tarot_18_Moon.jpg", meaning_en: "Illusion, fear, anxiety, subconscious.", meaning_zh: "ÂπªËßâÔºå‰∏çÂÆâÔºåÊΩúÊÑèËØÜÔºåËø∑Ëå´‰∏éÊé¢Á¥¢„ÄÇ" },
    { name_en: "The Sun", name_zh: "Â§™Èò≥", img: "https://upload.wikimedia.org/wikipedia/commons/1/17/RWS_Tarot_19_Sun.jpg", meaning_en: "Positivity, fun, warmth, success, vitality.", meaning_zh: "ÊàêÂäüÔºåÂø´‰πêÔºåÊ¥ªÂäõÔºåÂÖâÊòéÔºåÁúüÁõ∏Â§ßÁôΩ„ÄÇ" },
    { name_en: "Judgement", name_zh: "ÂÆ°Âà§", img: "https://upload.wikimedia.org/wikipedia/commons/d/dd/RWS_Tarot_20_Judgement.jpg", meaning_en: "Judgement, rebirth, inner calling, absolution.", meaning_zh: "ËßâÈÜíÔºåÂ§çÊ¥ªÔºåÂõ†ÊûúË£ÅÂÜ≥ÔºåÂÜÖÂøÉÁöÑÂëºÂî§„ÄÇ" },
    { name_en: "The World", name_zh: "‰∏ñÁïå", img: "https://upload.wikimedia.org/wikipedia/commons/f/ff/RWS_Tarot_21_World.jpg", meaning_en: "Completion, integration, accomplishment, travel.", meaning_zh: "ÂúÜÊª°ÔºåÂÆåÊàêÔºåÊàêÂ∞±ÔºåÊñ∞ÁöÑÊóÖÁ®ã„ÄÇ" }
];

// STATE
let curLang = 'zh';
let curInput = 'mouse';
let scene, camera, renderer;
let cards = []; 
let totalCards = 22; // Using Major Arcana
let angleStep;
let currentRotation = 0;
let targetRotation = 0;
let selectedCards = []; // { index, reversed, mesh }
let isDrawing = false;
let finalReveal = false;
let group; 
let raycaster, mouse;
let hands; 
let camVideo;
let isPinching = false;
let lastPinchTime = 0;
let dissolveSystems = []; // Store active particle systems

// TEXTURE LOADER
const textureLoader = new THREE.TextureLoader();
const backTextureUrl = 'https://i.imgur.com/7v8vO4H.jpeg'; // Card Back
let loadedTextures = 0;

function setLang(l) {
    curLang = l;
    document.getElementById('btn-en').classList.toggle('active', l==='en');
    document.getElementById('btn-zh').classList.toggle('active', l==='zh');
    updateTexts();
}

function setInput(m) {
    curInput = m;
    document.getElementById('btn-hand').classList.toggle('active', m==='hand');
    document.getElementById('btn-mouse').classList.toggle('active', m==='mouse');
}

function updateTexts() {
    const t = TEXTS[curLang];
    document.getElementById('subtitle').innerText = t.subtitle;
    document.getElementById('lbl-language').innerText = t.lblLang;
    document.getElementById('lbl-input').innerText = t.lblInput;
    document.getElementById('enter-btn').innerText = t.enter;
    document.getElementById('btn-hand').innerText = t.btnHand;
    document.getElementById('btn-mouse').innerText = t.btnMouse;
    document.getElementById('restart-btn').innerText = t.restart;
    
    // Update HUD if running
    if(scene) updateHUDStatus();
}

function enterExperience() {
    document.getElementById('start-screen').style.opacity = 0;
    setTimeout(() => {
        document.getElementById('start-screen').style.display = 'none';
        init3D();
        document.getElementById('ui-layer').style.opacity = 1;
        if(curInput === 'hand') startHandTracking();
        updateHUDStatus();
    }, 1500);
}

function updateHUDStatus() {
    const t = TEXTS[curLang];
    const status = document.getElementById('status-text');
    const icon = document.getElementById('gesture-icon');
    
    if (finalReveal) {
        status.innerText = t.statusDone;
        icon.innerText = "‚ú®";
        return;
    }

    if (isDrawing) {
        if(curInput === 'hand') { status.innerText = t.statusFist; icon.innerText = "‚úä"; }
        else { status.innerText = t.statusSpace; icon.innerText = isMobile ? "üëÜ" : "‚å®Ô∏è"; }
    } else {
        if(curInput === 'hand') { status.innerText = t.statusWave; icon.innerText = "‚úã"; }
        else { 
            status.innerText = isMobile ? t.statusTouch : t.statusMouse; 
            icon.innerText = isMobile ? "üëÜ" : "üñ±Ô∏è"; 
        }
    }
}

// --- 3D SCENE ---

function init3D() {
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.0008);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 3000);
    // ** ‰øÆÊîπÁÇπ 1ÔºöÁ´ñÂ±èÊ®°Âºè‰∏ãÁõ∏Êú∫Êõ¥Ëøë **
    updateCameraPosition();

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // Lights
    const ambient = new THREE.AmbientLight(0x404040, 1.5);
    scene.add(ambient);
    const spot = new THREE.SpotLight(0d4af37, 1);
    spot.position.set(0, 500, 500);
    scene.add(spot);
    
    // Mysterious Particles (Starfield)
    const geomPart = new THREE.BufferGeometry();
    const posPart = [];
    for(let i=0; i<300; i++) {
        posPart.push((Math.random()-0.5)*2000, (Math.random()-0.5)*2000, (Math.random()-0.5)*2000);
    }
    geomPart.setAttribute('position', new THREE.Float32BufferAttribute(posPart, 3));
    // ** 2. ËÉåÊôØÊòüÂÖâÁ®çÂæÆ‰∫Æ‰∏ÄÁÇπ (opacity 0.5 -> 0.8) **
    const matPart = new THREE.PointsMaterial({color: 0xffffff, size: 2, transparent: true, opacity: 0.8});
    const particles = new THREE.Points(geomPart, matPart);
    scene.add(particles);

    // Card Group
    group = new THREE.Group();
    scene.add(group);
    
    angleStep = (Math.PI * 2) / totalCards;
    
    // Load Textures & Create Cards
    const backMat = new THREE.MeshBasicMaterial({ map: textureLoader.load(backTextureUrl) });
    
    // Geometry for cards
    const cardGeo = new THREE.PlaneGeometry(100, 160);

    for (let i = 0; i < totalCards; i++) {
        // Front Texture
        const frontUrl = TAROT_DATA[i].img;
        const frontMat = new THREE.MeshBasicMaterial({ 
            map: textureLoader.load(frontUrl, () => {
                loadedTextures++;
                if(loadedTextures === totalCards) document.getElementById('loader').style.display = 'none';
            }),
            side: THREE.FrontSide
        });
        
        // Card Mesh (Front & Back)
        const cardObj = new THREE.Group();
        
        // Front Mesh
        const fMesh = new THREE.Mesh(cardGeo, frontMat);
        fMesh.position.z = 0.5;
        fMesh.rotation.y = Math.PI; // Face inward initially
        
        // Back Mesh
        const bMesh = new THREE.Mesh(cardGeo, backMat);
        bMesh.rotation.y = 0; // Back faces outward
        
        cardObj.add(fMesh);
        cardObj.add(bMesh);
        
        // **‰øÆÊîπÁÇπ 2ÔºöËÆ°ÁÆóÂçäÂæÑÊó∂Ôºå‰∏çÁî®Áº©ÂæóÂ§™Â∞è**
        const r = isMobile ? 600 : 800; 

        const theta = i * angleStep;
        cardObj.position.x = r * Math.sin(theta);
        cardObj.position.z = r * Math.cos(theta);
        cardObj.lookAt(0, 0, 0);
        
        // Initial custom property
        cardObj.userData = { id: i, name: TAROT_DATA[i].name_en, originPos: cardObj.position.clone(), originRot: cardObj.rotation.clone() };

        group.add(cardObj);
        cards.push(cardObj);
    }
    
    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();

    window.addEventListener('resize', onWindowResize, false);
    
    if(curInput === 'mouse') {
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mousedown', onMouseDown);
        document.addEventListener('mouseup', onMouseUp);
        document.addEventListener('touchstart', onTouchStart);
        document.addEventListener('touchmove', onTouchMove);
        document.addEventListener('touchend', onTouchEnd);
    }
    
    animate();
}

// **‰øÆÊîπÁÇπ 1 & 2 ÁöÑËæÖÂä©ÂáΩÊï∞**
function updateCameraPosition() {
    if (isMobile && window.innerHeight > window.innerWidth) {
        // Á´ñÂ±èÊ®°ÂºèÔºöÊãâËøëÁõ∏Êú∫ÔºåÂè™ÁúãÂ±ÄÈÉ®
        camera.position.z = 700; 
    } else {
        camera.position.z = 1000;
    }
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    updateCameraPosition();
}

// Interaction Variables
let isDragging = false;
let previousMousePosition = { x: 0, y: 0 };
let grabStartTime = 0;
let hoveredCard = null;

function onMouseMove(e) {
    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    
    if (isDragging && !isDrawing && !finalReveal) {
        const deltaMove = { x: e.offsetX - previousMousePosition.x };
        targetRotation += deltaMove.x * 0.005;
        previousMousePosition = { x: e.offsetX, y: e.offsetY };
    }
}

function onMouseDown(e) {
    isDragging = true;
    previousMousePosition = { x: e.offsetX, y: e.offsetY };
    grabStartTime = Date.now();
    
    // Check click on card
    if (!finalReveal) {
        checkIntersection();
        if (hoveredCard) {
            // Start Holding
            startSelecting(hoveredCard);
        }
    }
}

function onMouseUp(e) {
    isDragging = false;
    // If hold was short, maybe just click? Handled by loop logic usually.
    // Here we rely on long press logic in animate()
    if (isDrawing) {
        finishSelecting();
    }
}

// Touch Support
function onTouchStart(e) {
    if(e.touches.length > 0) {
        mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
        isDragging = true;
        previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        grabStartTime = Date.now();
        
        checkIntersection();
        if(hoveredCard) startSelecting(hoveredCard);
    }
}

function onTouchMove(e) {
    if(e.touches.length > 0) {
        mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
        
        if (isDragging && !isDrawing && !finalReveal) {
            const deltaMove = { x: e.touches[0].clientX - previousMousePosition.x };
            targetRotation += deltaMove.x * 0.008; // faster on mobile
            previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
    }
}

function onTouchEnd() {
    isDragging = false;
    if(isDrawing) finishSelecting();
}

function checkIntersection() {
    raycaster.setFromCamera(mouse, camera);
    // Intersection with only cards in group
    // We only care about cards roughly in front (z > r-200) optimization
    const intersects = raycaster.intersectObjects(group.children, true);
    if (intersects.length > 0) {
        // Find the parent group (card container)
        let obj = intersects[0].object;
        while(obj.parent !== group) { obj = obj.parent; }
        hoveredCard = obj;
    } else {
        hoveredCard = null;
    }
}

// Animation Loop
function animate() {
    requestAnimationFrame(animate);
    TWEEN.update();
    
    if (scene) {
        // Rotate Group Smoothly
        currentRotation += (targetRotation - currentRotation) * 0.1;
        group.rotation.y = currentRotation;
        
        // Idle Rotation
        if (!isDragging && !isDrawing && !finalReveal) {
            targetRotation += 0.0005;
        }

        // Highlight center card logic
        if (!isDrawing && !finalReveal) {
            // Simple distance check to camera forward vector
            // But raycaster is better on mouse
            if (curInput === 'hand') {
                // Hand logic handles hover
            } else {
                checkIntersection();
            }
        }
        
        // Card Hover Effect
        cards.forEach(c => {
            if (c === hoveredCard && !selectedCards.some(s=>s.mesh===c)) {
                c.scale.setScalar(1.2);
            } else {
                c.scale.setScalar(1);
            }
        });

        // Update Particles (Dissolve Effect)
        updateDissolveEffects();
        
        renderer.render(scene, camera);
    }
}

// ** 3. Âç°ÁâåÊ∂àÊï£ÁâπÊïàÈÄªËæë **
function createDissolveEffect(pos) {
    const count = 150; // Á≤íÂ≠êÊï∞Èáè
    const geom = new THREE.BufferGeometry();
    const positions = [];
    const velocities = [];
    
    for(let i=0; i<count; i++) {
        // Start at card position
        positions.push(pos.x, pos.y, pos.z);
        
        // Random velocity sphere
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos((Math.random() * 2) - 1);
        const speed = Math.random() * 3 + 1; // Speed
        
        velocities.push(
            speed * Math.sin(phi) * Math.cos(theta),
            speed * Math.sin(phi) * Math.sin(theta),
            speed * Math.cos(phi)
        );
    }
    
    geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    
    // "ÈáëËâ≤Á≤íÂ≠êÁªÜÂ∞è‰∏ÄÁÇπ" (Fine Gold Particles)
    const mat = new THREE.PointsMaterial({
        color: 0xd4af37, 
        size: 1.5, // ÁªÜÂ∞è
        transparent: true, 
        opacity: 1 
    });
    
    const system = new THREE.Points(geom, mat);
    scene.add(system);
    
    dissolveSystems.push({
        mesh: system,
        velocities: velocities,
        age: 0
    });
}

function updateDissolveEffects() {
    for(let i=dissolveSystems.length-1; i>=0; i--) {
        const sys = dissolveSystems[i];
        sys.age++;
        
        const positions = sys.mesh.geometry.attributes.position.array;
        
        // Update positions based on velocity
        for(let j=0; j<sys.velocities.length/3; j++) {
            positions[j*3] += sys.velocities[j*3];
            positions[j*3+1] += sys.velocities[j*3+1];
            positions[j*3+2] += sys.velocities[j*3+2];
        }
        
        sys.mesh.geometry.attributes.position.needsUpdate = true;
        
        // Fade out
        sys.mesh.material.opacity -= 0.02;
        
        if(sys.mesh.material.opacity <= 0) {
            scene.remove(sys.mesh);
            sys.mesh.geometry.dispose();
            sys.mesh.material.dispose();
            dissolveSystems.splice(i, 1);
        }
    }
}

// SELECTION LOGIC
function startSelecting(cardMesh) {
    if (selectedCards.length >= 3) return;
    if (selectedCards.some(s => s.mesh === cardMesh)) return;

    isDrawing = true;
    updateHUDStatus();
    
    // Animate card shake or glow?
    new TWEEN.Tween(cardMesh.position)
        .to({ y: cardMesh.position.y + 20 }, 200)
        .yoyo(true).repeat(Infinity).start();
}

function finishSelecting() {
    if (!isDrawing) return;
    isDrawing = false;
    
    if (hoveredCard && selectedCards.length < 3) {
        // Draw the card
        drawCard(hoveredCard);
    }
    updateHUDStatus();
}

function drawCard(cardMesh) {
    // Stop shake
    TWEEN.removeAll();
    
    // Determine Reversal (Random 30%)
    const isReversed = Math.random() < 0.3;
    
    // Remove from ring logic (visually)
    // Attach to Scene so it doesn't rotate with group
    scene.attach(cardMesh); 
    
    const index = selectedCards.length;
    selectedCards.push({ mesh: cardMesh, reversed: isReversed, data: TAROT_DATA[cardMesh.userData.id] });
    
    // Animation to Screen Corner (History Slot)
    
    // 1. Move to Center Front
    const centerPos = new THREE.Vector3(0, 0, camera.position.z - 200);
    const targetRot = new THREE.Euler(0, Math.PI, isReversed ? Math.PI : 0); // Front facing camera
    
    new TWEEN.Tween(cardMesh.position)
        .to({ x: centerPos.x, y: centerPos.y, z: centerPos.z }, 1000)
        .easing(TWEEN.Easing.Cubic.Out)
        .start();

    new TWEEN.Tween(cardMesh.rotation)
        .to({ x: targetRot.x, y: targetRot.y, z: targetRot.z }, 1000)
        .onComplete(() => {
            document.getElementById('status-text').innerText = TEXTS[curLang].statusReveal;
            
            // 2. Wait, then move to "History"
            setTimeout(() => {
                addToHistoryUI(selectedCards[index]);
                
                // ** Trigger Particle Dissolve Effect **
                createDissolveEffect(cardMesh.position);

                // Shrink and vanish card
                new TWEEN.Tween(cardMesh.scale).to({ x:0, y:0, z:0 }, 500).start();
                
                if(selectedCards.length === 3) {
                    setTimeout(showFinalResults, 1000);
                } else {
                    document.getElementById('status-text').innerText = isMobile ? TEXTS[curLang].statusTouch : TEXTS[curLang].statusMouse;
                }
            }, 1500);
        })
        .start();
}

function addToHistoryUI(cardObj) {
    const container = document.getElementById('history-container');
    const slot = document.createElement('div');
    slot.className = 'history-slot' + (cardObj.reversed ? ' is-reversed' : '');
    
    const img = document.createElement('img');
    img.src = cardObj.data.img;
    
    const info = document.createElement('div');
    info.className = 'history-info';
    
    const name = document.createElement('div');
    name.className = 'history-name';
    name.innerText = curLang === 'en' ? cardObj.data.name_en : cardObj.data.name_zh;
    
    const rev = document.createElement('div');
    rev.className = 'history-rev';
    rev.innerText = TEXTS[curLang].rev;
    
    info.appendChild(rev);
    info.appendChild(name);
    slot.appendChild(img);
    slot.appendChild(info);
    
    container.appendChild(slot);
}

function showFinalResults() {
    finalReveal = true;
    updateHUDStatus();
    
    // Hide Ring
    new TWEEN.Tween(group.scale).to({ x:0, y:0, z:0 }, 1000).start();
    
    // Bring cards back!
    // **‰øÆÊîπÁÇπ 4ÔºöÊúÄÁªàÁªìÊûúÂ±ïÁ§∫‰ΩçÁΩÆ‰ºòÂåñ**
    // Á´ñÂ±èÔºöÂûÇÁõ¥ÊéíÂàóÊàñËÄÖ‰∏âËßíÂΩ¢Á¥ßÂáëÊéíÂàó
    // Ê®™Â±èÔºöÊ∞¥Âπ≥ÊéíÂàó
    
    const gap = isMobile ? 120 : 220; 
    // Mobile Portrait Z: closer to make them look bigger
    const targetZ = camera.position.z - (isMobile ? 250 : 300); 
    // Mobile Portrait Y: Lift them up!
    const BaseY = isMobile ? 80 : 0; 
    
    selectedCards.forEach((c, i) => {
        const mesh = c.mesh;
        mesh.visible = true;
        mesh.scale.set(0,0,0);
        
        let tx, ty;
        if(isMobile && window.innerHeight > window.innerWidth) {
            // Portrait: Triangle or stacked? Let's do horizontal but squeezed
            // Actually user said "Result images too small". Moving Z closer fixes this.
            // Let's arrange them horizontally with small gap
            tx = (i - 1) * (gap * 0.9);
            ty = BaseY; 
            // Scale up slightly for mobile
            mesh.scale.set(1.1, 1.1, 1.1); 
        } else {
            tx = (i - 1) * gap;
            ty = 0;
            mesh.scale.set(1, 1, 1);
        }

        new TWEEN.Tween(mesh.position)
            .to({ x: tx, y: ty, z: targetZ }, 1500)
            .easing(TWEEN.Easing.Elastic.Out)
            .delay(i * 200)
            .onStart(() => {
                 if (isMobile) mesh.scale.set(1.2, 1.2, 1.2); 
                 else mesh.scale.set(1, 1, 1);
            })
            .start();
            
        // Text
        const textContainer = document.getElementById('final-text-container');
        textContainer.style.opacity = 1;
        
        const label = document.createElement('div');
        label.className = 'final-card-label';
        const nameText = curLang==='en'? c.data.name_en : c.data.name_zh;
        const meanText = curLang==='en'? c.data.meaning_en : c.data.meaning_zh;
        const revText = c.reversed ? `(${TEXTS[curLang].rev})` : '';
        
        label.innerHTML = `
            <div class="final-name">${nameText} ${revText}</div>
            <div class="final-meaning">${meanText}</div>
        `;
        textContainer.appendChild(label);
    });
    
    document.getElementById('end-ui').style.opacity = 1;
    document.getElementById('credits').style.opacity = 1;
    document.getElementById('hud-center').style.opacity = 0;
}


// --- HAND TRACKING (Simplified Placeholder Logic) ---
function startHandTracking() {
    const video = document.getElementById('video-feed');
    
    const hand = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});
    
    hand.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });
    
    hand.onResults(onHandResults);
    
    camVideo = new Camera(video, {
        onFrame: async () => { await hand.send({image: video}); },
        width: 640, height: 480
    });
    camVideo.start();
    video.style.opacity = 0.3; // Show small feed
}

function onHandResults(results) {
    if(!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) return;
    
    const lm = results.multiHandLandmarks[0];
    const indexTip = lm[8];
    const thumbTip = lm[4];
    const wrist = lm[0];
    
    // Map hand X to rotation speed
    // Center of screen is 0.5. < 0.4 Rotate Left, > 0.6 Rotate Right
    if (indexTip.x < 0.4) targetRotation += 0.02;
    if (indexTip.x > 0.6) targetRotation -= 0.02;
    
    // Pinch Detection (Distance between index tip and thumb tip)
    const distance = Math.sqrt(Math.pow(indexTip.x - thumbTip.x, 2) + Math.pow(indexTip.y - thumbTip.y, 2));
    
    if (distance < 0.05) {
        if (!isPinching) {
            isPinching = true;
            lastPinchTime = Date.now();
            // Trigger select on center card
            // Find card closest to center Z
            if(!finalReveal) {
                let centerCard = null;
                let minZ = -Infinity;
                cards.forEach(c => {
                    const worldPos = new THREE.Vector3();
                    c.getWorldPosition(worldPos);
                    if(worldPos.z > minZ) {
                        minZ = worldPos.z;
                        centerCard = c;
                    }
                });
                if(centerCard) {
                    hoveredCard = centerCard;
                    startSelecting(centerCard);
                }
            }
        } else {
            // Holding pinch?
            if(Date.now() - lastPinchTime > 1000) finishSelecting();
        }
    } else {
        isPinching = false;
        isDrawing = false;
    }
}
</script>
</body>
</html>
