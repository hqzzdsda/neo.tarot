<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Arcanum: Kinetic Ritual</title>
    <style>
        /* --- å…¨å±€æ ·å¼ (Global Styles) --- */
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Times New Roman', 'Songti SC', 'SimSun', serif; 
            user-select: none; 
            -webkit-tap-highlight-color: transparent; 
        }
        #canvas-container { 
            width: 100vw; 
            height: 100vh; 
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 1; 
            cursor: grab; /* é»˜è®¤æ‰‹å‹ */
        }
        #canvas-container:active {
            cursor: grabbing; /* æŠ“å–æ‰‹å‹ */
        }
        
        /* --- åˆå§‹ç•Œé¢ (Start Screen) --- */
        #start-screen {
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            z-index: 100;
            background: radial-gradient(circle at center, rgba(0,0,0,0.4) 0%, rgba(0,0,0,0.95) 90%);
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center;
            transition: opacity 1.5s cubic-bezier(0.25, 1, 0.5, 1);
            color: #d4af37;
            padding: 20px;
            box-sizing: border-box;
        }

        /* æ ‡é¢˜åŠ¨ç”»ä¸æ ·å¼ */
        .title-group { 
            text-align: center; 
            margin-bottom: 5vh; 
            position: relative;
            animation: floatTitle 6s ease-in-out infinite; 
        }
        
        h1 { 
            font-size: 72px; 
            margin: 0; 
            letter-spacing: 20px; 
            font-weight: 800;
            background: linear-gradient(135deg, #fff 0%, #d4af37 50%, #996515 100%);
            -webkit-background-clip: text; 
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 20px rgba(212, 175, 55, 0.4));
            position: relative;
        }
        
        h2 { 
            font-size: 14px; 
            font-weight: 400; 
            letter-spacing: 8px; 
            color: #a0a0a0; 
            margin-top: 15px; 
            text-transform: uppercase; 
            opacity: 0.8;
            border-top: 1px solid rgba(212, 175, 55, 0.3); 
            display: inline-block; 
            padding-top: 15px; 
            width: 120%; 
            margin-left: -10%;
        }

        @keyframes floatTitle {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        /* é€‰é¡¹æŒ‰é’®ç½‘æ ¼ */
        .options-grid { 
            display: grid; 
            grid-template-columns: 1fr 1fr; 
            gap: 60px; 
            margin-bottom: 5vh; 
            text-align: center; 
            opacity: 0; 
            animation: fadeUp 1s ease-out 0.5s forwards; 
        }
        .option-group { 
            display: flex; 
            flex-direction: column; 
            gap: 20px; 
            align-items: center; 
        }
        .option-label { 
            font-size: 11px; 
            letter-spacing: 3px; 
            color: #666; 
            text-transform: uppercase; 
            margin-bottom: 5px; 
            font-weight: 600;
        }

        /* èƒ¶å›ŠæŒ‰é’®æ ·å¼ */
        .choice-btn {
            background: rgba(255, 255, 255, 0.03); 
            border: 1px solid rgba(212, 175, 55, 0.3); 
            color: #888;
            padding: 12px 0; 
            width: 160px;
            font-family: inherit; 
            font-size: 12px; 
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
            border-radius: 50px; 
            position: relative; 
            overflow: hidden;
            backdrop-filter: blur(2px);
        }
        
        .choice-btn.active { 
            border-color: #d4af37; 
            color: #fff; 
            background: rgba(212, 175, 55, 0.15); 
            box-shadow: 0 0 25px rgba(212, 175, 55, 0.15);
        }
        
        .choice-btn:hover { 
            border-color: #fff; 
            color: #fff; 
            transform: translateY(-2px); 
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }

        /* è¿›å…¥æŒ‰é’®ç‰¹æ•ˆ */
        #enter-btn {
            background: transparent; 
            color: #d4af37; 
            border: 1px solid #d4af37;
            padding: 18px 80px; 
            font-size: 16px; 
            letter-spacing: 8px; 
            cursor: pointer;
            font-family: inherit; 
            font-weight: 600; 
            border-radius: 50px; 
            transition: all 0.5s;
            position: relative; 
            overflow: hidden;
            opacity: 0; 
            animation: fadeUp 1s ease-out 0.8s forwards;
        }
        
        #enter-btn::before {
            content: ''; 
            position: absolute; 
            top: 0; 
            left: -100%; 
            width: 100%; 
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(212, 175, 55, 0.2), transparent);
            transition: 0.5s;
        }
        #enter-btn:hover::before { left: 100%; transition: 0.7s; }
        #enter-btn:hover { 
            background: #d4af37; 
            color: #000; 
            box-shadow: 0 0 40px rgba(212, 175, 55, 0.4); 
            transform: scale(1.05); 
            letter-spacing: 10px;
        }

        @keyframes fadeUp { 
            from { opacity: 0; transform: translateY(20px); } 
            to { opacity: 1; transform: translateY(0); } 
        }

        /* ç¥ç§˜å­¦é—ªå…‰ç²’å­ */
        .sparkle {
            position: absolute; 
            background: white; 
            border-radius: 50%;
            pointer-events: none; 
            opacity: 0;
            box-shadow: 0 0 10px #d4af37, 0 0 20px #d4af37;
            animation: sparkleFloat linear forwards;
        }
        @keyframes sparkleFloat {
            0% { opacity: 0; transform: translateY(0) scale(0); }
            50% { opacity: 1; transform: translateY(-50px) scale(1); }
            100% { opacity: 0; transform: translateY(-100px) scale(0); }
        }

        /* --- æ¸¸æˆå†… UI å±‚ --- */
        #ui-layer { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: 20; 
            pointer-events: none; 
            color: #d4af37; 
            opacity: 0; 
            transition: opacity 1.5s; 
        }
        
        /* å†å²è®°å½•æ  */
        #history-container {
            position: absolute; 
            top: 20px; 
            right: 20px;
            display: flex; 
            flex-direction: row; 
            gap: 15px;
            pointer-events: auto; 
            z-index: 30; 
            height: 100px; 
            align-items: flex-start;
            transition: opacity 1s ease;
        }
        .history-slot {
            width: 50px; 
            height: 85px; 
            background: #fff; 
            border: 2px solid #d4af37; 
            border-radius: 8px; 
            overflow: hidden;
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: flex-end;
            box-shadow: 0 4px 15px rgba(0,0,0,0.8); 
            flex-shrink: 0; 
            position: relative;
            animation: slotEnter 0.6s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        @keyframes slotEnter { 
            from { opacity:0; transform: translateY(-20px); } 
            to { opacity:1; transform: translateY(0); } 
        }
        .history-slot img { position: absolute; top:0; left:0; width: 100%; height: 100%; object-fit: cover; }
        .history-info { position: relative; z-index: 2; width: 100%; background: rgba(0,0,0,0.8); text-align: center; padding: 2px 0; border-top: 1px solid #d4af37; }
        .history-name { font-size: 8px; color: #d4af37; font-weight: 700; white-space: nowrap; transform: scale(0.9); }
        .history-rev { font-size: 7px; color: #ff3333; display: none; font-weight: bold; background: rgba(0,0,0,0.5); width:100%; }
        .is-reversed img { transform: rotate(180deg); }
        .is-reversed .history-rev { display: block; }

        /* åº•éƒ¨ HUD */
        #hud-center {
            position: absolute; 
            bottom: 8%; 
            left: 50%; 
            transform: translateX(-50%);
            text-align: center; 
            color: #d4af37; 
            pointer-events: none;
            width: 100%; 
            transition: opacity 1s;
        }
        #gesture-icon { font-size: 32px; display: block; margin-bottom: 10px; opacity: 0.9; text-shadow: 0 0 15px #d4af37;}
        #status-text { font-size: 11px; letter-spacing: 4px; text-transform: uppercase; font-weight: 600; opacity: 0.8; }

        /* æœ€ç»ˆç»“æœæ–‡å­—å®¹å™¨ */
        #final-text-container {
            position: absolute; 
            top: 65%; /* ç¨å¾®ä¸Šç§»ä»¥é€‚é…å°å±å¹• */
            left: 0; 
            width: 100%;
            text-align: center; 
            opacity: 0; 
            transition: opacity 2s;
            pointer-events: none; 
            display: flex; 
            justify-content: center; 
            gap: 120px; /* æ¡Œé¢ç«¯é—´è·æ”¹å¤§ */
            flex-wrap: wrap; /* å…è®¸æ¢è¡Œ */
            padding: 0 20px;
            box-sizing: border-box;
        }
        .final-card-label {
            display: flex; 
            flex-direction: column; 
            width: 220px; 
            color: #fff; 
            text-shadow: 0 0 10px #d4af37; 
            text-align: center;
            animation: textFloat 3s ease-in-out infinite alternate;
            margin-bottom: 20px;
        }
        @keyframes textFloat { from { transform: translateY(0); } to { transform: translateY(-5px); } }
        
        .final-name { font-size: 15px; font-weight: bold; color: #d4af37; margin-bottom: 8px; border-bottom: 1px solid rgba(212, 175, 55, 0.3); padding-bottom: 5px; }
        .final-meaning { font-size: 11px; color: #ccc; font-style: italic; line-height: 1.5; opacity: 0.8; }

        /* é‡å¯æŒ‰é’®åŒºåŸŸ (åŒ…å«æŸ¥çœ‹æŒ‡å¼•) */
        #end-ui {
            position: absolute; 
            bottom: 12%; 
            left: 0; 
            width: 100%;
            display: flex; 
            flex-direction: column; /* å‚ç›´æ’åˆ— */
            align-items: center;
            justify-content: center;
            opacity: 0; 
            pointer-events: auto; /* ç¡®ä¿å¯ç‚¹å‡» */
            transition: opacity 1.5s; 
            z-index: 50;
            gap: 20px;
        }
        
        #restart-btn {
            background: rgba(0,0,0,0.7); 
            border: 1px solid #d4af37; 
            color: #d4af37;
            padding: 12px 50px; 
            font-size: 13px; 
            letter-spacing: 4px; 
            border-radius: 50px; 
            cursor: pointer; 
            font-family: inherit; 
            transition: 0.4s;
            backdrop-filter: blur(5px);
        }
        #restart-btn:hover { background: #d4af37; color: #000; box-shadow: 0 0 25px rgba(212, 175, 55, 0.6); }

        /* æ–°å¢ï¼šæŸ¥çœ‹æŒ‡å¼•æŒ‰é’® */
        #view-reading-btn {
            background: #d4af37;  /* é‡‘è‰²èƒŒæ™¯ */
            color: #000;          /* é»‘è‰²æ–‡å­— */
            border: 1px solid #d4af37;
            padding: 15px 60px;
            font-size: 14px;
            letter-spacing: 4px;
            border-radius: 50px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            transition: 0.4s;
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.4);
        }
        #view-reading-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 40px rgba(212, 175, 55, 0.8);
        }

        /* æ–°å¢ï¼šè§£è¯´æ–‡å­—å…¨å±å®¹å™¨ */
        #oracle-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 700px;
            text-align: center;
            color: #fff;
            font-size: 18px;        
            line-height: 2.0;       
            font-family: 'Noto Serif SC', serif;
            text-shadow: 0 0 10px #d4af37;
            z-index: 60;
            pointer-events: none; /* å¼€å§‹æ—¶ä¸å¯ç‚¹å‡» */
            opacity: 1;
        }

        /* Loading å‘¼å¸ç¯åŠ¨ç”» */
        @keyframes pulse { 0% { opacity: 0.4; } 50% { opacity: 1; } 100% { opacity: 0.4; } }

        /* --- åˆ¶ä½œäººå‘˜ä¿¡æ¯ --- */
        #credits {
            position: absolute; 
            bottom: 20px; 
            right: 25px;
            text-align: right; 
            color: #a0a0a0; 
            font-size: 10px;
            line-height: 1.6; 
            opacity: 0; 
            transition: opacity 1.5s;
            pointer-events: none; 
            z-index: 50; 
            font-family: 'Noto Serif SC', serif;
            letter-spacing: 1px;
        }

        #video-feed { position: absolute; bottom: 10px; right: 10px; width: 100px; opacity: 0; transform: scaleX(-1); pointer-events: none; border: 1px solid #d4af37; transition: opacity 0.5s; }
        #loader { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); color: #d4af37; letter-spacing: 6px; font-size: 12px; font-weight: bold; z-index: 200; }

        /* --- ç§»åŠ¨ç«¯é€‚é… (Responsive Styles) --- */
        @media (max-width: 768px) {
            h1 { font-size: 42px; letter-spacing: 8px; }
            h2 { font-size: 10px; letter-spacing: 4px; }
            .options-grid { grid-template-columns: 1fr; gap: 30px; margin-bottom: 30px; }
            .choice-btn { padding: 10px 0; width: 200px; }
            #enter-btn { padding: 15px 60px; font-size: 14px; }
            
            /* ç§»åŠ¨ç«¯å†å²è®°å½•ç½®é¡¶å±…ä¸­ */
            #history-container {
                top: 10px;
                right: 50%;
                transform: translateX(50%);
                height: 70px;
                gap: 10px;
            }
            .history-slot { width: 40px; height: 65px; }
            .history-name { font-size: 6px; }

            /* HUD è°ƒæ•´ */
            #hud-center { bottom: 15%; }
            #status-text { font-size: 10px; letter-spacing: 2px; }
            
            /* åˆ¶ä½œäººå‘˜ä¿¡æ¯ç¼©å° */
            #credits { text-align: center; right: 0; width: 100%; bottom: 10px; font-size: 8px; }
            
            /* æœ€ç»ˆç»“æœæ–‡å­—è°ƒæ•´ */
            #final-text-container { 
                top: 47%;           /* è°ƒæ•´å‚ç›´ä½ç½® */
                flex-direction: column; /* å¼ºåˆ¶å‚ç›´æ’åˆ—ï¼Œé˜²æ­¢æ–‡å­—æŒ¤å‹ */
                align-items: center;    /* å±…ä¸­å¯¹é½ */
                max-height: 40vh;       /* é™åˆ¶é«˜åº¦ï¼Œé˜²æ­¢é®æŒ¡åº•éƒ¨æŒ‰é’® */
                overflow-y: auto;       /* å¦‚æœæ–‡å­—å¤ªå¤šï¼Œå…è®¸æ»šåŠ¨ */
                gap: 10px; /* ç§»åŠ¨ç«¯é—´è·æ”¹å›å°å€¼ */
            }
            .final-card-label { width: 100%; max-width: 300px; }
            
            /* è§£è¯´æ–‡å­—åœ¨æ‰‹æœºä¸Šå°ä¸€ç‚¹ */
            #oracle-overlay { font-size: 14px; width: 90%; }
        }
    </style>
    
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>
    <div id="loader"></div>

    <div id="start-screen">
        <div class="title-group">
            <h1>ARCANUM</h1>
            <h2 id="subtitle">The Kinetic Ritual</h2>
        </div>

        <div class="options-grid">
            <div class="option-group">
                <div class="option-label" id="lbl-language">Language / è¯­è¨€</div>
                <button class="choice-btn active" onclick="setLang('en')" id="btn-en">English</button>
                <button class="choice-btn" onclick="setLang('zh')" id="btn-zh">ä¸­æ–‡</button>
            </div>
            <div class="option-group">
                <div class="option-label" id="lbl-input">Input / æ“æ§</div>
                <button class="choice-btn active" onclick="setInput('hand')" id="btn-hand">Hand Gesture âœ‹</button>
                <button class="choice-btn" onclick="setInput('mouse')" id="btn-mouse">Drag & Touch ğŸ–±ï¸</button>
            </div>
        </div>

        <button id="enter-btn" onclick="enterExperience()">ENTER</button>
    </div>

    <div id="ui-layer">
        <div id="history-container"></div>
        <div id="final-text-container"></div>
        
        <div id="oracle-overlay"></div>

        <div id="end-ui">
            <button id="view-reading-btn" onclick="enterStarryVoid()">REVEAL DESTINY</button>
            <button id="restart-btn" onclick="location.reload()" style="display:none">RESTART RITUAL</button>
        </div>
        
        <div id="credits">
            By: Jerry Hu & Gemini<br>huqiuzhi10@gmail.com
        </div>

        <div id="hud-center">
            <span id="gesture-icon">âœ‹</span>
            <div id="status-text">Drag to Spin Â· Click to Select</div>
        </div>
    </div>

    <video id="video-feed" playsinline></video>
    <div id="canvas-container"></div>

<script>
// ================= API é…ç½®åŒºåŸŸ =================
const API_KEY = "sk-92c5cec08baf4941a5ab5a185cd9c22f"; 
const API_ENDPOINT = "https://api.deepseek.com/chat/completions"; 
const API_MODEL = "deepseek-chat"; 
const USE_PROXY_FOR_API = true;
const PROXY_BASE_URL = "https://corsproxy.io/?"; 
const DEBUG_MODE = true;
// ==============================================


// æ£€æµ‹æ˜¯å¦ç§»åŠ¨è®¾å¤‡
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

// 1. é—ªå…‰ç‰¹æ•ˆé€»è¾‘
function createSparkles() {
    const screen = document.getElementById('start-screen');
    if(screen.style.display === 'none') return; 

    const sparkle = document.createElement('div');
    sparkle.className = 'sparkle';
    
    // éšæœºä½ç½®
    const x = Math.random() * 100;
    const y = Math.random() * 100;
    sparkle.style.left = x + '%';
    sparkle.style.top = y + '%';
    
    // éšæœºå¤§å°å’ŒæŒç»­æ—¶é—´
    const size = Math.random() * 3 + 1; 
    sparkle.style.width = size + 'px';
    sparkle.style.height = size + 'px';
    sparkle.style.animationDuration = (Math.random() * 2 + 2) + 's'; 
    
    screen.appendChild(sparkle);

    // åŠ¨ç”»ç»“æŸåç§»é™¤
    setTimeout(() => { sparkle.remove(); }, 4000);
}
setInterval(createSparkles, 200);


/**
 * DATA & CONFIG
 */
const TEXTS = {
    en: {
        subtitle: "The Kinetic Ritual",
        lblLang: "Language",
        lblInput: "Input Method",
        enter: "ENTER VOID",
        statusWave: "Move Hand L/R to Scroll Â· Pinch to Select",
        statusMouse: "Drag to Scroll Â· Click to Select",
        statusTouch: "Swipe to Scroll Â· Tap to Select",
        statusFist: "FIST TO REVEAL",
        statusSpace: "SPACE / HOLD TO REVEAL",
        statusReveal: "OBSERVING FATE...",
        statusDone: "RITUAL COMPLETE",
        rev: "Reversed",
        restart: "RESTART RITUAL",
        btnHand: "Hand Gesture âœ‹", 
        btnMouse: isMobile ? "Touch Control ğŸ‘†" : "Mouse Control ğŸ–±ï¸"        
    },
    zh: {
        subtitle: "è™šæ‹Ÿå¡”ç½—ä»ªå¼",
        lblLang: "è¯­è¨€è®¾ç½®",
        lblInput: "æ“æ§æ–¹å¼",
        enter: "è¿›å…¥è™šç©º",
        statusWave: "å·¦å³ç§»åŠ¨æ‰‹æŒæ»šåŠ¨ Â· æåˆé€‰ä¸­",
        statusMouse: "å·¦å³æ‹–æ‹½æ»šåŠ¨ Â· ç‚¹å‡»é€‰ä¸­",
        statusTouch: "å·¦å³æ»‘åŠ¨æ»šåŠ¨ Â· è½»ç‚¹é€‰ä¸­",
        statusFist: "æ¡æ‹³æ­ç¤ºå‘½è¿",
        statusSpace: "æŒ‰ç©ºæ ¼ / é•¿æŒ‰æ­ç¤º",
        statusReveal: "æ­£åœ¨è§‚æµ‹å‘½è¿...",
        statusDone: "ä»ªå¼å®Œæˆ",
        rev: "é€†ä½",
        restart: "é‡æ–°å¼€å§‹ä»ªå¼",
        btnHand: "æ‰‹åŠ¿æ§åˆ¶ âœ‹", 
        btnMouse: isMobile ? "è§¦å±æ§åˆ¶ ğŸ‘†" : "é¼ æ ‡æ§åˆ¶ ğŸ–±ï¸"  
    }
};

// åŸºç¡€æ•°æ® (å®Œæ•´22å¼ )
const RWS_DATA = [
    { id: 0, en: { name: "The Fool", meaning: "New beginnings, innocence, spontaneity" }, zh: { name: "æ„šè€…", meaning: "æ–°çš„å¼€å§‹ï¼Œå¤©çœŸï¼Œè‡ªå‘æ€§ï¼Œå†’é™©" } },
    { id: 1, en: { name: "The Magician", meaning: "Manifestation, resourcefulness, power" }, zh: { name: "é­”æœ¯å¸ˆ", meaning: "æ˜¾åŒ–ï¼Œèµ„æºä¸°å¯Œï¼ŒåŠ›é‡ï¼Œåˆ›é€ åŠ›" } },
    { id: 2, en: { name: "High Priestess", meaning: "Intuition, sacred knowledge" }, zh: { name: "å¥³ç¥­å¸", meaning: "ç›´è§‰ï¼Œç¥åœ£çŸ¥è¯†ï¼Œæ½œæ„è¯†ï¼Œç¥ç§˜" } },
    { id: 3, en: { name: "The Empress", meaning: "Femininity, beauty, nature" }, zh: { name: "çš‡å", meaning: "å¥³æ€§åŠ›é‡ï¼Œç¾ä¸½ï¼Œè‡ªç„¶ï¼Œå­•è‚²" } },
    { id: 4, en: { name: "The Emperor", meaning: "Authority, establishment" }, zh: { name: "çš‡å¸", meaning: "æƒå¨ï¼Œä½“åˆ¶ï¼Œç»“æ„ï¼Œæ§åˆ¶" } },
    { id: 5, en: { name: "The Hierophant", meaning: "Spiritual wisdom, beliefs" }, zh: { name: "æ•™çš‡", meaning: "ç²¾ç¥æ™ºæ…§ï¼Œä¿¡ä»°ï¼Œä¼ ç»Ÿï¼Œæ•™å¯¼" } },
    { id: 6, en: { name: "The Lovers", meaning: "Love, harmony, choices" }, zh: { name: "æ‹äºº", meaning: "çˆ±ï¼Œå’Œè°ï¼Œå…³ç³»ï¼Œé€‰æ‹©" } },
    { id: 7, en: { name: "The Chariot", meaning: "Control, willpower, success" }, zh: { name: "æˆ˜è½¦", meaning: "æ§åˆ¶ï¼Œæ„å¿—åŠ›ï¼ŒæˆåŠŸï¼Œè¡ŒåŠ¨" } },
    { id: 8, en: { name: "Strength", meaning: "Strength, courage, persuasion" }, zh: { name: "åŠ›é‡", meaning: "åŠ›é‡ï¼Œå‹‡æ°”ï¼Œè¯´æœï¼Œå½±å“åŠ›" } },
    { id: 9, en: { name: "The Hermit", meaning: "Soul-searching, introspection" }, zh: { name: "éšå£«", meaning: "æ¢ç´¢å†…å¿ƒï¼Œå†…çœï¼Œç‹¬å¤„ï¼ŒæŒ‡å¼•" } },
    { id: 10, en: { name: "Wheel of Fortune", meaning: "Good luck, karma, destiny" }, zh: { name: "å‘½è¿ä¹‹è½®", meaning: "å¥½è¿ï¼Œä¸šåŠ›ï¼Œç”Ÿå‘½å‘¨æœŸï¼Œå‘½è¿" } },
    { id: 11, en: { name: "Justice", meaning: "Justice, fairness, truth" }, zh: { name: "æ­£ä¹‰", meaning: "æ­£ä¹‰ï¼Œå…¬å¹³ï¼ŒçœŸç†ï¼Œå› æœ" } },
    { id: 12, en: { name: "Hanged Man", meaning: "Pause, surrender, letting go" }, zh: { name: "å€’åŠäºº", meaning: "æš‚åœï¼Œè‡£æœï¼Œæ”¾æ‰‹ï¼Œæ–°è§†è§’" } },
    { id: 13, en: { name: "Death", meaning: "Endings, change, transformation" }, zh: { name: "æ­»ç¥", meaning: "ç»“æŸï¼Œæ”¹å˜ï¼Œè½¬åŒ–ï¼Œè¿‡æ¸¡" } },
    { id: 14, en: { name: "Temperance", meaning: "Balance, moderation, patience" }, zh: { name: "èŠ‚åˆ¶", meaning: "å¹³è¡¡ï¼Œé€‚åº¦ï¼Œè€å¿ƒï¼Œç›®æ ‡" } },
    { id: 15, en: { name: "The Devil", meaning: "Shadow self, addiction" }, zh: { name: "æ¶é­”", meaning: "é˜´æš—é¢ï¼Œæ‰§ç€ï¼Œæˆç˜¾ï¼ŒæŸç¼š" } },
    { id: 16, en: { name: "The Tower", meaning: "Sudden change, upheaval" }, zh: { name: "é«˜å¡”", meaning: "çªå˜ï¼Œå‰§å˜ï¼Œæ··ä¹±ï¼Œå¯ç¤º" } },
    { id: 17, en: { name: "The Star", meaning: "Hope, faith, renewal" }, zh: { name: "æ˜Ÿæ˜Ÿ", meaning: "å¸Œæœ›ï¼Œä¿¡å¿µï¼Œç›®æ ‡ï¼Œæ–°ç”Ÿ" } },
    { id: 18, en: { name: "The Moon", meaning: "Illusion, fear, anxiety" }, zh: { name: "æœˆäº®", meaning: "å¹»è§‰ï¼Œææƒ§ï¼Œç„¦è™‘ï¼Œæ½œæ„è¯†" } },
    { id: 19, en: { name: "The Sun", meaning: "Positivity, fun, warmth" }, zh: { name: "å¤ªé˜³", meaning: "ç§¯æï¼Œå¿«ä¹ï¼Œæ¸©æš–ï¼ŒæˆåŠŸ" } },
    { id: 20, en: { name: "Judgement", meaning: "Judgement, rebirth, calling" }, zh: { name: "å®¡åˆ¤", meaning: "å®¡åˆ¤ï¼Œé‡ç”Ÿï¼Œå†…å¿ƒå¬å”¤ï¼Œèµ¦å…" } },
    { id: 21, en: { name: "The World", meaning: "Completion, integration" }, zh: { name: "ä¸–ç•Œ", meaning: "å®Œæˆï¼Œæ•´åˆï¼Œæˆå°±ï¼Œåœ†æ»¡" } }
];

let currentLang = 'en';
// å¦‚æœæ˜¯æ‰‹æœºï¼Œé»˜è®¤ä½¿ç”¨ Mouse/Touch æ¨¡å¼
let controlMode = isMobile ? 'mouse' : 'hand'; 
let isStarted = false;
let deckList = [];

// Game Logic Params
const MAX_SELECTION = 3; 
let selectionCount = 0;
let isRitualComplete = false;
let chosen3DMeshes = [];

const RADIUS = 10;
const CARD_W = 1.5;
const CARD_H = 2.58;
const CORNER_R = 0.08;
const GOLD_COLOR = 0xd4af37;
const BG_COLOR = 0x000000;

// åˆå§‹åŒ–æŒ‰é’®çŠ¶æ€
window.onload = function() {
    setInput(controlMode);
    updateStartScreenText();
};

function setLang(lang) {
    currentLang = lang;
    document.querySelectorAll('[onclick^="setLang"]').forEach(b => b.classList.remove('active'));
    document.getElementById(`btn-${lang}`).classList.add('active');
    updateStartScreenText();
}

function setInput(mode) {
    controlMode = mode;
    document.querySelectorAll('[onclick^="setInput"]').forEach(b => b.classList.remove('active'));
    document.getElementById(`btn-${mode}`).classList.add('active');
}

function updateStartScreenText() {
    const t = TEXTS[currentLang];
    document.getElementById('subtitle').innerText = t.subtitle;
    document.getElementById('lbl-language').innerText = t.lblLang;
    document.getElementById('lbl-input').innerText = t.lblInput;
    document.getElementById('enter-btn').innerText = t.enter;
    document.getElementById('restart-btn').innerText = t.restart;
    // æ›´æ–°æŒ‰é’®æ–‡å­—
    document.getElementById('btn-hand').innerText = t.btnHand;
    document.getElementById('btn-mouse').innerText = t.btnMouse;
}

function enterExperience() {
    isStarted = true;
    const screen = document.getElementById('start-screen');
    screen.style.opacity = 0;
    screen.style.pointerEvents = 'none'; 
    setTimeout(() => { screen.style.display = 'none'; }, 1500);
    const ui = document.getElementById('ui-layer');
    ui.style.opacity = 1;
    
    // åˆå§‹åŒ–è¾“å…¥ç›‘å¬
    if (controlMode === 'hand') {
        document.getElementById('video-feed').style.opacity = 0.3;
        initCamera();
    } else {
        initMouseListeners();
        initTouchListeners(); // å¢åŠ è§¦æ‘¸ç›‘å¬
    }
    
    updateCameraPos(); // ç¡®ä¿ç›¸æœºä½ç½®æ­£ç¡®
    updateStatusText();
    spawnDeck();
}

/**
 * THREE.JS SCENE SETUP
 */
const scene = new THREE.Scene();
scene.background = new THREE.Color(BG_COLOR);
scene.fog = new THREE.FogExp2(BG_COLOR, 0.012);
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
// åˆå§‹ä½ç½®ç”± updateCameraPos å†³å®š

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
document.getElementById('canvas-container').appendChild(renderer.domElement);

const texLoader = new THREE.TextureLoader();
// âš ï¸ é™æ€èµ„æºåŠ è½½ï¼šç›´æ¥åŠ è½½æœ¬åœ°å›¾ç‰‡ï¼Œä¸èµ°ä»£ç†
const texBackGlobal = texLoader.load('./cards/back.png'); 
texBackGlobal.anisotropy = renderer.capabilities.getMaxAnisotropy();
texBackGlobal.center.set(0.5, 0.5);

const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
scene.add(ambientLight);
const frontLight = new THREE.DirectionalLight(0xffeaac, 0.6);
frontLight.position.set(0, 2, 5);
scene.add(frontLight);

// Stars
const starGeo = new THREE.BufferGeometry();
const starPos = new Float32Array(2500*3);
for(let i=0;i<2500;i++) {
    const r = 20 + Math.random()*40;
    const theta = Math.random()*Math.PI*2;
    const phi = Math.acos(Math.random()*2-1);
    starPos[i*3] = r*Math.sin(phi)*Math.cos(theta);
    starPos[i*3+1] = r*Math.sin(phi)*Math.sin(theta);
    starPos[i*3+2] = r*Math.cos(phi);
}
starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
const starMat = new THREE.PointsMaterial({color: 0xcccccc, size: 0.06});
const starSystem = new THREE.Points(starGeo, starMat);
scene.add(starSystem);

/**
 * DECK CONSTRUCTION
 */
const deckGroup = new THREE.Group();
scene.add(deckGroup);
let cardObjects = [];

const shape = new THREE.Shape();
const w = CARD_W/2, h = CARD_H/2, r = CORNER_R;
shape.moveTo(-w+r, -h); shape.lineTo(w-r, -h); shape.quadraticCurveTo(w, -h, w, -h+r);
shape.lineTo(w, h-r); shape.quadraticCurveTo(w, h, w-r, h);
shape.lineTo(-w+r, h); shape.quadraticCurveTo(-w, h, -w, h-r);
shape.lineTo(-w, -h+r); shape.quadraticCurveTo(-w, -h, -w+r, -h);
const faceGeo = new THREE.ShapeGeometry(shape);

function fixUVs(geometry) {
    const posAttribute = geometry.attributes.position;
    const uvAttribute = geometry.attributes.uv;
    for (let i = 0; i < posAttribute.count; i++) {
        const x = posAttribute.getX(i);
        const y = posAttribute.getY(i);
        uvAttribute.setXY(i, (x / CARD_W) + 0.5, (y / CARD_H) + 0.5);
    }
    uvAttribute.needsUpdate = true;
}
fixUVs(faceGeo);

const matBase = { roughness: 0.6, metalness: 0.1 };
const edgeMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, ...matBase });

function createCardMesh(data, index, total) {
    const group = new THREE.Group();
    // âš ï¸ è¿™é‡ŒåŠ è½½å¡ç‰Œçº¹ç†ï¼šä½¿ç”¨æœ¬åœ°ç›¸å¯¹è·¯å¾„ï¼Œä¸èµ°ä»£ç†
    const texFront = texLoader.load(data.url);
    texFront.anisotropy = renderer.capabilities.getMaxAnisotropy();
    texFront.center.set(0.5, 0.5);
    
    const matBack = new THREE.MeshStandardMaterial({ map: texBackGlobal, ...matBase });
    const matFront = new THREE.MeshStandardMaterial({ map: texFront, ...matBase });

    const meshBack = new THREE.Mesh(faceGeo, matBack);
    meshBack.position.z = 0.005; 
    const meshFront = new THREE.Mesh(faceGeo, matFront);
    meshFront.rotation.y = Math.PI;
    meshFront.position.z = -0.005;
    const meshFiller = new THREE.Mesh(faceGeo, edgeMat);
    meshFiller.scale.set(0.995, 0.995, 1);
    
    group.add(meshBack, meshFront, meshFiller);
    
    // è®¡ç®—å¡ç‰Œåœ¨ç¯ä¸Šçš„è§’åº¦
    // éµå¾ª ThreeJS å³æ‰‹å®šåˆ™ï¼š
    const step = (Math.PI * 2) / total;
    const theta = index * step; 
    
    group.position.x = RADIUS * Math.sin(theta);
    group.position.z = -RADIUS * Math.cos(theta);
    group.lookAt(0, 0, 0);

    group.userData = { 
        id: data.id, 
        rawData: data, 
        state: 'IDLE', 
        theta: theta, 
        index: index, 
        isChosen: false,
        baseColor: 0xffffff 
    };
    return group;
}

function spawnDeck() {
    if(!isStarted) return;
    const isPortrait = window.innerHeight > window.innerWidth;
    deckGroup.position.y = isPortrait ? 2.0 : 0; 
    
    deckGroup.clear(); cardObjects = [];
    
    deckList = RWS_DATA.map(d => ({
        ...d,
        url: `./cards/${d.id}.png`
    }));

    deckList.sort(() => Math.random() - 0.5);
    
    deckList.forEach((item, i) => {
        const card = createCardMesh(item, i, deckList.length);
        deckGroup.add(card);
        cardObjects.push(card);
    });
    
    deckGroup.rotation.y = 0;
    document.getElementById('loader').style.display = 'none';
}

/**
 * ==========================================================
 * NEW: UNIFIED SCROLL PHYSICS (Apple Picker / æ‹¨è½®é€»è¾‘)
 * ==========================================================
 */

const physics = {
    state: 'IDLE', // IDLE, DRAGGING, INERTIA, SNAPPING
    velocity: 0,
    
    // æ‹–æ‹½ç›¸å…³
    lastInputPos: 0,
    dragStartPos: 0,
    dragStartTime: 0,
    
    // å¸é™„åŠ¨ç”»ç›¸å…³
    snapStartRot: 0,
    snapTargetRot: 0,
    snapStartTime: 0,
    snapDuration: 120, // ms
    
    // å‚æ•°è°ƒä¼˜
    friction: 0.96,       // æƒ¯æ€§æ‘©æ“¦ç³»æ•°
    snapThreshold: 0.0005, // é€Ÿåº¦ä½äºæ­¤å€¼å¼€å§‹å¸é™„
    minReleaseVel: 0.003, // æ¾æ‰‹æ—¶é€Ÿåº¦å°äºæ­¤å€¼ç›´æ¥å¸é™„
    
    // çµæ•åº¦
    dragSensitivity: isMobile ? 0.005 : 0.003,
    handJoystickSpeed: 0.05, // æ‰‹åŠ¿æ‘‡æ†æœ€å¤§é€Ÿåº¦

    // è¾¹ç•Œ (å¤´å°¾)
    minRot: 0, 
    maxRot: 0  
};

function updateBoundaries() {
    if (!deckList.length) return;
    const count = deckList.length;
    const step = (Math.PI * 2) / count;
    // å¤´éƒ¨é™åˆ¶ï¼šä¸å…è®¸è¶…è¿‡ index 0 å¤ªå¤š
    physics.maxRot = 0.2; 
    // å°¾éƒ¨é™åˆ¶ï¼šä¸å…è®¸è¶…è¿‡ index N-1 å¤ªå¤š
    // Card N-1 at theta = (N-1)*step. We need rotation = -(N-1)*step to center it.
    physics.minRot = -((count - 1) * step) - 0.2;
}

function updateCarouselPhysics() {
    if (isRitualComplete || !deckList.length) return;
    updateBoundaries();

    // 1. å¤„ç†æ‹–æ‹½ä¸­ (ä»…é™æ‰‹åŠ¿æ‘‡æ†æ¨¡å¼éœ€è¦åœ¨æ­¤å¤„å¤„ç†ï¼Œé¼ æ ‡æ‹–æ‹½åœ¨äº‹ä»¶é‡Œå¤„ç†)
    // å¦‚æœæ˜¯æ‰‹åŠ¿ Joystick æ¨¡å¼ï¼Œvelocity ç”± handX æŒç»­é©±åŠ¨
    if (controlMode === 'hand' && physics.state === 'DRAGGING') {
        // è¾¹ç•Œé˜»å°¼ï¼šå¦‚æœåœ¨è¾¹ç•Œå¤–ï¼Œæ–½åŠ é˜»åŠ›
        if (deckGroup.rotation.y > physics.maxRot || deckGroup.rotation.y < physics.minRot) {
            physics.velocity *= 0.5;
        }
        deckGroup.rotation.y += physics.velocity;
    }

    // 2. æƒ¯æ€§é˜¶æ®µ
    if (physics.state === 'INERTIA') {
        deckGroup.rotation.y += physics.velocity;
        physics.velocity *= physics.friction;
        
        // è¾¹ç•Œç¢°æ’ï¼šå¦‚æœæ’å¢™ï¼Œé€Ÿåº¦æ¸…é›¶å¹¶åå¼¹/å¸é™„
        if (deckGroup.rotation.y > physics.maxRot) {
            deckGroup.rotation.y = physics.maxRot;
            enterSnap();
        } else if (deckGroup.rotation.y < physics.minRot) {
            deckGroup.rotation.y = physics.minRot;
            enterSnap();
        }

        // é€Ÿåº¦è¶³å¤Ÿå°ï¼Œè¿›å…¥å¸é™„
        if (Math.abs(physics.velocity) < physics.snapThreshold) {
            enterSnap();
        }
    }

    // 3. å¸é™„é˜¶æ®µ (Hard Ease-Out)
    if (physics.state === 'SNAPPING') {
        const now = Date.now();
        const progress = Math.min((now - physics.snapStartTime) / physics.snapDuration, 1.0);
        
        // Ease Out Cubic
        const ease = 1 - Math.pow(1 - progress, 3);
        
        deckGroup.rotation.y = physics.snapStartRot + (physics.snapTargetRot - physics.snapStartRot) * ease;
        
        if (progress >= 1.0) {
            physics.state = 'IDLE';
            physics.velocity = 0;
            updateVisuals(); // ç¡®ä¿æœ€åå¯¹é½
        }
    }
}

// è§¦å‘å¸é™„ï¼šå¯»æ‰¾æœ€è¿‘çš„å¡ç‰Œ
function enterSnap() {
    const count = deckList.length;
    const step = (Math.PI * 2) / count;
    
    // å½“å‰ rotation
    let currentY = deckGroup.rotation.y;
    
    // Index = -Rotation / Step
    let rawIndex = -currentY / step;
    let targetIndex = Math.round(rawIndex);
    
    // å¼ºåˆ¶è¾¹ç•Œ
    if (targetIndex < 0) targetIndex = 0;
    if (targetIndex >= count) targetIndex = count - 1;
    
    // ç›®æ ‡è§’åº¦
    const targetRot = -(targetIndex * step);
    
    // åˆå§‹åŒ–å¸é™„åŠ¨ç”»å‚æ•°
    physics.state = 'SNAPPING';
    physics.snapStartRot = currentY;
    physics.snapTargetRot = targetRot;
    physics.snapStartTime = Date.now();
    physics.velocity = 0;
}

// ç»Ÿä¸€çš„ Release é€»è¾‘
function handleReleaseLogic() {
    if (Math.abs(physics.velocity) > physics.minReleaseVel) {
        physics.state = 'INERTIA';
    } else {
        enterSnap();
    }
}

// è§†è§‰æ›´æ–°ï¼šä¸­çº¿é«˜äº®ï¼Œé‚»å±…å˜æš—
function updateVisuals() {
    if (!deckList.length) return;
    
    const count = deckList.length;
    const step = (Math.PI * 2) / count;
    
    // è®¡ç®—æœ€æ¥è¿‘ä¸­å¿ƒçš„ Index
    let rawIndex = -deckGroup.rotation.y / step;
    let normalizedIndex = Math.round(rawIndex);
    
    if (normalizedIndex < 0) normalizedIndex = 0;
    if (normalizedIndex >= count) normalizedIndex = count - 1;
    
    centerCard = cardObjects[normalizedIndex];

    cardObjects.forEach((card, idx) => {
        if (card.userData.state === 'SELECTED' || card.userData.state === 'REVEALING') return;

        let targetColor = 0x222222; // é»˜è®¤æ›´æš—ï¼Œå¢åŠ å¯¹æ¯”åº¦
        
        if (idx === normalizedIndex) {
            targetColor = 0xffffff; // åªæœ‰æ­£ä¸­é—´æ˜¯å…¨äº®
        } 

        // é¢œè‰²æ’å€¼
        const meshBack = card.children[0];
        const meshFront = card.children[1];
        
        const currCol = new THREE.Color(card.userData.baseColor);
        const targColObj = new THREE.Color(targetColor);
        
        currCol.lerp(targColObj, 0.25); 
        
        meshBack.material.color.copy(currCol);
        meshFront.material.color.copy(currCol);
        card.userData.baseColor = currCol.getHex();
    });
}


/**
 * INPUT LISTENERS
 */
let isDragging = false;

function initMouseListeners() {
    const container = document.getElementById('canvas-container');

    container.addEventListener('mousedown', (e) => {
        if(e.button !== 0) return;
        startUnifiedDrag(e.clientX);
    });

    window.addEventListener('mousemove', (e) => {
        moveUnifiedDrag(e.clientX);
    });

    window.addEventListener('mouseup', (e) => {
        endUnifiedDrag(e.clientX);
    });
    
    // Keyboard
    window.addEventListener('keydown', (e) => {
        if(e.code === 'Space') handState = 'FIST'; 
        updateCursorIcon();
    });
    window.addEventListener('keyup', (e) => {
        if(e.code === 'Space' && handState === 'FIST') handState = 'PINCH'; 
        else if (e.code === 'Space') handState = 'OPEN';
        updateCursorIcon();
    });
}

function initTouchListeners() {
    const container = document.getElementById('canvas-container');
    
    container.addEventListener('touchstart', (e) => {
        const touch = e.touches[0];
        startUnifiedDrag(touch.clientX);
    }, { passive: false });

    container.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        moveUnifiedDrag(touch.clientX);
    }, { passive: false });

    container.addEventListener('touchend', (e) => {
        endUnifiedDrag(physics.lastInputPos);
    });
}

// --- ç»Ÿä¸€æ‹–æ‹½å®ç° (é¼ æ ‡/è§¦æ‘¸ 1:1) ---
function startUnifiedDrag(x) {
    if (isRitualComplete) return;
    isDragging = true;
    physics.state = 'DRAGGING';
    physics.velocity = 0;
    physics.lastInputPos = x;
    physics.dragStartPos = x;
    physics.dragStartTime = Date.now();
    handState = 'PINCH'; 
    updateCursorIcon();
}

function moveUnifiedDrag(x) {
    if (!isDragging || isRitualComplete) return;

    const deltaX = x - physics.lastInputPos;
    
    // è¾¹ç•Œé˜»å°¼è®¡ç®—
    let sensitivity = physics.dragSensitivity;
    if (deckGroup.rotation.y > physics.maxRot || deckGroup.rotation.y < physics.minRot) {
        sensitivity *= 0.2; // é˜»åŠ›
    }
    
    const rotationDelta = deltaX * sensitivity;
    deckGroup.rotation.y += rotationDelta;
    
    // è®°å½•é€Ÿåº¦ (ç®€å•çš„ç§»åŠ¨å¹³å‡å¯èƒ½æ›´å¥½ï¼Œä½†è¿™é‡Œç”¨ç¬æ—¶é€Ÿåº¦é…åˆé«˜æ‘©æ“¦åŠ›ä¹Ÿè¡Œ)
    physics.velocity = rotationDelta; 

    physics.lastInputPos = x;
}

function endUnifiedDrag(x) {
    if (!isDragging) return;
    isDragging = false;
    handState = 'OPEN';
    updateCursorIcon();

    const totalMove = Math.abs(x - physics.dragStartPos);
    const totalTime = Date.now() - physics.dragStartTime;

    // ç‚¹å‡»åˆ¤å®š
    if (totalMove < 5 && totalTime < 300) {
        // åªæœ‰é™æ­¢æˆ–ææ…¢æ—¶å…è®¸ç‚¹å‡»é€‰ä¸­
        if (centerCard && !activeCard) {
            physics.state = 'IDLE';
            physics.velocity = 0;
            // ç¡®ä¿è½»å¾®å¯¹é½
            enterSnap();
            selectCard(centerCard);
        }
    } else {
        handleReleaseLogic();
    }
}


/**
 * HAND GESTURE (JOYSTICK MODE)
 */
let lastHandX = 0;
let handIsTracking = false;

function updateHandJoystick(handX) {
    // æ‘‡æ†é€»è¾‘ï¼šä¸­å¿ƒæ˜¯æ­»åŒºï¼Œè¶Šè¿œé€Ÿåº¦è¶Šå¿«
    // handX: -1 (å·¦) ~ 1 (å³)
    // æ˜ å°„ï¼šæ‰‹å‘å³ (X > 0) -> ç‰Œé˜µå‘å·¦è½¬ (Rotation å˜å¤§ï¼Ÿä¸ï¼ŒRotationå˜å¤§æ˜¯å‘å·¦è½¬å—ï¼Ÿ)
    // è®©æˆ‘ä»¬ç†ä¸€ä¸‹ï¼š
    // Rotation = 0 (Index 0). Rotation = -Step (Index 1).
    // è¦çœ‹å³è¾¹çš„ç‰Œ (Index 1, 2...)ï¼ŒRotation éœ€è¦å˜å° (è´Ÿæ•°)ã€‚
    // ç¬¦åˆç›´è§‰ï¼šåƒæ‹¨åœ°çƒä»ªï¼Œæ‰‹å‘å·¦æ‹¨ -> åœ°çƒä»ªå‘å·¦è½¬ -> çœ‹åˆ°å³è¾¹çš„ä¸œè¥¿ã€‚
    // æ‰‹å‘å·¦ (X < 0) -> Velocity < 0 -> Rotation å˜å° -> Index å˜å¤§ã€‚
    
    const deadzone = 0.15;
    
    if (Math.abs(handX) > deadzone) {
        physics.state = 'DRAGGING';
        // å½’ä¸€åŒ–åŠ›åº¦ 0~1
        const force = (Math.abs(handX) - deadzone) / (1 - deadzone);
        const direction = Math.sign(handX);
        
        // é€Ÿåº¦
        physics.velocity = direction * force * physics.handJoystickSpeed;
    } else {
        // å›åˆ°æ­»åŒºï¼Œè§†ä¸º Release
        if (physics.state === 'DRAGGING') {
            handleReleaseLogic();
        }
    }
}

function updateCursorIcon() {
    const icon = handState==='FIST'?'âœŠ':(handState==='PINCH'?'ğŸ¤': (isMobile ? 'ğŸ‘†' : 'ğŸ–±ï¸'));
    document.getElementById('gesture-icon').innerText = icon;
}

function updateStatusText() {
    const t = TEXTS[currentLang];
    const el = document.getElementById('status-text');
    if (isRitualComplete) {
        el.innerText = t.statusDone;
        return;
    }
    if (activeCard && activeCard.userData.state === 'SELECTED') {
        el.innerText = controlMode === 'hand' ? t.statusFist : t.statusSpace;
    } else if (activeCard && activeCard.userData.state === 'REVEALING') {
        el.innerText = t.statusReveal;
    } else {
        if (controlMode === 'hand') el.innerText = t.statusWave;
        else el.innerText = isMobile ? t.statusTouch : t.statusMouse; 
    }
}

// æ ¸å¿ƒ Loop
function handleInput() {
    if (!isStarted) return;
    if (isRitualComplete) {
        animateFinalFormation();
        return;
    }

    // åŒºåˆ†è¾“å…¥æ¨¡å¼
    if (controlMode === 'hand' && handIsTracking) {
        // æ‰‹åŠ¿æ¨¡å¼ï¼šå¦‚æœä¸å¤„äºç‰¹å®šäº¤äº’çŠ¶æ€ï¼Œåˆ™å¯ç”¨ Joystick
        if (handState !== 'PINCH' && handState !== 'FIST' && !activeCard) {
             updateHandJoystick(lastHandX);
        } 
    } 
    // é¼ æ ‡æ¨¡å¼ï¼šåœ¨äº‹ä»¶å›è°ƒä¸­å¤„ç†ç‰©ç†çŠ¶æ€æ”¹å˜ï¼Œè¿™é‡Œåªè·‘ Update
    
    updateCarouselPhysics();
    updateVisuals();

    // é€‰ä¸­å¡ç‰Œåçš„é€»è¾‘ (ä¿æŒä¸å˜)
    if (activeCard) {
        const targetZ = isMobile ? -3.5 : -2.2;
        activeCard.position.lerp(new THREE.Vector3(0, 0, targetZ), 0.1);
        
        if (activeCard.userData.state === 'SELECTED') {
            const idleQ = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, 0, 0));
            activeCard.quaternion.slerp(idleQ, 0.1);
            updateStatusText();
            
            let shouldReveal = false;
            if (controlMode === 'hand' && handState === 'FIST') shouldReveal = true;
            if (controlMode !== 'hand') {
                if (handState === 'FIST') shouldReveal = true;
                if (handState === 'PINCH') {
                     if(!activeCard.userData.revealTimer) activeCard.userData.revealTimer = Date.now();
                     if(Date.now() - activeCard.userData.revealTimer > 500) shouldReveal = true;
                } else {
                    activeCard.userData.revealTimer = null;
                }
            }
            if (shouldReveal) {
                revealCard(activeCard);
            } else if (handState === 'OPEN' && controlMode !== 'hand') {
                returnCard(activeCard);
            }
        }
    } else {
        updateStatusText();
    }
}

function selectCard(card) {
    if (selectionCount >= MAX_SELECTION) return;
    // åªèƒ½åœ¨é™æ­¢æ—¶é€‰ä¸­
    if (physics.state !== 'IDLE' && physics.state !== 'SNAPPING') return;

    activeCard = card;
    card.userData.state = 'SELECTED';
    card.userData.revealTimer = Date.now(); 
    scene.attach(card); 
}

function returnCard(card) {
    deckGroup.attach(card);
    card.userData.state = 'RETURNING';
    activeCard = null;
}

function updateReturningCards() {
    cardObjects.forEach(card => {
        if (card.userData.state === 'RETURNING') {
            const targetPos = new THREE.Vector3(
                RADIUS * Math.sin(card.userData.theta), 
                0, 
                -RADIUS * Math.cos(card.userData.theta)
            );
            card.position.lerp(targetPos, 0.08); 
            
            const dummy = new THREE.Object3D();
            dummy.position.copy(targetPos); 
            dummy.lookAt(0,0,0);
            
            card.quaternion.slerp(dummy.quaternion, 0.08);
            
            if (card.position.distanceTo(targetPos) < 0.05) {
                card.userData.state = 'IDLE';
                card.position.copy(targetPos);
                card.quaternion.copy(dummy.quaternion);
            }
        }
    });
}

function revealCard(card) {
    if (card.userData.state === 'REVEALING') return;
    card.userData.state = 'REVEALING';
    updateStatusText();
    
    const isReversed = Math.random() < 0.5;
    card.userData.isReversed = isReversed;

    const startQ = card.quaternion.clone();
    const targetEuler = new THREE.Euler(0, Math.PI, isReversed ? Math.PI : 0);
    const targetQ = new THREE.Quaternion().setFromEuler(targetEuler);

    const data = card.userData.rawData;
    const name = data[currentLang].name;

    let p = 0;
    function animateFlip() {
        p += 0.03; 
        card.quaternion.slerpQuaternions(startQ, targetQ, p);
        if (p < 1) {
            requestAnimationFrame(animateFlip);
        } else {
            card.rotation.set(0, Math.PI, isReversed ? Math.PI : 0);
            document.getElementById('status-text').innerText = name.toUpperCase();
            setTimeout(() => { dissolve(card, isReversed); }, 2000);
        }
    }
    animateFlip();
}

function dissolve(card, isReversed) {
    spawnParticles(card.position);
    selectionCount++;
    addToHistory(card.userData.rawData, isReversed);
    card.visible = false;
    card.userData.isChosen = true;
    activeCard = null;
    chosen3DMeshes.push(card); 
    if (selectionCount >= MAX_SELECTION) startEndRitual();
}

function startEndRitual() {
    isRitualComplete = true;
    updateStatusText();
    
    document.getElementById('history-container').style.opacity = 0;
    document.getElementById('hud-center').style.opacity = 0;
    
    setTimeout(() => {
        document.getElementById('end-ui').style.opacity = 1;
        document.getElementById('end-ui').style.pointerEvents = 'auto';
        document.getElementById('credits').style.opacity = 1;

        document.getElementById('view-reading-btn').style.display = 'block';
        document.getElementById('restart-btn').style.display = 'none';

        const btnText = currentLang === 'zh' ? "æ­ç¤ºæŒ‡å¼•" : "REVEAL FATE";
        document.getElementById('view-reading-btn').innerText = btnText;

    }, 3500);

    cardObjects.forEach(c => {
        if (!c.userData.isChosen) {
            c.userData.dropSpeed = 0.05 + Math.random() * 0.1;
        }
    });

    chosen3DMeshes.forEach((card, index) => {
        card.visible = true;
        scene.attach(card); 
        card.position.set(4 + index*0.5, 3, -4); 
        card.scale.set(0.2, 0.2, 0.2);

        const isPortrait = window.innerHeight > window.innerWidth;
        const gap = isPortrait ? 1.8 : 2.2;       
        const depth = isPortrait ? -7.0 : -6.0; 
        const targetY = isPortrait ? 3.0 : 0;
        
        card.userData.finalTargetPos = new THREE.Vector3((index - 1) * gap, targetY, depth);
        card.userData.finalTargetScale = 0.8;
        card.userData.animProgress = 0;
        card.userData.animDelay = index * 30; 
    });

    const textContainer = document.getElementById('final-text-container');
    const t = TEXTS[currentLang];
    
    chosen3DMeshes.forEach(card => {
        const div = document.createElement('div');
        div.className = 'final-card-label';
        const data = card.userData.rawData[currentLang];
        const revText = card.userData.isReversed ? ` (${t.rev})` : "";
        div.innerHTML = `<div class="final-name">${data.name}${revText}</div><div class="final-meaning">${data.meaning}</div>`;
        textContainer.appendChild(div);
    });
    setTimeout(() => { textContainer.style.opacity = 1; }, 2000);
}

// --- ä¿®æ”¹ï¼šè¿›å…¥æ˜Ÿç©ºè§£è¯´æ¨¡å¼ (æ”¯æŒå¼‚æ­¥ API) ---
async function enterStarryVoid() {
    document.getElementById('view-reading-btn').style.display = 'none';
    document.getElementById('final-text-container').style.opacity = 0;
    
    chosen3DMeshes.forEach(mesh => { mesh.visible = false; });
    cardObjects.forEach(mesh => { mesh.visible = false; });

    const overlay = document.getElementById('oracle-overlay');
    
    const loadingText = currentLang === 'zh' ? "æ­£åœ¨ä¸æ˜Ÿè¾°è¿æ¥..." : "Connecting with the stars...";
    overlay.innerHTML = `<div style="opacity:0.7; animation: pulse 1.5s infinite;">${loadingText}</div>`;

    const onTypingComplete = () => {
        const restartBtn = document.getElementById('restart-btn');
        restartBtn.style.display = 'block';
        restartBtn.style.opacity = 0;
        let op = 0;
        const fadeTimer = setInterval(() => {
            if(op >= 1) clearInterval(fadeTimer);
            restartBtn.style.opacity = op;
            op += 0.05;
        }, 30);
    };

    if (API_KEY && API_KEY.length > 5) {
        try {
            const apiText = await callTarotAPI(chosen3DMeshes);
            typeWriter(apiText, overlay, onTypingComplete);
        } catch (e) {
            console.error("API Error:", e);
            if (DEBUG_MODE) {
                alert(`API è°ƒç”¨å¤±è´¥: ${e.message}\n\nã€è§£å†³æ–¹æ¡ˆã€‘\nDeepSeek API åœ¨æµè§ˆå™¨ç›´æ¥è°ƒç”¨æ—¶ä¼šè¢«æ‹¦æˆª (CORS Error)ã€‚\nè¯·ç¡®ä¿ä»£ç† URL æœ‰æ•ˆã€‚`);
            }
            const fallbackText = generateReadingText(); 
            typeWriter(fallbackText, overlay, onTypingComplete);
        }
    } else {
        setTimeout(() => {
            const text = generateReadingText();
            typeWriter(text, overlay, onTypingComplete);
        }, 1500);
    }
}

async function callTarotAPI(cards) {
    const cardDescriptions = cards.map((c, i) => {
        const name = c.userData.rawData[currentLang].name;
        const posName = currentLang === 'zh' ? ["è¿‡å»", "ç°åœ¨", "æœªæ¥"][i] : ["Past", "Present", "Future"][i];
        const status = c.userData.isReversed 
            ? (currentLang === 'zh' ? "é€†ä½ (Reversed)" : "Reversed") 
            : (currentLang === 'zh' ? "æ­£ä½ (Upright)" : "Upright");
        return `${posName}: ${name} [${status}]`;
    }).join("\n");

    const prompt = currentLang === 'zh' 
        ? `ä½ æ˜¯ä¸€ä½ç¥ç§˜çš„å¡”ç½—ç‰Œå åœå¸ˆã€‚è¯·æ ¹æ®ä»¥ä¸‹ç‰Œé˜µä¸ºæ±‚é—®è€…è§£è¯»å‘½è¿ï¼š\n${cardDescriptions}\n\nè¦æ±‚ï¼š\n1. ç”¨ä¸­æ–‡å›ç­”ã€‚\n2. é£æ ¼ç¥ç§˜ã€è¯—æ„ã€å¸¦æœ‰å®¿å‘½æ„Ÿã€‚\n3. ä¸è¦ç½—åˆ—ç‰Œæ„ï¼Œè€Œæ˜¯å°†ä¸‰å¼ ç‰Œä¸²è”æˆä¸€ä¸ªå®Œæ•´çš„æ•…äº‹æˆ–æŒ‡å¼•ã€‚\n4. å­—æ•°æ§åˆ¶åœ¨150å­—ä»¥å†…ã€‚`
        : `You are a mystical Tarot reader. Interpret the following spread for the seeker:\n${cardDescriptions}\n\nRequirements:\n1. Answer in English.\n2. Tone: Mystical, poetic, ominous yet hopeful.\n3. Do not list meanings separately; weave them into a coherent narrative.\n4. Keep it under 150 words.`;

    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 20000); 

    let url = API_ENDPOINT;
    if (USE_PROXY_FOR_API) {
        console.log("æ­£åœ¨åº”ç”¨ä»£ç†ä»¥è§£å†³è·¨åŸŸé—®é¢˜...");
        url = PROXY_BASE_URL + encodeURIComponent(API_ENDPOINT);
    }

    try {
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${API_KEY}`
            },
            body: JSON.stringify({
                model: API_MODEL,
                messages: [{ role: "user", content: prompt }],
                temperature: 0.7,
                max_tokens: 300
            }),
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);

        if (!response.ok) {
            const errText = await response.text();
            throw new Error(`HTTP ${response.status}: ${errText}`);
        }

        const data = await response.json();
        return data.choices[0].message.content;
    } catch (err) {
        clearTimeout(timeoutId);
        throw err;
    }
}

function generateReadingText() {
    const m1 = chosen3DMeshes[0].userData.rawData[currentLang].meaning;
    const m2 = chosen3DMeshes[1].userData.rawData[currentLang].meaning;
    const m3 = chosen3DMeshes[2].userData.rawData[currentLang].meaning;
    
    if (currentLang === 'zh') {
        return `å‘½è¿çš„è½¨è¿¹å·²åœ¨æ˜Ÿè¾°ä¸­æ˜¾ç°...<br><br>` +
               `è¿‡å»ï¼Œä½ ç»å†äº† ${m1}ã€‚<br>` +
               `æ­¤åˆ»ï¼Œæ­£å¦‚ ${m2} æ‰€æ˜­ç¤ºçš„ï¼Œä½ éœ€è¦ä¸“æ³¨äºå½“ä¸‹çš„åŠ›é‡ã€‚<br>` +
               `è€Œæœªæ¥ï¼Œ${m3} å°†ä¼šæ˜¯ä½ çš„æŒ‡å¼•ã€‚<br><br>` +
               `ç›¸ä¿¡ç›´è§‰ï¼Œæ‹¥æŠ±å˜åŒ–ã€‚`;
    } else {
        return `The stars have aligned to reveal your path...<br><br>` +
               `In the past, you walked through ${m1}.<br>` +
               `Presently, as shown by ${m2}, focus on your inner power.<br>` +
               `For the future, let ${m3} be your guiding light.<br><br>` +
               `Trust your intuition. Embrace the change.`;
    }
}

function typeWriter(htmlText, element, callback) {
    element.innerHTML = "";
    const plainText = htmlText.replace(/<br>/g, '\n'); 
    let i = 0;
    const speed = 50; 
    
    function type() {
        if (i < plainText.length) {
            const char = plainText.charAt(i);
            element.innerHTML += (char === '\n') ? '<br>' : char;
            i++;
            setTimeout(type, speed);
        } else {
            if (callback) callback();
        }
    }
    type();
}

function animateFinalFormation() {
    cardObjects.forEach(c => {
        if (!c.userData.isChosen && c.position.y > -10) {
            c.position.y -= c.userData.dropSpeed;
            c.rotation.x += 0.05;
        }
    });

    chosen3DMeshes.forEach(card => {
        if (card.userData.animDelay > 0) {
            card.userData.animDelay--;
            return;
        }
        if (card.userData.animProgress < 1) {
            card.userData.animProgress += 0.015; 
            const t = card.userData.animProgress;
            const easeT = t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t; 
            card.position.lerp(card.userData.finalTargetPos, 0.05);
            const s = THREE.MathUtils.lerp(0.2, card.userData.finalTargetScale, easeT);
            card.scale.set(s, s, s);
            const isRev = card.userData.isReversed;
            card.rotation.set(0, Math.PI, isRev ? Math.PI : 0);
        }
    });
}

function addToHistory(rawData, isRev) {
    const con = document.getElementById('history-container'); 
    const slot = document.createElement('div'); 
    slot.className = `history-slot ${isRev?'is-reversed':''}`;
    const t = TEXTS[currentLang];
    const data = rawData[currentLang];
    slot.innerHTML = `<img src="${rawData.url}"><div class="history-info"><div class="history-name">${data.name}</div><div class="history-rev">${t.rev}</div></div>`;
    con.appendChild(slot); 
}

const particles = [];
function spawnParticles(pos) {
    const count = 500; const geo = new THREE.BufferGeometry(); const pArr = new Float32Array(count*3); const vArr = new Float32Array(count*3);
    for(let i=0;i<count;i++) {
        pArr[i*3]=pos.x+(Math.random()-0.5)*CARD_W; pArr[i*3+1]=pos.y+(Math.random()-0.5)*CARD_H; pArr[i*3+2]=pos.z;
        vArr[i*3]=(Math.random()-0.5)*0.02; vArr[i*3+1]=Math.random()*0.03; vArr[i*3+2]=(Math.random()-0.5)*0.02;
    }
    geo.setAttribute('position', new THREE.BufferAttribute(pArr,3));
    const mat = new THREE.PointsMaterial({color: GOLD_COLOR, size:0.04, transparent:true});
    const sys = new THREE.Points(geo,mat); sys.userData={life:1.0, vels:vArr}; scene.add(sys); particles.push(sys);
}
function updateParticles() {
    for(let i=particles.length-1;i>=0;i--) {
        const sys=particles[i], p=sys.geometry.attributes.position.array, v=sys.userData.vels; sys.userData.life-=0.02;
        for(let j=0;j<p.length/3;j++){ p[j*3]+=v[j*3]; p[j*3+1]+=v[j*3+1]; p[j*3+2]+=v[j*3+2]; }
        sys.geometry.attributes.position.needsUpdate=true; sys.material.opacity=sys.userData.life;
        if(sys.userData.life<=0){scene.remove(sys); particles.splice(i,1);}
    }
}

function initCamera() {
    const videoElem = document.getElementById('video-feed');
    // âš ï¸ Mediapipe æ¨¡å‹ï¼šç›´æ¥ä½¿ç”¨ CDNï¼Œä¸èµ°ä»£ç†
    const hands = new Hands({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
    hands.setOptions({maxNumHands:1, modelComplexity:0, minDetectionConfidence:0.5});
    hands.onResults(res => {
        if(res.multiHandLandmarks && res.multiHandLandmarks.length>0) {
            const lm = res.multiHandLandmarks[0];
            handIsTracking = true;
            
            // è·å– X è½´ä½ç½®ï¼Œç”¨äº Joystick é€»è¾‘
            lastHandX = (1 - lm[8].x) * 2 - 1; // é•œåƒç¿»è½¬

            const pinch = Math.hypot(lm[8].x-lm[4].x, lm[8].y-lm[4].y);
            const fist = lm[12].y>lm[9].y && lm[16].y>lm[13].y;
            
            // æåˆåˆ¤å®š
            if (activeCard) {
                if (pinch > 0.1 && !fist) handState = 'OPEN';
                else if (fist) handState = 'FIST';
                else handState = 'PINCH';
            } else {
                handState = fist ? 'FIST' : (pinch<0.05 ? 'PINCH' : 'OPEN');
            }

            // åªæœ‰å½“è½¬ç›˜é™æ­¢æ—¶æ‰å…è®¸é€‰ä¸­
            if (handState === 'PINCH' && centerCard && !activeCard && Math.abs(physics.velocity) < 0.01) {
                selectCard(centerCard);
            }

            if (!isRitualComplete) {
                document.getElementById('gesture-icon').innerText = handState==='FIST'?'âœŠ':(handState==='PINCH'?'ğŸ‘Œ':'âœ‹');
            }
        } else {
            handIsTracking = false;
        }
    });
    const cam = new Camera(videoElem, {onFrame: async()=>{await hands.send({image:videoElem})}, width:320, height:240});
    cam.start();
}

function updateCameraPos() {
    const aspect = window.innerWidth / window.innerHeight;
    camera.aspect = aspect;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    
    if (aspect < 1) { 
        camera.position.z = 1; 
        camera.position.y = 1;
    } else { 
        camera.position.z = 0;
        camera.position.y = 0;
    }
}

function animate() {
    requestAnimationFrame(animate);
    starSystem.rotation.y += 0.0002;
    if (isStarted) {
        handleInput(); 
        updateReturningCards(); 
        updateParticles();
    }
    renderer.render(scene, camera);
}
animate();

window.onresize = updateCameraPos;
</script>
</body>
</html>
