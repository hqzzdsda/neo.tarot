<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Arcanum: Final Ritual</title>
    <style>
        /* --- å…¨å±€æ ·å¼ (Global Styles) --- */
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            /* ç§»é™¤ Google Fontsï¼Œæ”¹ç”¨ç³»ç»Ÿå®‰å…¨å­—ä½“ï¼Œé˜²æ­¢å›½å†…è®¿é—®å¡æ­» */
            font-family: 'Times New Roman', 'Songti SC', 'SimSun', serif; 
            user-select: none; 
            -webkit-tap-highlight-color: transparent; 
        }
        #canvas-container { 
            width: 100vw; 
            height: 100vh; 
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 1; 
        }
        
        /* --- åˆå§‹ç•Œé¢ (Start Screen) --- */
        #start-screen {
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            z-index: 100;
            background: radial-gradient(circle at center, rgba(0,0,0,0.4) 0%, rgba(0,0,0,0.95) 90%);
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center;
            transition: opacity 1.5s cubic-bezier(0.25, 1, 0.5, 1);
            color: #d4af37;
            padding: 20px;
            box-sizing: border-box;
        }

        /* æ ‡é¢˜åŠ¨ç”»ä¸æ ·å¼ */
        .title-group { 
            text-align: center; 
            margin-bottom: 5vh; 
            position: relative;
            animation: floatTitle 6s ease-in-out infinite; 
        }
        
        h1 { 
            font-size: 72px; 
            margin: 0; 
            letter-spacing: 20px; 
            font-weight: 800;
            background: linear-gradient(135deg, #fff 0%, #d4af37 50%, #996515 100%);
            -webkit-background-clip: text; 
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 20px rgba(212, 175, 55, 0.4));
            position: relative;
        }
        
        h2 { 
            font-size: 14px; 
            font-weight: 400; 
            letter-spacing: 8px; 
            color: #a0a0a0; 
            margin-top: 15px; 
            text-transform: uppercase; 
            opacity: 0.8;
            border-top: 1px solid rgba(212, 175, 55, 0.3); 
            display: inline-block; 
            padding-top: 15px; 
            width: 120%; 
            margin-left: -10%;
        }

        @keyframes floatTitle {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        /* é€‰é¡¹æŒ‰é’®ç½‘æ ¼ */
        .options-grid { 
            display: grid; 
            grid-template-columns: 1fr 1fr; 
            gap: 60px; 
            margin-bottom: 5vh; 
            text-align: center; 
            opacity: 0; 
            animation: fadeUp 1s ease-out 0.5s forwards; 
        }
        .option-group { 
            display: flex; 
            flex-direction: column; 
            gap: 20px; 
            align-items: center; 
        }
        .option-label { 
            font-size: 11px; 
            letter-spacing: 3px; 
            color: #666; 
            text-transform: uppercase; 
            margin-bottom: 5px; 
            font-weight: 600;
        }

        /* èƒ¶å›ŠæŒ‰é’®æ ·å¼ */
        .choice-btn {
            background: rgba(255, 255, 255, 0.03); 
            border: 1px solid rgba(212, 175, 55, 0.3); 
            color: #888;
            padding: 12px 0; 
            width: 160px;
            font-family: inherit; 
            font-size: 12px; 
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
            border-radius: 50px; 
            position: relative; 
            overflow: hidden;
            backdrop-filter: blur(2px);
        }
        
        .choice-btn.active { 
            border-color: #d4af37; 
            color: #fff; 
            background: rgba(212, 175, 55, 0.15); 
            box-shadow: 0 0 25px rgba(212, 175, 55, 0.15);
        }
        
        .choice-btn:hover { 
            border-color: #fff; 
            color: #fff; 
            transform: translateY(-2px); 
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }

        /* è¿›å…¥æŒ‰é’®ç‰¹æ•ˆ */
        #enter-btn {
            background: transparent; 
            color: #d4af37; 
            border: 1px solid #d4af37;
            padding: 18px 80px; 
            font-size: 16px; 
            letter-spacing: 8px; 
            cursor: pointer;
            font-family: inherit; 
            font-weight: 600; 
            border-radius: 50px; 
            transition: all 0.5s;
            position: relative; 
            overflow: hidden;
            opacity: 0; 
            animation: fadeUp 1s ease-out 0.8s forwards;
        }
        
        #enter-btn::before {
            content: ''; 
            position: absolute; 
            top: 0; 
            left: -100%; 
            width: 100%; 
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(212, 175, 55, 0.2), transparent);
            transition: 0.5s;
        }
        #enter-btn:hover::before { left: 100%; transition: 0.7s; }
        #enter-btn:hover { 
            background: #d4af37; 
            color: #000; 
            box-shadow: 0 0 40px rgba(212, 175, 55, 0.4); 
            transform: scale(1.05); 
            letter-spacing: 10px;
        }

        @keyframes fadeUp { 
            from { opacity: 0; transform: translateY(20px); } 
            to { opacity: 1; transform: translateY(0); } 
        }

        /* ç¥ç§˜å­¦é—ªå…‰ç²’å­ */
        .sparkle {
            position: absolute; 
            background: white; 
            border-radius: 50%;
            pointer-events: none; 
            opacity: 0;
            box-shadow: 0 0 10px #d4af37, 0 0 20px #d4af37;
            animation: sparkleFloat linear forwards;
        }
        @keyframes sparkleFloat {
            0% { opacity: 0; transform: translateY(0) scale(0); }
            50% { opacity: 1; transform: translateY(-50px) scale(1); }
            100% { opacity: 0; transform: translateY(-100px) scale(0); }
        }

        /* --- æ¸¸æˆå†… UI å±‚ --- */
        #ui-layer { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: 20; 
            pointer-events: none; 
            color: #d4af37; 
            opacity: 0; 
            transition: opacity 1.5s; 
        }
        
        /* å†å²è®°å½•æ  */
        #history-container {
            position: absolute; 
            top: 20px; 
            right: 20px;
            display: flex; 
            flex-direction: row; 
            gap: 15px;
            pointer-events: auto; 
            z-index: 30; 
            height: 100px; 
            align-items: flex-start;
            transition: opacity 1s ease;
        }
        .history-slot {
            width: 50px; 
            height: 85px; 
            background: #fff; 
            border: 2px solid #d4af37; 
            border-radius: 8px; 
            overflow: hidden;
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: flex-end;
            box-shadow: 0 4px 15px rgba(0,0,0,0.8); 
            flex-shrink: 0; 
            position: relative;
            animation: slotEnter 0.6s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        @keyframes slotEnter { 
            from { opacity:0; transform: translateY(-20px); } 
            to { opacity:1; transform: translateY(0); } 
        }
        .history-slot img { position: absolute; top:0; left:0; width: 100%; height: 100%; object-fit: cover; }
        .history-info { position: relative; z-index: 2; width: 100%; background: rgba(0,0,0,0.8); text-align: center; padding: 2px 0; border-top: 1px solid #d4af37; }
        .history-name { font-size: 8px; color: #d4af37; font-weight: 700; white-space: nowrap; transform: scale(0.9); }
        .history-rev { font-size: 7px; color: #ff3333; display: none; font-weight: bold; background: rgba(0,0,0,0.5); width:100%; }
        .is-reversed img { transform: rotate(180deg); }
        .is-reversed .history-rev { display: block; }

        /* åº•éƒ¨ HUD */
        #hud-center {
            position: absolute; 
            bottom: 8%; 
            left: 50%; 
            transform: translateX(-50%);
            text-align: center; 
            color: #d4af37; 
            pointer-events: none;
            width: 100%; 
            transition: opacity 1s;
        }
        #gesture-icon { font-size: 32px; display: block; margin-bottom: 10px; opacity: 0.9; text-shadow: 0 0 15px #d4af37;}
        #status-text { font-size: 11px; letter-spacing: 4px; text-transform: uppercase; font-weight: 600; opacity: 0.8; }

        /* æœ€ç»ˆç»“æœæ–‡å­—å®¹å™¨ */
        #final-text-container {
            position: absolute; 
            top: 65%; /* ç¨å¾®ä¸Šç§»ä»¥é€‚é…å°å±å¹• */
            left: 0; 
            width: 100%;
            text-align: center; 
            opacity: 0; 
            transition: opacity 2s;
            pointer-events: none; 
            display: flex; 
            justify-content: center; 
            gap: 120px; /* æ¡Œé¢ç«¯é—´è·æ”¹å¤§ */
            flex-wrap: wrap; /* å…è®¸æ¢è¡Œ */
            padding: 0 20px;
            box-sizing: border-box;
        }
        .final-card-label {
            display: flex; 
            flex-direction: column; 
            width: 220px; 
            color: #fff; 
            text-shadow: 0 0 10px #d4af37; 
            text-align: center;
            animation: textFloat 3s ease-in-out infinite alternate;
            margin-bottom: 20px;
        }
        @keyframes textFloat { from { transform: translateY(0); } to { transform: translateY(-5px); } }
        
        .final-name { font-size: 15px; font-weight: bold; color: #d4af37; margin-bottom: 8px; border-bottom: 1px solid rgba(212, 175, 55, 0.3); padding-bottom: 5px; }
        .final-meaning { font-size: 11px; color: #ccc; font-style: italic; line-height: 1.5; opacity: 0.8; }

        /* é‡å¯æŒ‰é’®åŒºåŸŸ (åŒ…å«æŸ¥çœ‹æŒ‡å¼•) */
        #end-ui {
            position: absolute; 
            bottom: 12%; 
            left: 0; 
            width: 100%;
            display: flex; 
            flex-direction: column; /* å‚ç›´æ’åˆ— */
            align-items: center;
            justify-content: center;
            opacity: 0; 
            pointer-events: none; 
            transition: opacity 1.5s; 
            z-index: 50;
            gap: 20px;
        }
        
        #restart-btn {
            background: rgba(0,0,0,0.7); 
            border: 1px solid #d4af37; 
            color: #d4af37;
            padding: 12px 50px; 
            font-size: 13px; 
            letter-spacing: 4px; 
            border-radius: 50px; 
            cursor: pointer; 
            font-family: inherit; 
            transition: 0.4s;
            backdrop-filter: blur(5px);
        }
        #restart-btn:hover { background: #d4af37; color: #000; box-shadow: 0 0 25px rgba(212, 175, 55, 0.6); }

        /* æ–°å¢ï¼šæŸ¥çœ‹æŒ‡å¼•æŒ‰é’® */
        #view-reading-btn {
            background: #d4af37;  /* é‡‘è‰²èƒŒæ™¯ */
            color: #000;          /* é»‘è‰²æ–‡å­— */
            border: 1px solid #d4af37;
            padding: 15px 60px;
            font-size: 14px;
            letter-spacing: 4px;
            border-radius: 50px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            transition: 0.4s;
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.4);
        }
        #view-reading-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 40px rgba(212, 175, 55, 0.8);
        }

        /* æ–°å¢ï¼šè§£è¯´æ–‡å­—å…¨å±å®¹å™¨ */
        #oracle-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 700px;
            text-align: center;
            color: #fff;
            font-size: 18px;       
            line-height: 2.0;      
            font-family: 'Noto Serif SC', serif;
            text-shadow: 0 0 10px #d4af37;
            z-index: 60;
            pointer-events: none; /* å¼€å§‹æ—¶ä¸å¯ç‚¹å‡» */
            opacity: 1;
        }

        /* Loading å‘¼å¸ç¯åŠ¨ç”» */
        @keyframes pulse { 0% { opacity: 0.4; } 50% { opacity: 1; } 100% { opacity: 0.4; } }

        /* --- åˆ¶ä½œäººå‘˜ä¿¡æ¯ --- */
        #credits {
            position: absolute; 
            bottom: 20px; 
            right: 25px;
            text-align: right; 
            color: #a0a0a0; 
            font-size: 10px;
            line-height: 1.6; 
            opacity: 0; 
            transition: opacity 1.5s;
            pointer-events: none; 
            z-index: 50; 
            font-family: 'Noto Serif SC', serif;
            letter-spacing: 1px;
        }

        #video-feed { position: absolute; bottom: 10px; right: 10px; width: 100px; opacity: 0; transform: scaleX(-1); pointer-events: none; border: 1px solid #d4af37; transition: opacity 0.5s; }
        #loader { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); color: #d4af37; letter-spacing: 6px; font-size: 12px; font-weight: bold; z-index: 200; }

        /* --- ç§»åŠ¨ç«¯é€‚é… (Responsive Styles) --- */
        @media (max-width: 768px) {
            h1 { font-size: 42px; letter-spacing: 8px; }
            h2 { font-size: 10px; letter-spacing: 4px; }
            .options-grid { grid-template-columns: 1fr; gap: 30px; margin-bottom: 30px; }
            .choice-btn { padding: 10px 0; width: 200px; }
            #enter-btn { padding: 15px 60px; font-size: 14px; }
            
            /* ç§»åŠ¨ç«¯å†å²è®°å½•ç½®é¡¶å±…ä¸­ */
            #history-container {
                top: 10px;
                right: 50%;
                transform: translateX(50%);
                height: 70px;
                gap: 10px;
            }
            .history-slot { width: 40px; height: 65px; }
            .history-name { font-size: 6px; }

            /* HUD è°ƒæ•´ */
            #hud-center { bottom: 15%; }
            #status-text { font-size: 10px; letter-spacing: 2px; }
            
            /* åˆ¶ä½œäººå‘˜ä¿¡æ¯ç¼©å° */
            #credits { text-align: center; right: 0; width: 100%; bottom: 10px; font-size: 8px; }
            
            /* æœ€ç»ˆç»“æœæ–‡å­—è°ƒæ•´ */
            #final-text-container { 
                top: 47%;           /* è°ƒæ•´å‚ç›´ä½ç½® */
                flex-direction: column; /* å¼ºåˆ¶å‚ç›´æ’åˆ—ï¼Œé˜²æ­¢æ–‡å­—æŒ¤å‹ */
                align-items: center;    /* å±…ä¸­å¯¹é½ */
                max-height: 40vh;       /* é™åˆ¶é«˜åº¦ï¼Œé˜²æ­¢é®æŒ¡åº•éƒ¨æŒ‰é’® */
                overflow-y: auto;       /* å¦‚æœæ–‡å­—å¤ªå¤šï¼Œå…è®¸æ»šåŠ¨ */
                gap: 10px; /* ç§»åŠ¨ç«¯é—´è·æ”¹å›å°å€¼ */
            }
            .final-card-label { width: 100%; max-width: 300px; }
            
            /* è§£è¯´æ–‡å­—åœ¨æ‰‹æœºä¸Šå°ä¸€ç‚¹ */
            #oracle-overlay { font-size: 14px; width: 90%; }
        }
    </style>
    
    <!-- åˆ‡æ¢ä¸º BootCDN çš„ Three.js é•œåƒï¼Œè§£å†³å›½å†…åŠ è½½é—®é¢˜ -->
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>
    <div id="loader"></div>

    <div id="start-screen">
        <div class="title-group">
            <h1>ARCANUM</h1>
            <h2 id="subtitle">The Virtual Ritual</h2>
        </div>

        <div class="options-grid">
            <div class="option-group">
                <div class="option-label" id="lbl-language">Language / è¯­è¨€</div>
                <button class="choice-btn active" onclick="setLang('en')" id="btn-en">English</button>
                <button class="choice-btn" onclick="setLang('zh')" id="btn-zh">ä¸­æ–‡</button>
            </div>
            <div class="option-group">
                <div class="option-label" id="lbl-input">Input / æ“æ§</div>
                <button class="choice-btn active" onclick="setInput('hand')" id="btn-hand">Hand Gesture âœ‹</button>
                <button class="choice-btn" onclick="setInput('mouse')" id="btn-mouse">Mouse / Touch ğŸ–±ï¸</button>
            </div>
        </div>

        <button id="enter-btn" onclick="enterExperience()">ENTER</button>
    </div>

    <div id="ui-layer">
        <div id="history-container"></div>
        <div id="final-text-container"></div>
        
        <!-- æ–°å¢ï¼šè§£è¯´æ–‡å­—å®¹å™¨ -->
        <div id="oracle-overlay"></div>

        <div id="end-ui">
            <!-- æ–°å¢ï¼šæŸ¥çœ‹æŒ‡å¼•æŒ‰é’® -->
            <button id="view-reading-btn" onclick="enterStarryVoid()">REVEAL DESTINY</button>
            <!-- åŸæœ‰ï¼šé‡å¯æŒ‰é’® (åˆå§‹éšè—) -->
            <button id="restart-btn" onclick="location.reload()" style="display:none">RESTART RITUAL</button>
        </div>
        
        <div id="credits">
            By: Jerry Hu & Gemini<br>huqiuzhi10@gmail.com
        </div>

        <div id="hud-center">
            <span id="gesture-icon">âœ‹</span>
            <div id="status-text">Wave to Turn Â· Pinch to Select</div>
        </div>
    </div>

    <video id="video-feed" playsinline></video>
    <div id="canvas-container"></div>

<script>
// ================= API é…ç½®åŒºåŸŸ =================
// ğŸ”´ è¯·åœ¨è¿™é‡Œå¡«å…¥ä½ çš„ DeepSeek API Key (sk-xxxxxxxx)
const API_KEY = "sk-92c5cec08baf4941a5ab5a185cd9c22f"; 

// DeepSeek å®˜æ–¹æ¥å£åœ°å€
const API_ENDPOINT = "https://api.deepseek.com/chat/completions"; 

// DeepSeek æ¨¡å‹åç§°
const API_MODEL = "deepseek-chat"; 

// ğŸ”µ ä»£ç†å¼€å…³ï¼šåªåœ¨æœ€åè°ƒç”¨ API æ—¶ç”Ÿæ•ˆ
// è®¾ç½®ä¸º true ä¼šé€šè¿‡å…¬å…±ä»£ç†è½¬å‘è¯·æ±‚ï¼Œä»¥è§£å†³è·¨åŸŸ(CORS)é—®é¢˜
const USE_PROXY_FOR_API = true;

// ä»£ç†æœåŠ¡åœ°å€ (ä»…åœ¨ API è°ƒç”¨ç¬é—´ä½¿ç”¨)
// å¤‡é€‰ 1: https://corsproxy.io/? (é€Ÿåº¦å¿«ï¼Œä½†æœ‰æ—¶è¢«å¢™)
// å¤‡é€‰ 2: https://api.allorigins.win/raw?url= (ç¨³å®šæ€§ä¸€èˆ¬)
const PROXY_BASE_URL = "https://corsproxy.io/?"; 

// è°ƒè¯•å¼€å…³ï¼šè®¾ä¸º true ä¼šå¼¹å‡ºé”™è¯¯è­¦å‘Šï¼Œå‘å¸ƒæ—¶è®¾ä¸º false
const DEBUG_MODE = true;
// ==============================================


// æ£€æµ‹æ˜¯å¦ç§»åŠ¨è®¾å¤‡
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

// 1. é—ªå…‰ç‰¹æ•ˆé€»è¾‘
function createSparkles() {
    const screen = document.getElementById('start-screen');
    if(screen.style.display === 'none') return; 

    const sparkle = document.createElement('div');
    sparkle.className = 'sparkle';
    
    // éšæœºä½ç½®
    const x = Math.random() * 100;
    const y = Math.random() * 100;
    sparkle.style.left = x + '%';
    sparkle.style.top = y + '%';
    
    // éšæœºå¤§å°å’ŒæŒç»­æ—¶é—´
    const size = Math.random() * 3 + 1; 
    sparkle.style.width = size + 'px';
    sparkle.style.height = size + 'px';
    sparkle.style.animationDuration = (Math.random() * 2 + 2) + 's'; 
    
    screen.appendChild(sparkle);

    // åŠ¨ç”»ç»“æŸåç§»é™¤
    setTimeout(() => { sparkle.remove(); }, 4000);
}
setInterval(createSparkles, 200);


/**
 * DATA & CONFIG
 */
const TEXTS = {
    en: {
        subtitle: "The Virtual Ritual",
        lblLang: "Language",
        lblInput: "Input Method",
        enter: "ENTER VOID",
        statusWave: "Wave to Turn Â· Pinch Center Card",
        statusMouse: "Move to Turn Â· Hold to Grab",
        statusTouch: "Tap left or right to Turn Â· Hold to Grab",
        statusFist: "FIST TO REVEAL",
        statusSpace: "SPACE / HOLD TO REVEAL",
        statusReveal: "OBSERVING FATE...",
        statusDone: "RITUAL COMPLETE",
        rev: "Reversed",
        restart: "RESTART RITUAL",
        btnHand: "Hand Gesture âœ‹", 
        btnMouse: isMobile ? "Touch Control ğŸ‘†" : "Mouse Control ğŸ–±ï¸"        
    },
    zh: {
        subtitle: "è™šæ‹Ÿå¡”ç½—ä»ªå¼",
        lblLang: "è¯­è¨€è®¾ç½®",
        lblInput: "æ“æ§æ–¹å¼",
        enter: "è¿›å…¥è™šç©º",
        statusWave: "æŒ¥æ‰‹è½¬åŠ¨ç‰Œé˜µ Â· æåˆæ‰‹æŒ‡é€‰ä¸­",
        statusMouse: "ç§»åŠ¨é¼ æ ‡è½¬åŠ¨ Â· æŒ‰ä½å·¦é”®æŠ“å–",
        statusTouch: "å·¦å³è½»ç‚¹è½¬åŠ¨ Â· é•¿æŒ‰æŠ“å–/æ­ç¤º",
        statusFist: "æ¡æ‹³æ­ç¤ºå‘½è¿",
        statusSpace: "æŒ‰ç©ºæ ¼ / é•¿æŒ‰æ­ç¤º",
        statusReveal: "æ­£åœ¨è§‚æµ‹å‘½è¿...",
        statusDone: "ä»ªå¼å®Œæˆ",
        rev: "é€†ä½",
        restart: "é‡æ–°å¼€å§‹ä»ªå¼",
        btnHand: "æ‰‹åŠ¿æ§åˆ¶ âœ‹", 
        btnMouse: isMobile ? "è§¦å±æ§åˆ¶ ğŸ‘†" : "é¼ æ ‡æ§åˆ¶ ğŸ–±ï¸"  
    }
};

// åŸºç¡€æ•°æ® (å®Œæ•´22å¼ )
const RWS_DATA = [
    { id: 0, en: { name: "The Fool", meaning: "New beginnings, innocence, spontaneity" }, zh: { name: "æ„šè€…", meaning: "æ–°çš„å¼€å§‹ï¼Œå¤©çœŸï¼Œè‡ªå‘æ€§ï¼Œå†’é™©" } },
    { id: 1, en: { name: "The Magician", meaning: "Manifestation, resourcefulness, power" }, zh: { name: "é­”æœ¯å¸ˆ", meaning: "æ˜¾åŒ–ï¼Œèµ„æºä¸°å¯Œï¼ŒåŠ›é‡ï¼Œåˆ›é€ åŠ›" } },
    { id: 2, en: { name: "High Priestess", meaning: "Intuition, sacred knowledge" }, zh: { name: "å¥³ç¥­å¸", meaning: "ç›´è§‰ï¼Œç¥åœ£çŸ¥è¯†ï¼Œæ½œæ„è¯†ï¼Œç¥ç§˜" } },
    { id: 3, en: { name: "The Empress", meaning: "Femininity, beauty, nature" }, zh: { name: "çš‡å", meaning: "å¥³æ€§åŠ›é‡ï¼Œç¾ä¸½ï¼Œè‡ªç„¶ï¼Œå­•è‚²" } },
    { id: 4, en: { name: "The Emperor", meaning: "Authority, establishment" }, zh: { name: "çš‡å¸", meaning: "æƒå¨ï¼Œä½“åˆ¶ï¼Œç»“æ„ï¼Œæ§åˆ¶" } },
    { id: 5, en: { name: "The Hierophant", meaning: "Spiritual wisdom, beliefs" }, zh: { name: "æ•™çš‡", meaning: "ç²¾ç¥æ™ºæ…§ï¼Œä¿¡ä»°ï¼Œä¼ ç»Ÿï¼Œæ•™å¯¼" } },
    { id: 6, en: { name: "The Lovers", meaning: "Love, harmony, choices" }, zh: { name: "æ‹äºº", meaning: "çˆ±ï¼Œå’Œè°ï¼Œå…³ç³»ï¼Œé€‰æ‹©" } },
    { id: 7, en: { name: "The Chariot", meaning: "Control, willpower, success" }, zh: { name: "æˆ˜è½¦", meaning: "æ§åˆ¶ï¼Œæ„å¿—åŠ›ï¼ŒæˆåŠŸï¼Œè¡ŒåŠ¨" } },
    { id: 8, en: { name: "Strength", meaning: "Strength, courage, persuasion" }, zh: { name: "åŠ›é‡", meaning: "åŠ›é‡ï¼Œå‹‡æ°”ï¼Œè¯´æœï¼Œå½±å“åŠ›" } },
    { id: 9, en: { name: "The Hermit", meaning: "Soul-searching, introspection" }, zh: { name: "éšå£«", meaning: "æ¢ç´¢å†…å¿ƒï¼Œå†…çœï¼Œç‹¬å¤„ï¼ŒæŒ‡å¼•" } },
    { id: 10, en: { name: "Wheel of Fortune", meaning: "Good luck, karma, destiny" }, zh: { name: "å‘½è¿ä¹‹è½®", meaning: "å¥½è¿ï¼Œä¸šåŠ›ï¼Œç”Ÿå‘½å‘¨æœŸï¼Œå‘½è¿" } },
    { id: 11, en: { name: "Justice", meaning: "Justice, fairness, truth" }, zh: { name: "æ­£ä¹‰", meaning: "æ­£ä¹‰ï¼Œå…¬å¹³ï¼ŒçœŸç†ï¼Œå› æœ" } },
    { id: 12, en: { name: "Hanged Man", meaning: "Pause, surrender, letting go" }, zh: { name: "å€’åŠäºº", meaning: "æš‚åœï¼Œè‡£æœï¼Œæ”¾æ‰‹ï¼Œæ–°è§†è§’" } },
    { id: 13, en: { name: "Death", meaning: "Endings, change, transformation" }, zh: { name: "æ­»ç¥", meaning: "ç»“æŸï¼Œæ”¹å˜ï¼Œè½¬åŒ–ï¼Œè¿‡æ¸¡" } },
    { id: 14, en: { name: "Temperance", meaning: "Balance, moderation, patience" }, zh: { name: "èŠ‚åˆ¶", meaning: "å¹³è¡¡ï¼Œé€‚åº¦ï¼Œè€å¿ƒï¼Œç›®æ ‡" } },
    { id: 15, en: { name: "The Devil", meaning: "Shadow self, addiction" }, zh: { name: "æ¶é­”", meaning: "é˜´æš—é¢ï¼Œæ‰§ç€ï¼Œæˆç˜¾ï¼ŒæŸç¼š" } },
    { id: 16, en: { name: "The Tower", meaning: "Sudden change, upheaval" }, zh: { name: "é«˜å¡”", meaning: "çªå˜ï¼Œå‰§å˜ï¼Œæ··ä¹±ï¼Œå¯ç¤º" } },
    { id: 17, en: { name: "The Star", meaning: "Hope, faith, renewal" }, zh: { name: "æ˜Ÿæ˜Ÿ", meaning: "å¸Œæœ›ï¼Œä¿¡å¿µï¼Œç›®æ ‡ï¼Œæ–°ç”Ÿ" } },
    { id: 18, en: { name: "The Moon", meaning: "Illusion, fear, anxiety" }, zh: { name: "æœˆäº®", meaning: "å¹»è§‰ï¼Œææƒ§ï¼Œç„¦è™‘ï¼Œæ½œæ„è¯†" } },
    { id: 19, en: { name: "The Sun", meaning: "Positivity, fun, warmth" }, zh: { name: "å¤ªé˜³", meaning: "ç§¯æï¼Œå¿«ä¹ï¼Œæ¸©æš–ï¼ŒæˆåŠŸ" } },
    { id: 20, en: { name: "Judgement", meaning: "Judgement, rebirth, calling" }, zh: { name: "å®¡åˆ¤", meaning: "å®¡åˆ¤ï¼Œé‡ç”Ÿï¼Œå†…å¿ƒå¬å”¤ï¼Œèµ¦å…" } },
    { id: 21, en: { name: "The World", meaning: "Completion, integration" }, zh: { name: "ä¸–ç•Œ", meaning: "å®Œæˆï¼Œæ•´åˆï¼Œæˆå°±ï¼Œåœ†æ»¡" } }
];

let currentLang = 'en';
// å¦‚æœæ˜¯æ‰‹æœºï¼Œé»˜è®¤ä½¿ç”¨ Mouse/Touch æ¨¡å¼
let controlMode = isMobile ? 'mouse' : 'hand'; 
let isStarted = false;
let deckList = [];

// Game Logic Params
const MAX_SELECTION = 3; 
let selectionCount = 0;
let isRitualComplete = false;
let chosen3DMeshes = [];

const RADIUS = 10;
const CARD_W = 1.5;
const CARD_H = 2.58;
const CORNER_R = 0.08;
const GOLD_COLOR = 0xd4af37;
const BG_COLOR = 0x000000;

// åˆå§‹åŒ–æŒ‰é’®çŠ¶æ€
window.onload = function() {
    setInput(controlMode);
    updateStartScreenText();
};

function setLang(lang) {
    currentLang = lang;
    document.querySelectorAll('[onclick^="setLang"]').forEach(b => b.classList.remove('active'));
    document.getElementById(`btn-${lang}`).classList.add('active');
    updateStartScreenText();
}

function setInput(mode) {
    controlMode = mode;
    document.querySelectorAll('[onclick^="setInput"]').forEach(b => b.classList.remove('active'));
    document.getElementById(`btn-${mode}`).classList.add('active');
}

function updateStartScreenText() {
    const t = TEXTS[currentLang];
    document.getElementById('subtitle').innerText = t.subtitle;
    document.getElementById('lbl-language').innerText = t.lblLang;
    document.getElementById('lbl-input').innerText = t.lblInput;
    document.getElementById('enter-btn').innerText = t.enter;
    document.getElementById('restart-btn').innerText = t.restart;
    // æ›´æ–°æŒ‰é’®æ–‡å­—
    document.getElementById('btn-hand').innerText = t.btnHand;
    document.getElementById('btn-mouse').innerText = t.btnMouse;
}

function enterExperience() {
    isStarted = true;
    const screen = document.getElementById('start-screen');
    screen.style.opacity = 0;
    screen.style.pointerEvents = 'none'; 
    setTimeout(() => { screen.style.display = 'none'; }, 1500);
    const ui = document.getElementById('ui-layer');
    ui.style.opacity = 1;
    
    // åˆå§‹åŒ–è¾“å…¥ç›‘å¬
    if (controlMode === 'hand') {
        document.getElementById('video-feed').style.opacity = 0.3;
        initCamera();
    } else {
        initMouseListeners();
        initTouchListeners(); // å¢åŠ è§¦æ‘¸ç›‘å¬
    }
    
    updateCameraPos(); // ç¡®ä¿ç›¸æœºä½ç½®æ­£ç¡®
    updateStatusText();
    spawnDeck();
}

/**
 * THREE.JS SCENE SETUP
 */
const scene = new THREE.Scene();
scene.background = new THREE.Color(BG_COLOR);
scene.fog = new THREE.FogExp2(BG_COLOR, 0.012);
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
// åˆå§‹ä½ç½®ç”± updateCameraPos å†³å®š

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
document.getElementById('canvas-container').appendChild(renderer.domElement);

const texLoader = new THREE.TextureLoader();
const texBackGlobal = texLoader.load('./cards/back.png'); 
texBackGlobal.anisotropy = renderer.capabilities.getMaxAnisotropy();
texBackGlobal.center.set(0.5, 0.5);

const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
scene.add(ambientLight);
const frontLight = new THREE.DirectionalLight(0xffeaac, 0.6);
frontLight.position.set(0, 2, 5);
scene.add(frontLight);

// Stars
const starGeo = new THREE.BufferGeometry();
const starPos = new Float32Array(2500*3);
for(let i=0;i<2500;i++) {
    const r = 20 + Math.random()*40;
    const theta = Math.random()*Math.PI*2;
    const phi = Math.acos(Math.random()*2-1);
    starPos[i*3] = r*Math.sin(phi)*Math.cos(theta);
    starPos[i*3+1] = r*Math.sin(phi)*Math.sin(theta);
    starPos[i*3+2] = r*Math.cos(phi);
}
starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
const starMat = new THREE.PointsMaterial({color: 0xcccccc, size: 0.06});
const starSystem = new THREE.Points(starGeo, starMat);
scene.add(starSystem);

/**
 * DECK CONSTRUCTION
 */
const deckGroup = new THREE.Group();
scene.add(deckGroup);
let cardObjects = [];

const shape = new THREE.Shape();
const w = CARD_W/2, h = CARD_H/2, r = CORNER_R;
shape.moveTo(-w+r, -h); shape.lineTo(w-r, -h); shape.quadraticCurveTo(w, -h, w, -h+r);
shape.lineTo(w, h-r); shape.quadraticCurveTo(w, h, w-r, h);
shape.lineTo(-w+r, h); shape.quadraticCurveTo(-w, h, -w, h-r);
shape.lineTo(-w, -h+r); shape.quadraticCurveTo(-w, -h, -w+r, -h);
const faceGeo = new THREE.ShapeGeometry(shape);

function fixUVs(geometry) {
    const posAttribute = geometry.attributes.position;
    const uvAttribute = geometry.attributes.uv;
    for (let i = 0; i < posAttribute.count; i++) {
        const x = posAttribute.getX(i);
        const y = posAttribute.getY(i);
        uvAttribute.setXY(i, (x / CARD_W) + 0.5, (y / CARD_H) + 0.5);
    }
    uvAttribute.needsUpdate = true;
}
fixUVs(faceGeo);

const matBase = { roughness: 0.6, metalness: 0.1 };
const edgeMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, ...matBase });
const outlineGeo = new THREE.EdgesGeometry(faceGeo);
const outlineMat = new THREE.LineBasicMaterial({ color: GOLD_COLOR, linewidth: 2 });

function createCardMesh(data, index, total) {
    const group = new THREE.Group();
    const texFront = texLoader.load(data.url);
    texFront.anisotropy = renderer.capabilities.getMaxAnisotropy();
    texFront.center.set(0.5, 0.5);
    
    const matBack = new THREE.MeshStandardMaterial({ map: texBackGlobal, ...matBase });
    const matFront = new THREE.MeshStandardMaterial({ map: texFront, ...matBase });

    const meshBack = new THREE.Mesh(faceGeo, matBack);
    meshBack.position.z = 0.005; 
    const meshFront = new THREE.Mesh(faceGeo, matFront);
    meshFront.rotation.y = Math.PI;
    meshFront.position.z = -0.005;
    const meshFiller = new THREE.Mesh(faceGeo, edgeMat);
    meshFiller.scale.set(0.995, 0.995, 1);
    
    // å–æ¶ˆé«˜å…‰ outline
    // const outlineMesh = new THREE.LineSegments(outlineGeo, outlineMat);
    // outlineMesh.position.z = 0.006; outlineMesh.visible = false;
    // group.userData.outline = outlineMesh;

    group.add(meshBack, meshFront, meshFiller);
    
    const step = (Math.PI * 2) / total;
    const theta = index * step;
    group.position.x = RADIUS * Math.sin(theta);
    group.position.z = -RADIUS * Math.cos(theta);
    group.lookAt(0, 0, 0);

    group.userData = { id: data.id, rawData: data, state: 'IDLE', theta: theta, isChosen: false };
    return group;
}

function spawnDeck() {
    if(!isStarted) return;
   // åˆ¤æ–­æ˜¯å¦æ˜¯ç«–å±ï¼ˆæ‰‹æœºï¼‰
    const isPortrait = window.innerHeight > window.innerWidth;
    
    // è®¾ç½®é«˜åº¦
    deckGroup.position.y = isPortrait ? 2.0 : 0; 
    
    deckGroup.clear(); cardObjects = [];
    
    // ç”Ÿæˆå¸¦è·¯å¾„æ•°æ®
    deckList = RWS_DATA.map(d => ({
        ...d,
        url: `./cards/${d.id}.png`
    }));

    deckList.sort(() => Math.random() - 0.5);
    
    deckList.forEach((item, i) => {
        const card = createCardMesh(item, i, deckList.length);
        deckGroup.add(card);
        cardObjects.push(card);
    });
    document.getElementById('loader').style.display = 'none';
}

/**
 * INTERACTION LOGIC
 */
let handState = 'OPEN';
let handX = 0;
let ringRotation = 0;
let activeCard = null;
let centerCard = null;

function initMouseListeners() {
    window.addEventListener('mousemove', (e) => {
        handX = (e.clientX / window.innerWidth) * 2 - 1;
    });
    window.addEventListener('mousedown', (e) => {
        if(e.button === 0) handState = 'PINCH'; 
        updateCursorIcon();
    });
    window.addEventListener('mouseup', () => {
        handState = 'OPEN';
        updateCursorIcon();
    });
    window.addEventListener('keydown', (e) => {
        if(e.code === 'Space') handState = 'FIST'; 
        updateCursorIcon();
    });
    window.addEventListener('keyup', (e) => {
        if(e.code === 'Space' && handState === 'FIST') handState = 'PINCH'; 
        else if (e.code === 'Space') handState = 'OPEN';
        updateCursorIcon();
    });
}

// è§¦æ‘¸äº‹ä»¶ç›‘å¬ (Mobile Support)
function initTouchListeners() {
    const container = document.getElementById('canvas-container');
    
    container.addEventListener('touchmove', (e) => {
        e.preventDefault(); // é˜²æ­¢æ»šåŠ¨
        const touch = e.touches[0];
        // æ¨¡æ‹Ÿé¼ æ ‡Xè½´ç§»åŠ¨ï¼Œæ§åˆ¶æ—‹è½¬
        handX = (touch.clientX / window.innerWidth) * 2 - 1;
    }, { passive: false });

    container.addEventListener('touchstart', (e) => {
        const touch = e.touches[0];
        handX = (touch.clientX / window.innerWidth) * 2 - 1;
        handState = 'PINCH'; 
        updateCursorIcon();
    }, { passive: false });

    container.addEventListener('touchend', (e) => {
        handState = 'OPEN';
        updateCursorIcon();
    });
}

function updateCursorIcon() {
    const icon = handState==='FIST'?'âœŠ':(handState==='PINCH'?'ğŸ¤': (isMobile ? 'ğŸ‘†' : 'ğŸ–±ï¸'));
    document.getElementById('gesture-icon').innerText = icon;
}

function updateStatusText() {
    const t = TEXTS[currentLang];
    const el = document.getElementById('status-text');
    if (isRitualComplete) {
        el.innerText = t.statusDone;
        return;
    }
    if (activeCard && activeCard.userData.state === 'SELECTED') {
        el.innerText = controlMode === 'hand' ? t.statusFist : t.statusSpace;
    } else if (activeCard && activeCard.userData.state === 'REVEALING') {
        el.innerText = t.statusReveal;
    } else {
        if (controlMode === 'hand') el.innerText = t.statusWave;
        else el.innerText = isMobile ? t.statusTouch : t.statusMouse; // åŒºåˆ†è§¦æ‘¸å’Œé¼ æ ‡æç¤º
    }
}

function handleInput() {
    if (!isStarted) return;
    if (isRitualComplete) {
        animateFinalFormation();
        return;
    }

    if (!activeCard && handState === 'OPEN') {
        const deadZone = 0.15;
        // ç§»åŠ¨ç«¯çµæ•åº¦è°ƒæ•´
        const speed = isMobile ? 0.015 : 0.02;
        if (Math.abs(handX) > deadZone) ringRotation += (handX - Math.sign(handX)*deadZone) * speed;
    }
    deckGroup.rotation.y = THREE.MathUtils.lerp(deckGroup.rotation.y, ringRotation, 0.05);

    let closestDist = Infinity;
    let newCenterCard = null;
    if (!activeCard) {
        cardObjects.forEach(card => {
            if (card.userData.state === 'IDLE' && !card.userData.isChosen) {
                const worldPos = new THREE.Vector3();
                card.getWorldPosition(worldPos);
                // ç§»åŠ¨ç«¯åˆ¤å®šèŒƒå›´æ”¾å®½
                if (worldPos.z < -RADIUS + 2.5 && Math.abs(worldPos.x) < (isMobile ? 2.0 : 1.5)) {
                    const dist = worldPos.distanceTo(camera.position);
                    if (dist < closestDist) { closestDist = dist; newCenterCard = card; }
                }
            }
            if (card.userData.outline) card.userData.outline.visible = false;
        });
    }

    if (newCenterCard) {
        centerCard = newCenterCard;
        if (centerCard.userData.outline) centerCard.userData.outline.visible = true;
    } else {
        centerCard = null;
    }

    if (handState === 'PINCH' && centerCard && !activeCard) selectCard(centerCard);

    if (activeCard) {
        // é€‰ä¸­åçš„å¡ç‰Œä½ç½®
        const targetZ = isMobile ? -3.5 : -2.2;
        activeCard.position.lerp(new THREE.Vector3(0, 0, targetZ), 0.1);
        
        if (activeCard.userData.state === 'SELECTED') {
            const idleQ = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, 0, 0));
            activeCard.quaternion.slerp(idleQ, 0.1);
            updateStatusText();
            
            if (handState === 'FIST' || (controlMode === 'mouse' && handState === 'PINCH')) {
                 if(!activeCard.userData.revealTimer) activeCard.userData.revealTimer = Date.now();
                 if(Date.now() - activeCard.userData.revealTimer > 500) {
                     revealCard(activeCard);
                 }
            } else if (handState === 'OPEN') {
                activeCard.userData.revealTimer = null;
                returnCard(activeCard);
            }
        }
    } else {
        updateStatusText();
    }
}

function selectCard(card) {
    if (selectionCount >= MAX_SELECTION) return;
    activeCard = card;
    card.userData.state = 'SELECTED';
    card.userData.revealTimer = Date.now(); // åˆå§‹åŒ–è®¡æ—¶å™¨
    if(card.userData.outline) card.userData.outline.visible = false;
    scene.attach(card); 
}

function returnCard(card) {
    deckGroup.attach(card);
    card.userData.state = 'RETURNING';
    activeCard = null;
}

function updateReturningCards() {
    cardObjects.forEach(card => {
        if (card.userData.state === 'RETURNING') {
            const targetPos = new THREE.Vector3(
                RADIUS * Math.sin(card.userData.theta), 
                0, 
                -RADIUS * Math.cos(card.userData.theta)
            );
            card.position.lerp(targetPos, 0.08); 
            const dummy = new THREE.Object3D();
            dummy.position.copy(card.position);
            dummy.lookAt(0,0,0);
            card.quaternion.slerp(dummy.quaternion, 0.08);
            if (card.position.distanceTo(targetPos) < 0.05) {
                card.userData.state = 'IDLE';
                card.position.copy(targetPos);
                card.lookAt(0,0,0);
            }
        }
    });
}

function revealCard(card) {
    if (card.userData.state === 'REVEALING') return;
    card.userData.state = 'REVEALING';
    updateStatusText();
    
    const isReversed = Math.random() < 0.5;
    card.userData.isReversed = isReversed;

    const startQ = card.quaternion.clone();
    const targetEuler = new THREE.Euler(0, Math.PI, isReversed ? Math.PI : 0);
    const targetQ = new THREE.Quaternion().setFromEuler(targetEuler);

    const data = card.userData.rawData;
    const name = data[currentLang].name;

    let p = 0;
    function animateFlip() {
        p += 0.03; 
        card.quaternion.slerpQuaternions(startQ, targetQ, p);
        if (p < 1) {
            requestAnimationFrame(animateFlip);
        } else {
            card.rotation.set(0, Math.PI, isReversed ? Math.PI : 0);
            document.getElementById('status-text').innerText = name.toUpperCase();
            setTimeout(() => { dissolve(card, isReversed); }, 2000);
        }
    }
    animateFlip();
}

function dissolve(card, isReversed) {
    spawnParticles(card.position);
    selectionCount++;
    addToHistory(card.userData.rawData, isReversed);
    card.visible = false;
    card.userData.isChosen = true;
    activeCard = null;
    chosen3DMeshes.push(card); 
    if (selectionCount >= MAX_SELECTION) startEndRitual();
}

function startEndRitual() {
    isRitualComplete = true;
    updateStatusText();
    
    document.getElementById('history-container').style.opacity = 0;
    document.getElementById('hud-center').style.opacity = 0;
    
    setTimeout(() => {
        // æ˜¾ç¤ºåº•éƒ¨UI
        document.getElementById('end-ui').style.opacity = 1;
        document.getElementById('end-ui').style.pointerEvents = 'auto';
        document.getElementById('credits').style.opacity = 1;

        // --- é€»è¾‘å˜æ›´ï¼šå…ˆæ˜¾ç¤ºæŸ¥çœ‹æŒ‡å¼•æŒ‰é’®ï¼Œéšè—é‡å¯æŒ‰é’® ---
        document.getElementById('view-reading-btn').style.display = 'block';
        document.getElementById('restart-btn').style.display = 'none';

        // è®¾ç½®æŒ‰é’®è¯­è¨€
        const btnText = currentLang === 'zh' ? "æ­ç¤ºæŒ‡å¼•" : "REVEAL FATE";
        document.getElementById('view-reading-btn').innerText = btnText;

    }, 3500);

    cardObjects.forEach(c => {
        if (!c.userData.isChosen) {
            c.userData.dropSpeed = 0.05 + Math.random() * 0.1;
        }
    });

    chosen3DMeshes.forEach((card, index) => {
        card.visible = true;
        scene.attach(card); 
        // ç»“æŸåŠ¨ç”»èµ·å§‹ä½ç½®
        card.position.set(4 + index*0.5, 3, -4); 
        card.scale.set(0.2, 0.2, 0.2);

        // å“åº”å¼æœ€ç»ˆä½ç½®è®¡ç®—
        const isPortrait = window.innerHeight > window.innerWidth;
        const gap = isPortrait ? 1.8 : 2.2;      
        const depth = isPortrait ? -7.0 : -6.0; 
        const targetY = isPortrait ? 3.0 : 0;
        
        card.userData.finalTargetPos = new THREE.Vector3((index - 1) * gap, targetY, depth);
        card.userData.finalTargetScale = 0.8;
        card.userData.animProgress = 0;
        card.userData.animDelay = index * 30; 
    });

    const textContainer = document.getElementById('final-text-container');
    const t = TEXTS[currentLang];
    
    chosen3DMeshes.forEach(card => {
        const div = document.createElement('div');
        div.className = 'final-card-label';
        const data = card.userData.rawData[currentLang];
        const revText = card.userData.isReversed ? ` (${t.rev})` : "";
        div.innerHTML = `<div class="final-name">${data.name}${revText}</div><div class="final-meaning">${data.meaning}</div>`;
        textContainer.appendChild(div);
    });
    setTimeout(() => { textContainer.style.opacity = 1; }, 2000);
}

// --- ä¿®æ”¹ï¼šè¿›å…¥æ˜Ÿç©ºè§£è¯´æ¨¡å¼ (æ”¯æŒå¼‚æ­¥ API) ---
async function enterStarryVoid() {
    // éšè—æŒ‰é’®å’Œæ ‡ç­¾
    document.getElementById('view-reading-btn').style.display = 'none';
    document.getElementById('final-text-container').style.opacity = 0;
    
    // éšè—æ‰€æœ‰3Då¡ç‰Œ
    chosen3DMeshes.forEach(mesh => { mesh.visible = false; });
    cardObjects.forEach(mesh => { mesh.visible = false; });

    const overlay = document.getElementById('oracle-overlay');
    
    // æ˜¾ç¤º Loading åŠ¨ç”»
    const loadingText = currentLang === 'zh' ? "æ­£åœ¨ä¸æ˜Ÿè¾°è¿æ¥..." : "Connecting with the stars...";
    overlay.innerHTML = `<div style="opacity:0.7; animation: pulse 1.5s infinite;">${loadingText}</div>`;

    // å®šä¹‰æ‰“å­—ç»“æŸåçš„å›è°ƒå‡½æ•°
    const onTypingComplete = () => {
        const restartBtn = document.getElementById('restart-btn');
        restartBtn.style.display = 'block';
        restartBtn.style.opacity = 0;
        let op = 0;
        const fadeTimer = setInterval(() => {
            if(op >= 1) clearInterval(fadeTimer);
            restartBtn.style.opacity = op;
            op += 0.05;
        }, 30);
    };

    // å°è¯•è°ƒç”¨ API
    if (API_KEY && API_KEY.length > 5) {
        try {
            const apiText = await callTarotAPI(chosen3DMeshes);
            typeWriter(apiText, overlay, onTypingComplete);
        } catch (e) {
            console.error("API Error:", e);
            
            // ğŸ”´ è°ƒè¯•æ¨¡å¼ï¼šå¼¹å‡ºé”™è¯¯è­¦å‘Š
            if (DEBUG_MODE) {
                // æç¤ºç”¨æˆ·å®‰è£…æ’ä»¶
                alert(`API è°ƒç”¨å¤±è´¥: ${e.message}\n\nã€è§£å†³æ–¹æ¡ˆã€‘\nDeepSeek API åœ¨æµè§ˆå™¨ç›´æ¥è°ƒç”¨æ—¶ä¼šè¢«æ‹¦æˆª (CORS Error)ã€‚\nè¯·å®‰è£…æµè§ˆå™¨æ’ä»¶ "Allow CORS: Access-Control-Allow-Origin" å¹¶å¼€å¯ï¼Œç„¶ååˆ·æ–°é¡µé¢é‡è¯•ã€‚`);
            }
            
            // å¤±è´¥åˆ™é™çº§åˆ°æœ¬åœ°æ–‡æ¡ˆ
            const fallbackText = generateReadingText(); 
            typeWriter(fallbackText, overlay, onTypingComplete);
        }
    } else {
        // æ²¡æœ‰ Keyï¼Œç›´æ¥ä½¿ç”¨æœ¬åœ°é€»è¾‘
        setTimeout(() => {
            const text = generateReadingText();
            typeWriter(text, overlay, onTypingComplete);
        }, 1500);
    }
}

// --- æ–°å¢ï¼šè°ƒç”¨ LLM API è·å–è§£è¯» (åŒ…å« Proxy é€»è¾‘) ---
async function callTarotAPI(cards) {
    const cardDescriptions = cards.map((c, i) => {
        const name = c.userData.rawData[currentLang].name;
        const posName = currentLang === 'zh' ? ["è¿‡å»", "ç°åœ¨", "æœªæ¥"][i] : ["Past", "Present", "Future"][i];
        const status = c.userData.isReversed 
            ? (currentLang === 'zh' ? "é€†ä½ (Reversed)" : "Reversed") 
            : (currentLang === 'zh' ? "æ­£ä½ (Upright)" : "Upright");
        return `${posName}: ${name} [${status}]`;
    }).join("\n");

    const prompt = currentLang === 'zh' 
        ? `ä½ æ˜¯ä¸€ä½ç¥ç§˜çš„å¡”ç½—ç‰Œå åœå¸ˆã€‚è¯·æ ¹æ®ä»¥ä¸‹ç‰Œé˜µä¸ºæ±‚é—®è€…è§£è¯»å‘½è¿ï¼š\n${cardDescriptions}\n\nè¦æ±‚ï¼š\n1. ç”¨ä¸­æ–‡å›ç­”ã€‚\n2. é£æ ¼ç¥ç§˜ã€è¯—æ„ã€å¸¦æœ‰å®¿å‘½æ„Ÿã€‚\n3. ä¸è¦ç½—åˆ—ç‰Œæ„ï¼Œè€Œæ˜¯å°†ä¸‰å¼ ç‰Œä¸²è”æˆä¸€ä¸ªå®Œæ•´çš„æ•…äº‹æˆ–æŒ‡å¼•ã€‚\n4. å­—æ•°æ§åˆ¶åœ¨150å­—ä»¥å†…ã€‚`
        : `You are a mystical Tarot reader. Interpret the following spread for the seeker:\n${cardDescriptions}\n\nRequirements:\n1. Answer in English.\n2. Tone: Mystical, poetic, ominous yet hopeful.\n3. Do not list meanings separately; weave them into a coherent narrative.\n4. Keep it under 150 words.`;

    // å¢åŠ  AbortController ç”¨äºè¶…æ—¶æ§åˆ¶
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 20000); // 20ç§’è¶…æ—¶

    // --- å…³é”®ä¿®æ”¹ï¼šåªåœ¨è¿™ä¸€æ­¥æ„å»ºä»£ç† URL ---
    let url = API_ENDPOINT;
    if (USE_PROXY_FOR_API) {
        console.log("æ­£åœ¨åº”ç”¨ä»£ç†ä»¥è§£å†³è·¨åŸŸé—®é¢˜...");
        // å°†ç›®æ ‡ API åœ°å€ç¼–ç åæ‹¼æ¥åˆ°ä»£ç†åœ°å€åé¢
        url = PROXY_BASE_URL + encodeURIComponent(API_ENDPOINT);
    }
    // -------------------------------------

    try {
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${API_KEY}`
            },
            body: JSON.stringify({
                model: API_MODEL,
                messages: [{ role: "user", content: prompt }],
                temperature: 0.7,
                max_tokens: 300
            }),
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);

        if (!response.ok) {
            const errText = await response.text();
            throw new Error(`HTTP ${response.status}: ${errText}`);
        }

        const data = await response.json();
        return data.choices[0].message.content;
    } catch (err) {
        clearTimeout(timeoutId);
        throw err;
    }
}

// --- å¤‡é€‰ï¼šç”Ÿæˆæœ¬åœ°è§£è¯´æ–‡æ¡ˆ ---
function generateReadingText() {
    const m1 = chosen3DMeshes[0].userData.rawData[currentLang].meaning;
    const m2 = chosen3DMeshes[1].userData.rawData[currentLang].meaning;
    const m3 = chosen3DMeshes[2].userData.rawData[currentLang].meaning;
    
    if (currentLang === 'zh') {
        return `å‘½è¿çš„è½¨è¿¹å·²åœ¨æ˜Ÿè¾°ä¸­æ˜¾ç°...<br><br>` +
               `è¿‡å»ï¼Œä½ ç»å†äº† ${m1}ã€‚<br>` +
               `æ­¤åˆ»ï¼Œæ­£å¦‚ ${m2} æ‰€æ˜­ç¤ºçš„ï¼Œä½ éœ€è¦ä¸“æ³¨äºå½“ä¸‹çš„åŠ›é‡ã€‚<br>` +
               `è€Œæœªæ¥ï¼Œ${m3} å°†ä¼šæ˜¯ä½ çš„æŒ‡å¼•ã€‚<br><br>` +
               `ç›¸ä¿¡ç›´è§‰ï¼Œæ‹¥æŠ±å˜åŒ–ã€‚`;
    } else {
        return `The stars have aligned to reveal your path...<br><br>` +
               `In the past, you walked through ${m1}.<br>` +
               `Presently, as shown by ${m2}, focus on your inner power.<br>` +
               `For the future, let ${m3} be your guiding light.<br><br>` +
               `Trust your intuition. Embrace the change.`;
    }
}

// --- æ‰“å­—æœºç‰¹æ•ˆ ---
function typeWriter(htmlText, element, callback) {
    element.innerHTML = "";
    const plainText = htmlText.replace(/<br>/g, '\n'); 
    let i = 0;
    const speed = 50; 
    
    function type() {
        if (i < plainText.length) {
            const char = plainText.charAt(i);
            element.innerHTML += (char === '\n') ? '<br>' : char;
            i++;
            setTimeout(type, speed);
        } else {
            if (callback) callback();
        }
    }
    type();
}

function animateFinalFormation() {
    cardObjects.forEach(c => {
        if (!c.userData.isChosen && c.position.y > -10) {
            c.position.y -= c.userData.dropSpeed;
            c.rotation.x += 0.05;
        }
    });

    chosen3DMeshes.forEach(card => {
        if (card.userData.animDelay > 0) {
            card.userData.animDelay--;
            return;
        }
        if (card.userData.animProgress < 1) {
            card.userData.animProgress += 0.015; 
            const t = card.userData.animProgress;
            const easeT = t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t; 
            card.position.lerp(card.userData.finalTargetPos, 0.05);
            const s = THREE.MathUtils.lerp(0.2, card.userData.finalTargetScale, easeT);
            card.scale.set(s, s, s);
            const isRev = card.userData.isReversed;
            card.rotation.set(0, Math.PI, isRev ? Math.PI : 0);
        }
    });
}

function addToHistory(rawData, isRev) {
    const con = document.getElementById('history-container'); 
    const slot = document.createElement('div'); 
    slot.className = `history-slot ${isRev?'is-reversed':''}`;
    const t = TEXTS[currentLang];
    const data = rawData[currentLang];
    slot.innerHTML = `<img src="${rawData.url}"><div class="history-info"><div class="history-name">${data.name}</div><div class="history-rev">${t.rev}</div></div>`;
    con.appendChild(slot); 
}

const particles = [];
function spawnParticles(pos) {
    const count = 500; const geo = new THREE.BufferGeometry(); const pArr = new Float32Array(count*3); const vArr = new Float32Array(count*3);
    for(let i=0;i<count;i++) {
        pArr[i*3]=pos.x+(Math.random()-0.5)*CARD_W; pArr[i*3+1]=pos.y+(Math.random()-0.5)*CARD_H; pArr[i*3+2]=pos.z;
        vArr[i*3]=(Math.random()-0.5)*0.02; vArr[i*3+1]=Math.random()*0.03; vArr[i*3+2]=(Math.random()-0.5)*0.02;
    }
    geo.setAttribute('position', new THREE.BufferAttribute(pArr,3));
    const mat = new THREE.PointsMaterial({color: GOLD_COLOR, size:0.04, transparent:true});
    const sys = new THREE.Points(geo,mat); sys.userData={life:1.0, vels:vArr}; scene.add(sys); particles.push(sys);
}
function updateParticles() {
    for(let i=particles.length-1;i>=0;i--) {
        const sys=particles[i], p=sys.geometry.attributes.position.array, v=sys.userData.vels; sys.userData.life-=0.02;
        for(let j=0;j<p.length/3;j++){ p[j*3]+=v[j*3]; p[j*3+1]+=v[j*3+1]; p[j*3+2]+=v[j*3+2]; }
        sys.geometry.attributes.position.needsUpdate=true; sys.material.opacity=sys.userData.life;
        if(sys.userData.life<=0){scene.remove(sys); particles.splice(i,1);}
    }
}

function initCamera() {
    const videoElem = document.getElementById('video-feed');
    const hands = new Hands({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
    hands.setOptions({maxNumHands:1, modelComplexity:0, minDetectionConfidence:0.5});
    hands.onResults(res => {
        if(res.multiHandLandmarks && res.multiHandLandmarks.length>0) {
            const lm = res.multiHandLandmarks[0];
            handX += ((1-lm[8].x)*2-1 - handX)*0.2;
            const pinch = Math.hypot(lm[8].x-lm[4].x, lm[8].y-lm[4].y);
            const fist = lm[12].y>lm[9].y && lm[16].y>lm[13].y;
            handState = fist ? 'FIST' : (pinch<0.05 ? 'PINCH' : 'OPEN');
            if (!isRitualComplete) {
                document.getElementById('gesture-icon').innerText = handState==='FIST'?'âœŠ':(handState==='PINCH'?'ğŸ‘Œ':'âœ‹');
            }
        }
    });
    const cam = new Camera(videoElem, {onFrame: async()=>{await hands.send({image:videoElem})}, width:320, height:240});
    cam.start();
}

// å“åº”å¼ç›¸æœºä½ç½®æ›´æ–°
function updateCameraPos() {
    const aspect = window.innerWidth / window.innerHeight;
    camera.aspect = aspect;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    
    // å…³é”®ï¼šç«–å±æ¨¡å¼ä¸‹ç›¸æœºåé€€ï¼Œä»¥ä¾¿çœ‹åˆ°å®Œæ•´çš„ç‰Œé˜µç¯
    if (aspect < 1) { // ç«–å±
        camera.position.z = 1; // è·ç¦»æ›´è¿œ
        camera.position.y = 1;
    } else { // æ¨ªå±
        camera.position.z = 0;
        camera.position.y = 0;
    }
}

function animate() {
    requestAnimationFrame(animate);
    starSystem.rotation.y += 0.0002;
    if (isStarted) {
        handleInput(); 
        updateReturningCards(); 
        updateParticles();
    }
    renderer.render(scene, camera);
}
animate();

window.onresize = updateCameraPos;
</script>
</body>
</html>
